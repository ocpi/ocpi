:toc:
:toclevels: 4
:sectnumlevels: 4
:outlinelevels: 4:0
:title-page:
:numbered:
:version-label: document version
:year: 2020
:protocol_version: 2.2
:revdate: 12-06-{year}
:document_header: OCPI {document_version}
:revnumber: {document_version}

= OCPI {protocol_version}: Open Charge Point Interface
https://github.com/ocpi & https://ocpi-protocol.org

<<<
:toc:



<<<

Copyright © 2014 – 2020 NKL. All rights reserved.

This document is made available under the _Creative Commons Attribution-
NoDerivatives 4.0 International Public License_

(https://creativecommons.org/licenses/by-nd/4.0/legalcode[https://creativecommons.org/licenses/by-nd/4.0/legalcode]).



<<<

*Version History*

[cols="4,5,6,16",options="header"]
|===
|Version |Date |Author |Description

|2.2-d2 |12-06-2020 | Robert de Leeuw +
_ihomer_ | 2nd documentation revision of the OCPI 2.2 spec. +
           Contains textual improvements and fixes some of the examples. +
           Most improvements in the tarrifs module, especially `step_size` is better explained.
|2.2 |30-09-2019 | Robert de Leeuw +
_ihomer_ |Added support for Roaming Hubs +
        Adds support for Platforms with multiple/different roles, additional roles +
        Adds support for smart charging +
        Lots of improvements to existing modules +
        See <<changelog_changelog,changelog>>
|2.1.1-d2 |	21-06-2019 |Robert de Leeuw +
                        ihomer |Fixes the command module documentation, fixes a lot of examples, lots of small textual improvements: see <<changelog_changelog,changelog>>
|2.1.1 |08-06-2017 | Robert de Leeuw +
                  _ihomer_  |Fixed 4 bugs found in OCPI 2.1, lots of small textual improvements: see <<changelog_changelog,changelog>>
|2.1 |08-04-2016 | Robert de Leeuw +
                _ihomer_  |Added <<mod_commands_commands_module,command module>>. +
 Added support for <<mod_tokens_real-time_authorization,real-time authorization>>. + 
 Lots of small improvements: see <<changelog_changelog,changelog>> 
|2.0-d2 |15-02-2016 | Robert de Leeuw +
                   _ihomer_  |2nd documentation revision of the OCPI 2.0 spec. +
 Only documentation updated: ConnectorType of Connector + 
 was not visible, credentials clarified, location URL + 
 segments incorrect (now string, was int), + 
 minor textual updates. + 
 DateTime with timezones is still an issue 
|2.0 |30-12-2015 | Robert de Leeuw +
                _ihomer_ +
                 Simon Philips +
                 _Becharged_ +
                 Chris Zwirello +
                 _The New Motion_ + 
                 Simon Schilling
                 |First official release of OCPI.
|0.4 |04-11-2014 | Olger Warnier +
                _The New Motion_  |First draft of OCPI. (Also known as Draft v4)
|0.3 |06-05-2014 | Olger Warnier +
                _The New Motion_  |First draft of OCPI. (Also known as Draft v3)
|===

*Document revisions*
There can be multiple documentation revisions of the same version of the OCPI protocol.

The newer documentation revisions of the same protocol version can never change the content of the messages: no new fields or renaming of fields. A new revision can only clarify/fix texts/descriptions and fix typos etc.

These documentation revisions (not the first) will be named: d2, d3, d4 etc.

Examples:

- OCPI 2.1.1 is a different protocol version of OCPI than OCPI 2.1.

- OCPI 2.2-d2 is the same protocol version as OCPI 2.2, but a newer documentation revision.


<<<

[[introduction_ocpi]]
== OCPI

[[introduction_ocpi_2.2]]
=== OCPI 2.2

OCPI 2.2 includes new functionality and improvements, compared to OCPI 2.1.1.


==== Changes/New functionality:

* Support for Hubs
[disc]
** <<transport_and_format_message_routing,Message routing headers>>
** <<mod_hub_client_info_module,Hub Client Info>>

* <<credentials_credentials_role_class,Support Platforms with multiple/different roles, additional roles>>
* <<mod_charging_profiles_module,Charging Profiles>>
* <<mod_sessions_set_charging_preferences,Preference based Smart Charging>>
* Improvements:
[disc]
** <<mod_cdrs_cdr_object,CDRs>>: Credit CDRs, VAT, Calibration law/Eichrecht support, Session_id, AuthorizationReference, CdrLocation, CdrToken
** <<mod_sessions_session_object,Sessions>>: VAT, CdrToken, How to add a Charging Period
** <<mod_tariffs_tariff_object,Tariffs>>: Tariff types, Min/Max price, reservation tariff, Much more examples
** <<mod_locations_location_object,Locations>>: Multiple Tariffs, Lost of small improvements
** <<mod_tokens_token_object,Tokens>>: Group_id, energy contract
** <<mod_commands_cancelreservation_object,Commands>>: Cancel Reservation added

For more information on detailed changes see <<changelog_changelog,changelog>>.


==== OCPI 2.2-d2
This new documentation revision of OCPI 2.2 contains textual improvements and fixes to JSON examples.
The Tariff module contains most of the improvements, and especially `step_size` needed a much better explanation and examples.

Many thanks to all the contributors that have taken the time and effort to commit issues and pushed pull requests with improvements.


[[introduction_introduction_and_background]]
=== Introduction and background

The Open Charge Point Interface (OCPI) enables a scalable, automated EV roaming setup between Charge Point Operators and e-Mobility Service Providers.
It supports authorization, charge point information exchange (including live status updates and transaction events),
charge detail record exchange, remote charge point commands and the exchange of smart-charging related information between parties.

It offers market participants in EV an attractive and scalable solution for (international) roaming between networks,
avoiding the costs and innovation-limiting complexities involved with today's non-automated solutions or with central roaming hubs.
As such it helps to enable EV drivers to charge everywhere in a fully-informed way,
helps the market to develop quickly and helps market players to execute their business models in the best way.

What does it offer (main functionality):

* A good roaming system (for bilateral usage and/or via a hub).
* Real-time information about location, availability and price.
* A uniform way of exchanging data (Notification Data Records and Charge Data Records), before during and after the transaction.
* Remote mobile support to access any Charge Point without pre-registration.

An international group of over 200 companies from all over the world already supports OCPI. Initiators are EV Box, New Motion, ElaadNL, BeCharged, GreenFlux and Last Mile Solutions.
Other participants include: Next Charge, Freshmile, Plugsurfing, E55C, GIREVE, OCN, ihomer, Rexel, Stromnetz Hamburg, Enervalis, Place to plug,
Plugsurfing, Ecomovement, Allego, Gronn Kontakt Norway, ENIO, Fastned, AvantIT, Chargemap, Involtum, Capitol Region Denmark,
Vattenfall, EON, ECY Conseil Emeric Chardiny, Eneco Mobility, Jedlix, MTC, Smartlab, Sodetrel, XXIMO, Mnemonics, Share & Charge,
Service House, Alfen / ICU, PI2 Consultancy, Pitpoint, Blue Corner, Building Energy, Chargestorm, Chargepoint, ESARJ, Chargelab.co,
MUVEXT, Next Green Car / Zap Map, Be Mo Tech, Parking Eagle, GraphDefined, Chargecloud, Rutgerplantengaconsulting, Everon, Tanqyou,
Electric Vehicle Association Scotland (EVA NCS), EV-Tech, Plugin Power, Last Mile Solutions, BIA Power, IBIL, Gridscape, Maxem, Virta,
EasyCharger, Total EV Charge, Gowithflow, EKAROS, Rexel US, Stekker App, Travelcard, Emobility Consulting.
The EVRoaming foundation supported by the Netherlands Knowledge Platform for Charging Infrastructure (NKL)
facilitates and coordinates this protocol to guarantee progress and ensure development and results.

This document describes a combined set of standards based on the work done in the past. Next to that,
the evolution of these standards and their use are taken into account and some elements have been updated to match nowadays use.

*OCPI is developed with support of:*

evRoaming4EU project and its partners: +
https://www.evroaming4.eu[https://www.evroaming4.eu]

image::images/evroamingeu_logo.png[evRoaming4EU logo,scale=50%]

ECISS project and its partners: +
https://www.nklnederland.nl/eciss[https://www.nklnederland.nl/eciss]

image::images/eciss_logo.png[ECISS logo]


The latest version of this specification can be found here: https://github.com/ocpi/ocpi[https://github.com/ocpi/ocpi]


<<<

[[terminology_terminology_and_definitions]]
== Terminology and Definitions

=== Requirement Keywords
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in https://www.ietf.org/rfc/rfc2119.txt[https://www.ietf.org/rfc/rfc2119.txt].

[[terminology_abbreviations]]
=== Abbreviations

[cols="2s,10",options="header"]
|===
|Abbr. |Description
|CDR   |Charge Detail Record.
|CPO   |Charging Point Operator.
|eMSP  |e-Mobility Service Provider.
|EV    |Electric Vehicle.
|EVSE  |Electric Vehicle Supply Equipment. Is considered as an independently operated and managed part of a Charge Point that can deliver energy to one EV at a time.
|JSON  |JavaScript Simple Object Notation.
|NAP   |National Access Point.
|NSP   |Navigation Service Provider.
|OCPP  |Open Charge Point Protocol.
|SCSP  |Smart Charging Service Provider.
|===


[[terminology_roles]]
=== EV Charging Market Roles

In the EV Charging landscape, different market roles can be identified.

[cols="3s,9",options="header"]
|===
|Role  |Description
|CPO   |Charging Point Operator. Operates a network of Charge Points.
|eMSP  |e-Mobility Service Provider. Gives EV drivers access to charging services.
|Hub   |Can connect one or more CPOs to one or more eMSPs.
|NAP   |National Access Point. Provides a national database with all (public) charging locations. Information can be sent and retrieved from the NAP. This makes it different from a typical NSP.
|NSP   |Navigation Service Provider. Provides EV drivers with location information of Charge Points. Usually only interested in Location information.
|Roaming Hub |See: Hub.
|SCSP  |Smart Charging Service Provider. Provides Smart Charging service to other parties. Might use a lot of different inputs to calculate Smart Charging Profiles.
|===

Some of these roles can be combined in one company. A Platform can provide service for multiple CPOs or eMSPs,
but also for both eMSPs and CPOs.

OCPI 2.0/2.1.1 had a very strict definition of roles: only CPO and eMSP. But this is rare in the real world,
there are almost no parties that are strictly CPO or eMSP and have their own platform. In the real world, lots of
parties provide service to CPOs that are not running their own platform.
A lot of CPOs are also eMSP. With OCPI 2.1.1 and earlier that meant having to set up an OCPI connection per role.

OCPI 2.2 introduces more roles and abstracts the role from the OCPI connection itself.
OCPI 2.2 talks about Platforms connecting to Platforms, or Platforms connecting via Hubs to other Platforms.
The Platform itself is not a role. The Platform provides services for 1 or more roles.

Examples of platforms:

* A pure CPO: Not providing services to other CPOs. Not being an eMSP. Running its own software that connects via OCPI. +
  Is defined in OCPI as a Platform has 1 CPO role, the CPO role of that company.
* A Company that has a cloud-based eMSP software solution,
  it offers to companies that want to be eMSP, but don't want to host/run their own software. +
  Is a Platform that has a number of eMSP roles, one for each eMSP the company is providing services for.
  Not for this company itself because the company itself is not an eMSP.
* A Company that operates public Charge Points and also provides eMSP service to EV drivers, running their own software platform. +
  Is seen in OCPI as a Platform that has 2 roles: CPO and eMSP for this company.
* If one the companies above starts to offer their service to other CPOs and eMSP, it is in OCPI still seen as 1 platform.
  This platform then provides multiple CPO and eMSP roles.


[[introduction_typical_roles]]
==== Typical OCPI implementations per Role

The following table shows the typical modules implemented by the different roles.
These are not required.
The table shows the typical communication role: Receiver, Sender or Both.

[cols="6,4,4,4,4,4,4",options="header"]
|===
|Modules
  |<<types_role_enum,CPO>>
  |<<types_role_enum,eMSP>>
  |<<types_role_enum,Hub>>
  |<<types_role_enum,NSP>>
  |<<types_role_enum,NAP>>
  |<<types_role_enum,SCSP>>
|<<mod_cdrs_cdrs_module,CDRs>>                                   |Sender   |Receiver |Both   |          |          |
|<<mod_charging_profiles_module,Charging Profiles>> |Receiver |         |Both   |          |          |Sender
|<<mod_commands_commands_module,Commands>>                   |Receiver |Sender   |Both   |          |          |
|<<credentials_credentials_endpoint,Credentials>>             |Both     |Both     |Both   |Both      |Both      |Both
|<<mod_hub_client_info_module,Hub Client Info>>       |Receiver |Receiver |Sender |Receiver  |Receiver  |Receiver
|<<mod_locations_locations_module,Locations>>               |Sender   |Receiver |Both   |Receiver  |Both      |
|<<mod_sessions_sessions_module,Sessions>>                   |Sender   |Receiver |Both   |          |          |Receiver
|<<mod_tariffs_tariffs_module,Tariffs>>                       |Sender   |Receiver |Both   |Receiver  |Both      |
|<<mod_tokens_tokens_module,Tokens>>                           |Receiver |Sender   |Both   |          |          |
|<<versions_module,Versions>>                |Both     |Both     |Both   |Both      |Both      |Both
|===


[[terminology_terms]]
=== Terminology

[cols="3s,9",options="header"]
|===
|Term  |Description
|Broadcast Push | When communicating via a Hub, a data owner can do a single call to the Hub, the Hub then calls all receiving systems. +
                  See: <<transport_and_format_message_routing_broadcast_push,Broadcast push>>
|Charge Point |The physical system where an EV can be charged. A Charge Point has one or more EVSEs. Sometimes called Charging Station
|Client Owned Objects | In a normal REST interface the server is the owner of data, when a new resource is created by calling POST, the server creates the URL where the resource can be found by a client. +
                        OCPI is different, in most modules the owner is the party pushing data to a server, to inform them of updates. +
                        For example Locations, the CPO owns a Location (Charge Point), when a new Charge Point is added, the CPO calls PUT on the eMSP systems to inform them about new locations. +
                        See: <<transport_and_format_client_owned_object_push,Client Owned Objects>>
|Configuration Module | OCPI Module needed to setup and maintain OCPI connections, but does not provide information for the EV driver:
                        <<credentials_credentials_endpoint,Credentials>>, <<versions_module,Versions>>
                        and <<mod_hub_client_info_module,Hub Client Info>>. +
                        Configuration Modules use <<transport_and_format_message_routing,message routing>>.
|Functional Module | OCPI Module that provides functionality/information for the EV Driver, such as: <<mod_tokens_tokens_module,Tokens>>,
                     <<mod_locations_locations_module,Locations>>, <<mod_cdrs_cdrs_module,CDRs>> etc. +
                     Functional Modules do NOT use message routing.
|Open Routing Request | This is for Platforms that are connected via a Hub. When a system sends a pull request to the Hub,
                        and does not know, or care about, the owner of information, but asks the Hub to route the GET to the correct Platform.
                        The Hub finds the correct Platform and routes the request to that Platform. +
                        See: <<transport_and_format_message_routing_open_routing_request,Open Routing Request>>
|Platform | Software that provides services via OCPI.
            A platform can provide service for a single eMSP or CPO, or for multiple CPOs or eMSPs.
            It can even provide services for both eMSPs and CPOs at the same time.
|Pull | A system calls GET request to retrieve information from the system that owns the data.
|Push | The system (owning the data) actively calls POST/PUT/PATCH to update other systems with new/updated information.
|===


[[terminology_provider_and_operator_abbreviation]]
=== Provider and Operator abbreviation

In OCPI it is advised to use eMI3 compliant names for Contract IDs and EVSE IDs. The provider and the operator name is important here,
to target the right provider or operator, they need to be known upfront, at least between the cooperating parties.

In several standards, an issuing authority is mentioned that will keep a central registry of known Providers and Operators.
At this moment, the following countries have an authority that keeps track of the known providers and operators:

[[terminology_the_netherlands]]
==== The Netherlands, Belgium and Luxembourg (BeNeLux)

The Dutch foundation, named http://www.eviolin.nl[eViolin] keeps the registry for The Netherlands, Belgium and Luxembourg.

* The list of operator IDs and provider IDs can be viewed on their website http://www.eviolin.nl/index.php/leden/[eViolin/Leden].

[[terminology_germany]]
==== Germany

The BDEW organisation keeps the registry for Germany in their general code number service https://bdew-codes.de/[bdew-codes.de].

* https://bdew-codes.de/Codenumbers/EMobilityId/ProviderIdList[Provider ID List] See https://bdew-codes.de/Codenumbers/EMobilityId/ProviderIdList[https://bdew-codes.de/Codenumbers/EMobilityId/ProviderIdList]
* https://bdew-codes.de/Codenumbers/EMobilityId/OperatorIdList[EVSE Operator ID List] See https://bdew-codes.de/Codenumbers/EMobilityId/OperatorIdList[https://bdew-codes.de/Codenumbers/EMobilityId/OperatorIdList]

[[terminology_austria]]
==== Austria

Austrian Mobile Power GmbH maintains a registry for Austria. This list is not publicly available.
For more information visit http://austrian-mobile-power.at/tools/id-vergabe/information/[austrian-mobile-power.at]

[[terminology_france]]
==== France

The AFIREV* organization will keep/keeps the registry for France. It provides operation Id for CPO and eMSP in compliance with eMI3 id structure. The prefix of these Ids is the “fr” country code. AFIREV will also be in charge of the definition of EVSE-Id structure, Charging-Pool-Id structure (location), and Contract-Id structure for France. AFIREV bases its requirements and recommendations on eMI3 definitions.

AFIREV stands for: Association Française pour l’Itinérance de la Recharge Électrique des Véhicules

[[terminology_charging_topology]]
=== Charging topology

The charging topology, as relevant to the eMSP, consists of three entities:

* _Connector_ is a specific socket or cable available for the EV to make use of.
* _EVSE_ is the part that controls the power supply to a single EV in a single session. An EVSE may provide multiple connectors but only one of these can be active at the same time.
* _Location_ is a group of one or more EVSEs that belong together geographically or spatially.

.Charging Topology schematic
image::images/topology.svg[Charging Topology schematic]

A Location is typically the exact location of one or more EVSEs, but it can also be the entrance of a parking garage or a gated community. It is up to the CPO to use whatever makes the most sense in a specific situation. Once arrived at the location, any further instructions to reach the EVSE from the Location are stored in the EVSE object itself (such as the floor number, visual identification or manual instructions).

[[terminology_variable_names]]
=== Variable names

To prevent issues with capitals in variable names, the naming in JSON is not CamelCase but snake_case. All variables are lowercase and include an underscore for a whitespace.

[[terminology_cardinality]]
=== Cardinality

When defining the cardinality of a field, the following symbols are used throughout this document:

[cols="1,9,1",options="header"]
|===
|Symbol |Description |Type
|? |An optional object. If not set, it might be `null`, or the field might be omitted. When the field is set to null or omitted and it has a default value, the value is the default value. |Object
|1 |Required object. |Object 
|* |A list of zero or more objects. If empty, it might be `null`, `[]` or the field might be omitted. |[Object] 
|+ |A list of at least one object. |[Object] 
|===


[[introduction_data_retention]]
=== Data Retention

OCPI does not specify how long a system should store data. Companies are RECOMMENDED to make this part of business contracts.
Parties also will need to oblige to local legislation.

==== Between OCPI version

When a new version of OCPI is implemented, the data exchanged via the old version does not have to be available via the newer version of OCPI.
Hence, the Version end-point will probably have different end-points per version. So when an object is stored with a URL that contains a version,
it is NOT REQUIRED to be available at a URL with a different version number.


<<<

[[supported_topologies]]
== Supported Topologies

OCPI started as a bilateral protocol, for peer-to-peer communication.
Soon parties started to use OCPI via Hubs, but OCPI 2.1.1 and earlier were not designed for that.
OCPI 2.2 introduces a solution for this: <<transport_and_format_message_routing,message routing>>.

OCPI 2.2 introduces Platforms that connect via OCPI instead of CPO and eMSP, more on this in: <<terminology_roles,EV Charging Market Roles>>

=== Peer-to-peer

The simplest topology is a bilateral connection: peer-to-peer between two platforms,
and in the most simple version each platform only has 1 role.

.peer-to-peer topology example
image::images/architecture_direct.svg[peer-to-peer topology example]


=== Multiple peer-to-peer connections

A more real-world topology where multiple parties connect their platforms
and each platform only has 1 role.
(Not every party necessarily connects with all the other parties with the other role).

.Multiple peer-to-peer topology example
image::images/architecture_multiple_direct_modified.svg[Multiple peer-to-peer topology example]

<<<
=== Peer-to-peer multiple the same roles

Some parties provide for example CPO or eMSP services for other companies.
So the platform hosts multiple parties with the same role.
This topology is a bilateral connection: peer-to-peer between two platforms,
and both platforms can have multiple roles.

.peer-to-peer with multiple roles topology example
image::images/architecture_platform_same_direct.svg[peer-to-peer with multiple roles topology example]


=== Peer-to-peer dual roles

Some parties have dual roles, most of the companies are CPO and eMSP.
This topology is a bilateral connection: peer-to-peer between two platforms,
and both platforms have the CPO and the eMSP roles.

.peer-to-peer with both CPO and eMSP roles topology example
image::images/architecture_platform_dual_direct.svg[peer-to-peer with both CPO and eMSP roles topology example]

<<<
=== Peer-to-peer mixed roles

Some parties have dual roles, or provide them to other parties and then connect to other companies that do the same.
This topology is a bilateral connection: peer-to-peer between two platforms,
and both platforms have multiple different and also the same roles.

.peer-to-peer with mixed roles topology example
image::images/architecture_platform_mixed_direct.svg[peer-to-peer with mixed roles topology example]

<<<
=== Multiple peer-to-peer

More a real-world topology when OCPI is used between market parties without a hub, all parties are platforms with multiple roles.

Disadvantage of this: requires a lot of connections between platforms to be setup, tested and maintained.

.peer-to-peer with mixed roles topology example
image::images/architecture_mutiple_platform_direct_modified.svg[peer-to-peer with mixed roles topology example]

<<<
=== Platforms via Hub

This topology has all Platforms only connect via a Hub, all communication goes via the Hub.

.Platforms connected via a Hub topology example
image::images/architecture_hub_simple_modified.svg[Platforms connected via a Hub topology example]

<<<
=== Platforms via Hub and direct

Not all Platforms will only communicate via a Hub.
There might be different reasons for Platforms to still have peer-to-peer connections.
The Hub might not yet support new functionality.
The Platforms use a custom module for some new project, which is not supported by the Hub.
etc.

.Platforms connected via a Hub and directly topology example
image::images/architecture_hub_and_direct_modified.svg[Platforms connected via a Hub and directly topology example]


<<<

:numbered:
[[transport_and_format_transport_and_format]]
== Transport and format

[[transport_and_format_json_http_implementation_guide]]
=== JSON / HTTP implementation guide

The OCPI protocol is based on HTTP and uses the JSON format. It follows a RESTful architecture for web services where possible.

[[transport_and_format_security_and_authentication]]
==== Security and authentication

The interfaces are protected on the HTTP transport level, with SSL and token-based authentication.
Please note that this mechanism does *not* require client-side certificates for authentication,
only server-side certificates to set up a secure SSL connection.


[[transport_and_format_authorization_header]]
==== Authorization header

Every OCPI HTTP request MUST add an 'Authorization' header. The header looks as follows:

[source]
----
  Authorization: Token IpbJOXxkxOAuKR92z0nEcmVF3Qw09VG7I7d/WCg0koM=
----

The literal 'Token' indicates that the token-based authentication mechanism is used, in OCPI this is called the 'credentials token'.
<<credentials_credentials_object,'Credentials tokens'>> are exchanged via the <<credentials_credentials_endpoint,credentials module>>.
These are different 'tokens' then the <<mod_tokens_token_object,Tokens>> exchanged via the <<mod_tokens_tokens_module,Token Module>>: Tokens used by drivers to authorize charging.
To prevent confusion, when talking about the token used here in the HTTP Authorization header, call them: 'Credentials Tokens'.

Its parameter is a string consisting of printable, non-whitespace ASCII characters. It contains the 'credentials token' Base64 encoded.

The credentials token must uniquely identify the requesting party.
This way, the server can use the information in the Authorization header to link the request to the correct requesting party's account.

If the header is missing or the credentials token doesn't match any known party then the server SHALL respond with an HTTP `401 - Unauthorized` status code.

When a server receives a request with a valid <<credentials_registration,`CREDENTIALS_TOKEN_A`>>, on another module
then: <<credentials_credentials_endpoint,`credentials`>>
or <<versions_module,`versions`>>,
the server SHALL respond with an HTTP `401 - Unauthorized` status code.


[[transport_and_format_pull_and_push]]
==== Pull and Push

OCPI supports both *Pull* and *Push* models. 

* *Push:* Changes in objects and new objects are sent (semi) real-time to the receiver.
* *Pull:* Receiver request a (full) list of objects every X times.

OCPI doesn't require parties to implement Push.
Pull is required, a receiver needs to be able to get _in-sync_ after a period of connection loss.

It is possible to implement a Pull only OCPI implementation, it might be a good starting point for an OCPI implementation.
However, it is strongly advised to implement Push for production systems that have to handle some load,
especially when several clients are requesting long lists frequently.
Push implementations tend to use fewer resources.
It is therefore advised to clients _pulling_ lists from a server to do this on a relative low polling interval: think in hours, not minutes,
and to introduce some splay (randomize the length of the poll interface a bit).


[[transport_and_format_request_format]]
==== Request format

The request method can be any of <<transport_and_format_get,GET>>, POST, <<transport_and_format_put,PUT>>, <<transport_and_format_patch,PATCH>> or DELETE. The OCPI protocol uses them in a way similar to REST APIs.

[cols="2,12",options="header"]
|===
|Method |Description

|<<transport_and_format_get,GET>> |Fetches objects or information. 
|POST |Creates new objects or information. 
|<<transport_and_format_put,PUT>> |Updates existing objects or information. 
|<<transport_and_format_patch,PATCH>> |Partially updates existing objects or information. 
|DELETE |Removes existing objects or information. 
|===

The HTTP header: Content-Type SHALL be set to `application/json` for any request that contains a message body: POST, PUT and PATCH.
When no body is present, probably in a GET or DELETE, then the Content-Type header MAY be omitted.


[[transport_and_format_get]]
===== GET

A server is not required to return all objects to a client, the server might for example not send all CDRs to a client,
because some CDRs do not belong to this client. 

When a client receives objects from the server that contain invalid JSON or invalid OCPI objects (For example: missing fields),
the client has no way of letting this know to the server. It is advised to log these errors and contact the server administrator about this.
When a list of objects contains some objects that are correct and some with 'problems' the client should at least process the correct OCPI objects. 

[[transport_and_format_pagination]]
====== Pagination

All GET methods that return a list of objects have pagination, this allows a client and server to control the number of objects
returned in the response to a GET request, while still enabling the client to retrieve all objects by doing multiple requests
with different parameters. Without pagination, the server has to return all objects in one response that could potentially contain millions of objects.

To enable pagination of the returned list of objects, additional URL parameters are allowed for the GET request and additional
headers need to be added to the response.

[[transport_and_format_paginated_request]]
====== Paginated Request

The following table lists all the parameters that have to be supported but might be omitted by a client request.

[cols="2,2,12",options="header"]
|===
|Parameter |Datatype |Description

|date_from |<<types_datetime_type,DateTime>> |Only return objects that have `last_updated` after or equal to this Date/Time (inclusive).
|date_to |<<types_datetime_type,DateTime>> |Only return objects that have `last_updated` up to this Date/Time, but not including (exclusive).
|offset |int |The offset of the first object returned. Default is 0 (the first object).
|limit |int |The maximum number of objects to GET. The server might decide to return fewer objects, either because there are no more objects, or the server limits the maximum number of objects to return. This is to prevent, for example, overloading the system.
|===

The `date_from` is inclusive and `date_to` exclusive, this way, when sequential requests with to the same end-point are done,
the next interval will have no overlap and the `date_from` of the next interval is simply the `date_to` of the previous interval.

Example: With offset=0 and limit=10 the server shall return the first 10 records (if 10 objects match the request). Then the next page starts with offset=10.

[[transport_and_format_paginated_response]]
====== Paginated Response

For pagination to work correctly, it is important that multiple calls to the same URL (including query parameters):
result in the same objects being returned by the server.
For this to be the case, the sequence of objects mustn't change, or as little as possible.
It is best practice to return the oldest (by creation date, not the `last_updated` field) first.
While a client crawls over the pages (multiple GET requests every time to the 'next' page Link), a new object might be created on the server.
The client detects this: the `X-Total-Count` will be higher on the next call.
But the client doesn't have to correct for this. Only the last page will be different (or an additional page).
So the client will not be required to crawl all pages all over again
when the client has reached to last page it has retrieved all relevant pages and is up to date.

NOTE: Some query parameters can cause concurrency problems. For example the `date_to` query parameter.
When there are for example 1000 objects matching a query for all objects with `date_to` before 2016-01-01.
While crawling over the pages one of these objects is updated.
The client detects this: `X-Total-Count` will be lower in the next request.
It is advised to redo the previous GET but then with the `offset` lowered by 1 (if the `offset` was not 0)
and after that continue crawling the 'next' page links.
When an object before this page has been updated, then the client has missed 1 object.

HTTP headers that have to be added to any paginated GET response.

[cols="3,2,10",options="header"]
|===
|HTTP Header |Datatype |Description

|Link |String |Link to the 'next' page should be provided when this is NOT the last page.
       The Link should also contain any filters present in the original request. See the examples below.
|X-Total-Count |int |(Custom HTTP Header) The total number of objects available in the server system that match the given query
                (including the given query parameters, for example: `date_to` and `date_from` but excluding `limit` and `offset`)
                and that are available to this client. For example: The CPO server might return less CDR objects to an eMSP then the total number of CDRs available in the CPO system.
|X-Limit |int |(Custom HTTP Header) The maximum number of objects that the server can return.
          Note that this is an upper limit. If there are not enough remaining objects to return,
          fewer objects than this upper limit number will be returned, X-Limit SHALL then still show the upper limit, not the number of objects returned.
|===


[[transport_and_format_pagination_examples]]
====== Pagination Examples

Example of a required OCPI pagination link header:

[source]
----
  Link: <https://www.server.com/ocpi/cpo/2.2/cdrs/?offset=150&limit=50>; rel="next"
----

After the client has called the given "next" page URL above the Link parameter will most likely look like this:

[source]
----
  Link: <https://www.server.com/ocpi/cpo/2.2/cdrs/?offset=200&limit=50>; rel="next"
----

Example of a query with filters: Client does a GET to: 

[source]
----
  https://www.server.com/ocpi/cpo/2.2/cdrs/?date_from=2016-01-01T00:00:00Z&date_to=2016-12-31T23:59:59Z
----

The server should return (when the server has enough objects and the limit is the amount of objects the server wants to send is 100.)
_(This example should have been on 1 line, but didn't fit the paper width.)_ 

[source]
----
  Link: <https://www.server.com/ocpi/cpo/2.2/cdrs/?offset=100
                 &limit=100&date_from=2016-01-01T00:00:00Z&date_to=2016-12-31T23:59:59Z>; rel="next"
----

Example of a server limiting the amount of objects returned: Client does a GET to:

[source]
----
  https://www.server.com/ocpi/cpo/2.2/cdrs/?limit=2000
----

The server should return (when the server has enough objects and the limit is the amount of objects the server wants to send is 100.) The `X-Limit` HTTP header should be set to 100 as well.

[source]
----
  Link: <https://www.server.com/ocpi/cpo/2.2/cdrs/?offset=100&limit=100>; rel="next"
----

[[transport_and_format_put]]
===== PUT

A PUT request must specify all required fields of an object (similar to a POST request).
Optional fields that are not included will revert to their default value which is either specified in the protocol or NULL.

[[transport_and_format_patch]]
===== PATCH

A PATCH request must only specify the object's identifier (if needed to identify this object) and the fields to be updated. Any fields (both required or optional) that are left out remain unchanged.

The MIME-type of the request body is: `application/json` and may contain the data as documented for each endpoint.

In case a PATCH request fails, the client is expected to call the <<transport_and_format_get,GET>> method to check the state of the object in the other party's system. If the object doesn't exist, the client should do a <<transport_and_format_put,PUT>>. 

[[transport_and_format_client_owned_object_push]]
==== Client Owned Object Push

Normal client/server RESTful services work in a way where the Server is the owner of the objects that are created.
The client requests a POST method with an object to the end-point URL.
The response sent by the server will contain the URL to the new object.
The client will request only one server to create a new object, not multiple servers.

Many OCPI modules work differently: the client is the owner of the object
and only pushes the information to one or more servers for information sharing purposes.
For example the CPO owns the Tariff objects and pushes them to a couple of eMSPs,
so each eMSP gains knowledge of the tariffs that the CPO will charge them for their customers' sessions.
eMSP might receive Tariff objects from multiple CPOs.
They need to be able to make a distinction between the different tariffs from different CPOs.

The distinction between objects from different CPOs/eMSPs is made based on
a {<<credentials_credentials_object,country_code>>}
and {<<credentials_credentials_object,party_id>>}.
The <<credentials_credentials_object,country_code>>
and <<credentials_credentials_object,party_id>>
of the other party are received during the <<credentials_credentials_endpoint,credentials>> handshake,
so that a server might know the values a client will use in an URL.

Client Owned Object URL definition: {base-ocpi-url}/{end-point}/{country-code}/{party-id}/{object-id}

Example of a URL to a Client Owned Object

[source]
----
  https://www.server.com/ocpi/cpo/2.2/tariffs/NL/TNM/14
----

POST is not supported for these kinds of modules.
PUT is used to send new objects to the servers. 

If a client tries to access an object with a URL that has a different
<<credentials_credentials_object,country_code>>
and/or <<credentials_credentials_object,party_id>>
then given during the <<credentials_credentials_endpoint,credentials>> handshake,
it is allowed the respond with an HTTP `404` status code, this way blocking client access to objects that do not belong to them.

To identify the owner of data, the party generating the information that is provided to other parties via OCPI,
a 'Data owner' is provided at the beginning of every module that has a clear owner.

[[transport_and_format_errors]]
===== Errors

When a client pushes a Client Owned Object, but the {object-id} in the URL is different from the id in the object being pushed,
server implementations are advised to return an <<status_codes_status_codes,OCPI status code>>:
<<status_codes_status_codes,2001>>.

[[transport_and_format_response_format]]
==== Response format
The content that is sent with all the response messages is an 'application/json' type and contains a JSON object with the following properties:

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|data |Array or Object or String |* or ? |Contains the actual response data object or list of objects from each request, depending on the cardinality of the response data, this is an array (card. * or +), or a single object (card. 1 or ?) 
|status_code |int |1 |OCPI status code, as listed in <<status_codes_status_codes,Status Codes>>, indicates how the request was handled. To avoid confusion with HTTP codes, OCPI status codes consist of four digits.
|status_message |<<types_string_type,string>> |? |An optional status message which may help when debugging. 
|timestamp |<<types_datetime_type,DateTime>> |1 |The time this message was generated. 
|===

For brevity's sake, any further examples used in this specification will only contain the value of the "data" field. In reality, it will always have to be wrapped in the above response format.

When a request cannot be accepted, the type response depends on the type of error. For more information see: <<status_codes_status_codes,Status codes>>

For errors on the HTTP layer, use HTTP error response codes, including the response format above, that contains more details. HTTP status codes are described on http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html[w3.org].


[[transport_and_format_example_version_information_response_list_of_objects]]
===== Example: Version information response (list of objects)

[source,json]
----
include::examples/transport_and_format_version_info_example.json[]
----

[[transport_and_format_example_version_details_response_one_object]]
===== Example: Version details response (one object)

[source,json]
----
include::examples/transport_and_format_version_details_example.json[]
----


[[transport_and_format_example_tokens_get_response_with_one_token_object_cpo_end-point_one_object]]
===== Example: Tokens GET Response with one Token object. (CPO end-point) (one object)

[source,json]
----
include::examples/transport_and_format_get_token_example.json[]
----

[[transport_and_format_example_tokens_get_response_with_list_of_token_objects_emsp_end-point_list_of_objects]]
===== Example: Tokens GET Response with list of Token objects. (eMSP end-point) (list of objects)

[source,json]
----
include::examples/transport_and_format_get_token_list_example.json[]
----

[[transport_and_format_example_response_with_an_error_contains_no_data_field]]
===== Example: Response with an error (contains no data field)

[source,json]
----
{
	"status_code": 2001,
	"status_message": "Missing required field: type",
	"timestamp": "2015-06-30T21:59:59Z"
}
----


[[transport_and_format_message_routing]]
==== Message Routing

When the development of OCPI was started, it was designed for peer-to-peer communication between CPO and eMSP.
This has advantages, but also disadvantages.
Having to set up and maintain OCPI connections to a lot of parties requires more effort than doing it for only a couple of connections.
By communication via one or more Hubs, the amount of OCPI connections is reduced,
while still being able to offer roaming to a lot of different parties and customers.

With the introduction of Message Routing, OCPI is now better usable for communication via Hubs.

All examples/sequence diagrams in this section use the roles CPO and eMSP as examples, they could be switched, it could be other roles.

===== Platforms
With Message Routing functionality it also becomes possible to support Platforms that host multiple roles.
A lot of parties are not only CPO or eMSP. Most are both CPO and eMSP.
Some parties are doing business in multiple counties, which means to operate with different `country_codes`
Some parties have a platform on which the host service for other CPOs/eMSPs.
Some parties are themselves CPO and host CPO services for others,
but other parties are (themselves) not a CPO or other role in the EV charging landscape
but do provide service to CPOs/eMSPs, etc.

===== Message Routing Headers
When OCPI is used to communicate to/from a Platform or via a Hub (which is almost always the case)
the following four HTTP headers are to be added to any request/response to allow messages to be routed.

When implementing OCPI these four headers SHALL be implemented for any request/response to/from a Functional Module.
This does not mean they have to be present in all request.
There are situation/special request where some headers can or shall be omitted, more on this later.

Only requests/responses from Function Modules: such as: <<mod_tokens_tokens_module,Tokens>>,
<<mod_locations_locations_module,Locations>>, <<mod_cdrs_cdrs_module,CDRs>> etc.
SHALL be routed, so need the routing headers.

The requests/responses to/from Configuration Modules: <<credentials_credentials_endpoint,Credentials>>,
<<versions_module,Versions>> and
<<mod_hub_client_info_module,Hub Client Info>> are not to be routed, and are for Platform-to-Platform
or Platform-to-Hub communication. Thus routing headers SHALL NOT be used with these modules.


[cols="4,2,14",options="header"]
|===
|HTTP Header |Datatype |Description

|OCPI-to-party-id |<<types_cistring_type,CiString>>(3)|'party id' of the connected party this message is to be sent to.
|OCPI-to-country-code |<<types_cistring_type,CiString>>(2)|'country code' of the connected party this message is to be sent to.
|OCPI-from-party-id |<<types_cistring_type,CiString>>(3)|'party id' of the connected party this message is sent from.
|OCPI-from-country-code |<<types_cistring_type,CiString>>(2)|'country code' of the connected party this message is sent from.
|===


.Example sequence diagram of a GET for 1 Object from a CPO to an eMSP.
image::images/sd_get_simple.svg[OCPI Sequence Diagram Hub GET]

.Example sequence diagram of a PUT via 2 Hubs.
image::images/sd_put_2_hubs.svg[OCPI Sequence Diagram Hub PUT with 2 Hubs]


[[transport_and_format_message_routing_broadcast_push]]
===== Broadcast Push

For simplicity, connected clients might push (POST, PUT, PATCH) information to all connected clients with an "opposite role",
for example: CPO pushing information to all eMSPs and NSPs, eMSP pushing information to all CPOs.
(The role "Other" is seen as an eMSP type of role, so Broadcast Push from a CPO is also sent to "Other".
Messages from "Other" are only sent to CPOs and not to eMSPs though.)

When using Broadcast Push, the Hub broadcasts received information to all connected clients.
To send data through a Hub might be very useful to share information like Locations or Tokens with all parties
connected to the Hub that have implemented the corresponding module.
This means only one request to the Hub will be necessary, as all connected clients will be served by the Hub.

To send a Broadcast Push, the client uses the party-id and country-code of the Hub in the 'OCPI-to-' headers.
The Hub parses the request and sends a response to the client, which optionally contains its own party-id and country-code in the 'OCPI-from-' headers.
The Hub then sends the pushed data to any client implementing the corresponding applicable module, using its own party-id and country-code in the 'OCPI-from-' headers.
The client receiving a Push from a Hub (with the Hubs information in the 'OCPI-from-' headers) will respond to
this Push with the Hubs party-id and country-code in the 'OCPI-to-' headers.

GET SHALL NOT be used in combination with Broadcast Push.
If the requesting party wants to GET information of which it does not know the receiving party,
an <<transport_and_format_message_routing_open_routing_request,Open Routing Request>> MUST be used. (see below)

Broadcast Push SHALL only be used with information that is meant to be sent to all other parties. It is useful to share data like
<<mod_tokens_tokens_module,Tokens>> and <<mod_locations_locations_module,Locations>>,
but not so much for <<mod_cdrs_cdrs_module,CDRs>> and <<mod_sessions_sessions_module,Sessions>>
as these pieces of information are specific to only one party and are possibly even protected by GDPR or other laws.

NOTE: For "Client Owned Objects", the party-id and country-code in the URL segments will still be the original party-id and country-code from the original client sending the Broadcast Push to the Hub.

.Example sequence diagram of a Broadcast Push from a CPO to multiple eMSPs.
image::images/sd_put_boardcast.svg[OCPI Sequence Diagram of a Broadcast Push from a CPO to multiple eMSPs]


[[transport_and_format_message_routing_open_routing_request]]
===== Open Routing Request
When a Hub has the intelligence to route messages based on the content of the request,
or the requesting party does not know the destination of a request, the 'OCPI-to-' headers can be omitted in the request towards the Hub.
The Hub can then decide to which party a request needs to be routed, or that it needs to be broadcasted if the destination cannot be determined.

This has nothing to do with <<transport_and_format_message_routing_broadcast_push,Broadcast Push>> though,
as <<transport_and_format_message_routing_broadcast_push,Broadcast Push>> only works for the <<transport_and_format_pull_and_push,Push model>>,
not for <<transport_and_format_get,GET>> requests.

Open Routing Requests are possible for GET (<<transport_and_format_get_all_via_hubs,Not GET ALL>>), POST, PUT, PATCH and DELETE.

.Example sequence diagram of a open routing GET from a CPO via the Hub.
image::images/sd_get_openrouting.svg[Example sequence diagram of a open routing GET from a CPO via the Hub]


[[transport_and_format_get_all_via_hubs]]
===== GET All via Hubs
A client (Receiver) can request a GET on the Sender interface of a module implemented by a Hub.
To request a GET All from a Hub, the client uses the party-id and country-code of the Hub in the 'OCPI-to-' headers,
and calls the GET method on the Sender interface of a module.

The Hub can then combine objects from different connected parties and return them to the client.

The client can determine the owner of the objects by looking at the `county_code` and `party_id` in the individual objects returned by the hub.

.Example sequence diagram of a GET All via the Hub, .
image::images/sd_get_all.svg[OCPI Sequence Diagram of a GET All via the Hub.]


===== Overview of required/optional routing headers for different scenarios

The following section shows which headers are required/optional and which 'OCPI-to-'/'OCPI-from-' IDs need to be used.

This is not an exclusive list, combinations are possible.

====== Party to Party (without Hub)

This table contains the description of which headers are required to be used for which message when a request is sent
directly from one platform provider to another platform provider, without a Hub in between.
The headers are addressing the parties to/from which the message is sent, not the platform itself.

[cols="8,10,8,8",options="header"]
|===
| Name | Route | TO Headers | FROM Headers
| Direct request | Requesting platform provider to Receiving platform provider | Receiving-party | Requesting-party
| Direct response | Receiving platform provider to Requesting platform provider | Requesting-party | Receiving-party
|===

.Example sequence diagram of a GET for 1 Object from a CPO on one platform to an MSP on another platform directly (without a Hub)
image::images/sd_platform_to_platform_direct.svg[Example sequence diagram of a GET for 1 Object from a CPO on one platform to an MSP on another platform directly (without a Hub)]


====== Party to Party via Hub

This table contains the description of which headers are required to be used for which message when a request is routed from one platform to another platform via a Hub.

[cols="8,10,8,8",options="header"]
|===
| Name | Route | TO Headers | FROM Headers
| Direct request | Requesting platform to Hub | Receiving-party | Requesting-party
| Direct request | Hub to receiving platform | Receiving-party | Requesting-party
| Direct response | Receiving platform to Hub | Requesting-party | Receiving-party
| Direct response | Hub to requesting platform | Requesting-party | Receiving-party
|===

.Example sequence diagram of a GET for 1 Object from one Platform to another Platform via a Hub
image::images/sd_platform_hub_platform.svg[Example sequence diagram of a GET for 1 Object from one Platform to another Platform via a Hub]


====== Party to Party Broadcast Push

This table contains the description of which headers are required to be used for which message when a request is a
<<transport_and_format_message_routing_broadcast_push,Broadcast Push>> to the Hub.
[cols="8,10,8,8",options="header"]
|===
| Name | Route | TO Headers | FROM Headers
| Broadcast request | Requesting platform to Hub | Hub | Requesting-party
| Broadcast response | Hub to requesting platform | Requesting-party | Hub
| Broadcast request | Hub to receiving platform | Receiving-party| Hub
| Broadcast response | Receiving platform to Hub | Hub | Receiving-party
|===

.Example sequence diagram of Broadcast Push from one Platform to another Platform via a Hub
image::images/sd_platform_hub_platform_broadcast.svg[Example sequence diagram of Broadcast Push from one Platform to another Platform via a Hub]


====== Party to Party Open Routing Request

This table contains the description of which headers are required to be used for which message when <<transport_and_format_message_routing_open_routing_request,the routing of a request needs to be determined by the Hub itself>>.
For an Open Routing Request, the TO headers in the request from the requesting party to the Hub MUST be omitted.
[cols="8,10,8,8",options="header"]
|===
| Name | Route | TO Headers | FROM Headers
| Open request | Requesting platform to Hub | | Requesting-party
| Open request | Hub to receiving platform | Receiving-party | Requesting-party
| Open response | Receiving platform to Hub | Requesting-party | Receiving-party
| Open response | Hub to requesting platform | Requesting-party | Receiving-party
|===

.Example sequence diagram of a open routing between platforms  GET from a CPO via the Hub
image::images/sd_get_openrouting_platform.svg[Example sequence diagram of a open routing between platforms  GET from a CPO via the Hub]

===== GET All via Hubs
This table contains the description of which headers are required to be used when doing a <<transport_and_format_get_all_via_hubs,GET All via a Hub>>.
For a GET All via Hub: The HTTP Method SHALL be GET, The call is to a Senders Interface, the TO headers in the request to the Hub has to be set to the Hub.

[cols="8,10,8,8",options="header"]
|===
| Name | Route | TO Headers | FROM Headers
| GET All via Hubs request | Requesting platform to Hub | Hub | Requesting-party
| GET All via Hubs response | Hub to receiving platform | Requesting-party | Hub
|===

.Example sequence diagram of a GET All via the Hub, .
image::images/sd_get_all_platform.svg[OCPI Sequence Diagram of a GET All via the Hub.]


===== Timestamps and Objects send via Hubs
When OCPI Objects are sent via Hubs, the `last_updated` fields SHALL NOT be updated by the Hub.


[[transport_and_format_unique_messageg_ids]]
=== Unique message IDs

For debugging issues, OCPI implementations are required to include unique IDs via HTTP headers in every request/response.

[cols="3,10",options="header"]
|===
|HTTP Header |Description

|X-Request-ID     |Every request SHALL contain a unique request ID, the response to this request SHALL contain the same ID.
|X-Correlation-ID |Every request/response SHALL contain a unique correlation ID, every response to this request SHALL contain the same ID.
|===

It is advised to used GUID/UUID as values for X-Request-ID and X-Correlation-ID.

When a Hub forwards a request to a party, the request to this party SHALL contain a new unique value in the X-Request-ID HTTP header,
not a copy of the X-Request-ID HTTP header taken from the incoming request that is being forwarded.

When a Hub forwards a request to a party, the request SHALL contain the same X-Correlation-ID HTTP header (with the same value).

.Example sequence diagram of the uses of X-Request-ID and X-Correlation-ID in a peer-to-peer topology.
image::images/unqiue_ids_pair2pair.svg[Example sequence diagram of the uses of X-Request-ID and X-Correlation-ID in a peer-to-peer topology.]

.Example sequence diagram of the uses of X-Request-ID and X-Correlation-ID in a topology with a Hub.
image::images/unqiue_ids_via_hub.svg[Example sequence diagram of the uses of X-Request-ID and X-Correlation-ID in a topology with a Hub.]


[[transport_and_format_interface_endpoints]]
=== Interface endpoints

As OCPI contains multiple interfaces. Different endpoints are available for messaging.
The protocol is designed such that the exact URLs of the endpoints can be defined by each party.
It also supports an interface per version.

The locations of all the version-specific endpoints can be retrieved by fetching the API information from the versions endpoint.
Each version-specific endpoint will then list the available endpoints for that version.
It is strongly recommended to insert the protocol version into the URL.

For example: `/ocpi/cpo/2.2/locations` and `/ocpi/emsp/2.2/locations`.

The URLs of the endpoints in this document are descriptive only. The exact URL can be found by fetching the endpoint information from the API info endpoint and looking up the identifier of the endpoint.

[cols="4,2,10",options="header"]
|===
|Operator interface |Identifier |Example URL 

|Credentials |credentials |`+https://example.com/ocpi/cpo/2.2/credentials+`
|Charging location details |locations |`+https://example.com/ocpi/cpo/2.2/locations+`
|===

[cols="4,2,10",options="header"]
|===
|eMSP interface |Identifier |Example URL 

|Credentials |credentials |`+https://example.com/ocpi/emsp/2.2/credentials+`
|Charging location updates |locations |`+https://example.com/ocpi/emsp/2.2/locations+`
|===

[[transport_and_format_offline_behaviour]]
=== Offline behaviour

During communication over OCPI, one of the communicating parties might be unreachable for an undefined amount of time.
OCPI works event-based, new messages and status are pushed from one party to another. When communication is lost, updates cannot be delivered.

OCPI messages SHOULD NOT be queued. When a client does a POST, PUT or PATCH request and that request fails or times out,
the client should not queue the message and retry the same message again later. 

When the connection is re-established, it is up to the target-server of a connection to
GET the current status from to source-server to get back to a synchronized state.

For example:

- CDRs of the period of communication loss can be retrieved with a GET command on the CDRs module, with filters to retrieve only CDRs of the period since the last CDR has been received.
- Status of EVSEs (or Locations) can be retrieved by calling a GET on the Locations module.


<<<

[[status_codes_status_codes]]
== Status codes

There are two types of status codes:

- Transport related (HTTP)
- Content related (OCPI)

The transport layer ends after a message is correctly parsed into a (semantically unvalidated) JSON structure.
When a message does not contain a valid JSON string, the HTTP error `400 - Bad request` MUST be returned.

If a request is syntactically valid JSON and addresses an existing resource, a HTTP error MUST NOT be returned.
Those requests are supposed to have reached the OCPI layer. 

In case of a GET request, when the resource does NOT exist, the server SHOULD return a HTTP `404 - Not Found`.

When the server receives a valid OCPI object it SHOULD respond with:

* HTTP `200 - Ok` when the object already existed and has successfully been updated.
* HTTP `201 - Created` when the object has been newly created in the server system.

Requests that reach the OCPI layer SHOULD return an OCPI response message with a `status_code` field as defined below.

Custom status code range values SHALL NOT be used by standard OCPI module as described in this document!
When custom status codes are used, keep in mind that different custom modules could use the same values with a different meaning,
as they are not standardized.

[cols="3,10",options="header"]
|===
|Range |Description 

|1xxx |Success 
|2xxx |Client errors – The data sent by the client can not be processed by the server 
|3xxx |Server errors – The server encountered an internal error 
|===

When the status code is in the success range (1xxx), the `data` field in the response message SHOULD contain the information as specified in the protocol. Otherwise the `data` field is unspecified and MAY be omitted, set to `null` or something else that could help to debug the problem from a programmer's perspective. For example, it could specify which fields contain an error or are missing.


[[status_codes_1xxx_success]]
=== 1xxx: Success

[cols="3,10",options="header"]
|===
|Code |Description 

|1000 |Generic success code
|19xx |Reserved range for custom success status codes (1900-1999).
|===


[[status_codes_2xxx_client_errors]]
=== 2xxx: Client errors

Errors detected by the server in the message sent by a client where the client did something wrong.

[cols="3,10",options="header"]
|===
|Code |Description 

|2000 |Generic client error 
|2001 |Invalid or missing parameters 
|2002 |Not enough information, for example: Authorization request with too little information. 
|2003 |Unknown Location, for example: Command: START_SESSION with unknown location.
|2004 |Unknown Token, for example: 'real-time' authorization of an unknown Token.
|29xx |Reserved range for custom client error status codes (2900-2999).
|===


[[status_codes_3xxx_server_errors]]
=== 3xxx: Server errors

Error during processing of the OCPI payload in the server. The message was syntactically correct but could not be processed by the server.

[cols="3,10",options="header"]
|===
|Code |Description 

|3000 |Generic server error 
|3001 |Unable to use the client's API. For example during the credentials registration: When the initializing party requests data from the other party during the open POST call to its credentials endpoint. If one of the GETs can not be processed, the party should return this error in the POST response. 
|3002 |Unsupported version 
|3003 |No matching endpoints or expected endpoints missing between parties. Used during the registration process if the two parties do not have any mutual modules or endpoints available, or the minimal implementation expected by the other party is not been met.
|39xx |Reserved range for custom server error status codes (3900-3999).
|===


[[status_codes_4xxx_hub_errors]]
=== 4xxx: Hub errors

When a server encounters an error, client side error (2xxx) or server side error (3xxx), it sends the status code to the Hub.
The Hub SHALL then forward this error to the client which sent the request (when the request was not a Broadcast Push).

For errors that a Hub encounters while routing messages, the following OCPI status codes shall be used.

[cols="3,10",options="header"]
|===
|Code |Description

|4001 |Unknown receiver (TO address is unknown)
|4002 |Timeout on forwarded request (message is forwarded, but request times out)
|4003 |Connection problem (receiving party is not connected)
|49xx |Reserved range for custom hub error status codes (4900-4999).
|===


<<<

:numbered:
[[versions_module]]
== _Versions_ module

*Type:* Configuration Module

This is the required base module of OCPI. This module is the starting point for any OCPI connection.
Via this module, clients can learn <<version_information_endpoint_version_information_endpoint,which versions>>
of OCPI a server supports, and <<version_information_endpoint_version_details_endpoint,which modules>> it supports for each of the versions.

[[version_information_endpoint_version_information_endpoint]]
=== Version information endpoint

This endpoint lists all the available OCPI versions and the corresponding URLs to
where version specific details such as the supported endpoints can be found.

Endpoint structure definition:

No structure defined. This is open for every party to define themselves.

Examples:

`+https://www.server.com/ocpi/cpo/versions+`

`+https://www.server.com/ocpi/emsp/versions+`

`+https://ocpi.server.com/versions+`

The exact URL to the implemented version endpoint should be given (offline) to parties that want to communicate with your OCPI implementation.

Both, CPOs and eMSPs MUST implement such a version endpoint.

[cols="2,12",options="header"]
|===
|Method |Description 

|GET |Fetch information about the supported versions. 
|===

[[version_information_get_versions_endpoint_data]]
==== Data

[cols="2,1,10",options="header"]
|===
|Type |Card. |Description 

|<<version_information_endpoint_version_class,Version>> |+ |A list of supported OCPI versions. 
|===

[[version_information_endpoint_version_class]]
==== Version _class_

[cols="2,3,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|version |<<version_information_endpoint_versionnumber_enum,VersionNumber>> |1 |The version number. 
|url |<<types_url_type,URL>> |1 |URL to the endpoint containing version specific information. 
|===

[[version_information_endpoint_get]]
==== GET

Fetch all supported OCPI versions of this CPO or eMSP.

[[version_information_get_versions_endpoint_example]]
===== Example

[source,json]
----
include::examples/versions_info_example.json[]
----

[[version_information_endpoint_version_details_endpoint]]
=== Version details endpoint

Via the version details, the parties can exchange which modules are implemented for a specific version of OCPI,
which interface role is implemented, and what the endpoint URL is for this interface.

Parties that are both CPO and eMSP (or a Hub) can implement one version endpoint that covers both roles.
With the information that is available in the version details, parties don't need to implement a separate endpoint per role (CPO or eMSP) anymore.
In practice this means that when a company is both a CPO and an eMSP and it connects to another party that implements both interfaces, only one OCPI connection is needed.

NOTE: OCPI 2.2 introduces the role field in the version details.
Older versions of OCPI do not support this.

Endpoint structure definition:

No structure defined. This is open for every party to define themselves.

Examples:

`+https://www.server.com/ocpi/cpo/2.2+`

`+https://www.server.com/ocpi/emsp/2.2+`

`+https://ocpi.server.com/2.2/details+`

This endpoint lists the supported endpoints and their URLs for a specific OCPI version. To notify the other party that the list of endpoints of your current version has changed, you can send a PUT request to the corresponding credentials endpoint (see the credentials chapter).

Both the CPO and the eMSP MUST implement this endpoint.

[cols="2,12",options="header"]
|===
|Method |Description 

|GET |Fetch information about the supported endpoints for this version. 
|===


[[version_information_get_details_endpoint_data]]
==== Data

[cols="2,3,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|version |<<version_information_endpoint_versionnumber_enum,VersionNumber>> |1 |The version number. 
|endpoints |<<version_information_endpoint_endpoint_class,Endpoint>> |+ |A list of supported endpoints for this version. 
|===


[[version_information_endpoint_endpoint_class]]
==== Endpoint _class_

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|identifier |<<version_information_endpoint_moduleid_enum,ModuleID>> |1 |Endpoint identifier.
|role| <<version_information_endpoint_interface_role_enum,InterfaceRole>> |1 |Interface role this endpoint implements.
|url |<<types_url_type,URL>> |1 |URL to the endpoint. 
|===

NOTE: for the `credentials` module, the role is not relevant as this module is the same for all roles.


[[version_information_endpoint_interface_role_enum]]
==== InterfaceRole _enum_

[cols="3,10",options="header"]
|===
|Value |Description

|SENDER   |Sender Interface implementation. Interface implemented by the owner of data, so the Receiver can Pull information from the data Sender/owner.
|RECEIVER |Receiver Interface implementation. Interface implemented by the receiver of data, so the Sender/owner can Push information to the Receiver.
|===


[[version_information_endpoint_moduleid_enum]]
==== ModuleID _enum_

The Module identifiers for each endpoint are described in the beginning of each _Module_ chapter. The following table contains the list of modules in this version of OCPI. Most modules (except <<credentials_credentials_endpoint,Credentials &amp; Registration>>) are optional, but there might be dependencies between modules.
If there are dependencies between modules, it will be mentioned in the affected module description.

[cols="5,3,10",options="header"]
|===
|Module |ModuleID |Remark 

|<<mod_cdrs_cdrs_module,CDRs>> |cdrs |
|<<mod_charging_profiles_module,Charging Profiles>> |chargingprofiles |
|<<mod_commands_commands_module,Commands>> |commands |
|<<credentials_credentials_endpoint,Credentials &amp; Registration>> |credentials |Required for all implementations. +
                                                                   The `role` field has no function for this module.
|<<mod_hub_client_info_module,Hub Client Info>> |hubclientinfo |
|<<mod_locations_locations_module,Locations>> |locations |
|<<mod_sessions_sessions_module,Sessions>> |sessions |
|<<mod_tariffs_tariffs_module,Tariffs>> |tariffs |
|<<mod_tokens_tokens_module,Tokens>> |tokens |
|===

[[version_information_endpoint_versionnumber_enum]]
==== VersionNumber _enum_

List of known versions.

[cols="3,10",options="header"]
|===
|Value |Description 

|2.0 |OCPI version 2.0
|2.1 |OCPI version 2.1 (DEPRECATED, do not use, use 2.1.1 instead) 
|2.1.1 |OCPI version 2.1.1
|2.2 |OCPI version 2.2 (this version)
|===

[[version_information_endpoint_custom_modules]]
===== Custom Modules

Parties are allowed to create custom modules or customized versions of the existing modules.
To do so, the <<version_information_endpoint_moduleid_enum,ModuleID enum>> can be extended with additional custom moduleIDs.
These custom moduleIDs MAY only be sent to parties with which there is an agreement to use a custom module. Do NOT send custom moduleIDs to parties you are not 100% sure will understand the custom moduleIDs.
It is advised to use a prefix (e.g. country-code + party-id) for any custom moduleID, this ensures that the moduleID will not be used for any future module of OCPI.

For example:
`nltnm-tokens`

[[version_information_get_endpoint]]
==== GET

Fetch information about the supported endpoints and their URLs for this OCPI version.

[[version_information_get_details_endpoint_example]]
===== Examples

Simple version details example: CPO with only 2 modules.
[source,json]
----
include::examples/version_details_example.json[]
----

Simple version details example: party with both CPO and eMSP with only 2 modules.

In this case the `credentials` module is not defined twice as this module is the same for all roles.
[source,json]
----
include::examples/version_details_example2.json[]
----


<<<

:numbered:
[[credentials_credentials_endpoint]]
== _Credentials_ module

*Module Identifier: `credentials`*

*Type:* Configuration Module

The credentials module is used to exchange the credentials token that has to be used by parties for authorization of requests.

Every OCPI request is required to contain a credentials token in the <<transport_and_format_authorization_header,HTTP Authorization header>>.


[[credentials_use_cases]]
=== Use cases

[[credentials_registration]]
==== Registration

To start using OCPI, the Platforms will need to exchange credentials tokens.

To start the exchange of credentials tokens, one platform has to be selected as Sender for the Credentials module.
This has to be decided between the Platforms (outside of OCPI) before they first connect.

To start the credentials exchange, the Receiver Platform must create a unique credentials token: `CREDENTIALS_TOKEN_A`
that has to be used to authorize the Sender until the credentials exchange is finished.
This credentials token along with the versions endpoint SHOULD be sent to the Sender in a secure way that is outside the scope of this protocol.

The Sender starts the registration process, retrieves the version information and details (using `CREDENTIALS_TOKEN_A` in the HTTP Authorization header).
The Sender generates a unique credentials token: `CREDENTIALS_TOKEN_B`, sends it to the Receiver in a POST request to the `credentials` module of the Receiver.
The Receiver stores `CREDENTIALS_TOKEN_B` and uses it for any requests to the Sender Platform, including the version information and details.

The Receiver generates a unique credentials token: `CREDENTIALS_TOKEN_C` and returns it to the Sender in the response to the POST request from the Sender.

After the credentials exchange has finished, the Sender SHALL use `CREDENTIALS_TOKEN_C` in future OCPI request to the Receiver Platform.
The `CREDENTIALS_TOKEN_A` can then be thrown away, it MAY no longer be used.

(In the sequence diagrams below we use relative paths as short resource identifiers to illustrate API endpoints;
please note that they should be absolute URLs in any working implementation of OCPI.)

.The OCPI registration process
image::images/registration-sequence.svg[The OCPI registration process]

Due to its symmetric nature of the credentials module, any platform can be Sender and or the Receiver for this module.


[[credentials_updating_to_a_newer_version]]
==== Updating to a newer version

At some point, both platforms will have implemented a newer OCPI version.
To start using the newer version,
one platform has to send a PUT request to the credentials endpoint of the other platform.

.The OCPI update process
image::images/update-sequence.svg[The OCPI update process]

[[credentials_changing_endpoints_for_the_current_version]]
==== Changing endpoints for the current version

This can be done by following the update procedure for the same version.

By sending a PUT request to the credentials endpoint of this version,
the other platform will fetch and store the corresponding set of endpoints.


[[credentials_updating_the_credentials_and_resetting_the_token]]
==== Updating the credentials and resetting the credentials token

The credentials (or parts thereof, such as the credentials token) can be updated by sending the new credentials via
a PUT request to the credentials endpoint of the current version, similar to the update procedure described above.

Security advices:
When one of the connecting platforms suspects that a credentials token is compromised, that platform SHALL initiate a credentials token update as soon as possible.
It is advisable to renew the credentials tokens at least once a month, in case it was not detected that the credentials where compromised.

[[credentials_errors_during_registration]]
==== Errors during registration

When the server connects back to the client during the credentials registration, it might encounter problems.
When this happens, the server should add the status code <<status_codes_3xxx_server_errors,3001>>
in the response to the POST from the client.

[[credentials_required_endpoints_not_available]]
==== Required endpoints not available

When two platforms connect, it might happen that one of the platforms expects a certain endpoint to be available at the other platform.

For example: a Platform with a CPO role could only want to connect when the CDRs endpoint is available in an platform with an eMSP role.

In case the Sender (starting the credentials exchange process) cannot find the endpoints it expects,
it is expected NOT to send the POST request with credentials to the Receiver.
Log a message/notify the administrator to contact the administrator of the Receiver platform.

In case the Receiver platform that cannot find the endpoints it expects,
then it is expected to respond to the request with the status code <<status_codes_3xxx_server_errors,3003>>.


[[credentials_interfaces_and_endpoints]]
=== Interfaces and endpoints

The Credentials module is different from all other OCPI modules.
This module is symmetric, it has to be implemented by all OCPI implementations, and all implementations need to be able call
this module on any other platform, and have to be able the handle receiving the request from another party.

Example: `/ocpi/2.2/credentials` and `/ocpi/emsp/2.2/credentials`

[cols="2,12",options="header"]
|===
|Method |Description 

|<<credentials_get_method,GET>> |Retrieves the credentials object to access the server's platform. 
|<<credentials_post_method,POST>> |Provides the server with a credentials object to access the client's system (i.e. register). 
|<<credentials_put_method,PUT>> |Provides the server with an updated credentials object to access the client's system. 
|PATCH |n/a 
|<<credentials_delete_method,DELETE>> |Informs the server that its credentials to the client's system are now invalid (i.e. unregister). 
|===

[[credentials_get_method]]
==== *GET* Method

Retrieves the credentials object to access the server's platform. The request body is empty, the response contains the credentials object to access the server's platform. This credentials object also contains extra information about the server such as its business details.

[[credentials_post_method]]
==== *POST* Method

Provides the server with credentials to access the client's system. This credentials object also contains extra information about the client such as its business details.

A `POST` initiates the registration process for this endpoint's version. The server must also fetch the client's endpoints for this version.

If successful, the server must generate a new credentials token and respond with the client's new credentials to access the server's system. The credentials object in the response also contains extra information about the server such as its business details.

This method MUST return a `HTTP status code 405: method not allowed` if the client has already been registered before.

[[credentials_put_method]]
==== *PUT* Method

Provides the server with updated credentials to access the client's system. This credentials object also contains extra information about the client such as its business details.

A `PUT` will switch to the version that contains this credentials endpoint if it's different from the current version. The server must fetch the client's endpoints again, even if the version has not changed.

If successful, the server must generate a new credentials token for the client and respond with the client's updated credentials to access the server's system. The credentials object in the response also contains extra information about the server such as its business details.

This method MUST return a `HTTP status code 405: method not allowed` if the client has not been registered yet.

[[credentials_delete_method]]
==== *DELETE* Method

Informs the server that its credentials to access the client's system are now invalid and can no longer be used. Both parties must end any automated communication. This is the unregistration process.

This method MUST return a `HTTP status code 405: method not allowed` if the client has not been registered before.


[[credentials_object_description]]
=== Object description

[[credentials_credentials_object]]
==== Credentials object

[cols="3,3,1,9",options="header"]
|===
|Property |Type |Card. |Description 

|token |<<types_string_type,string>>(64) |1 |Case Sensitive, ASCII only. The credentials token for the other party to authenticate in your system. Not encoded in Base64 or any other encoding.
|url |<<types_url_type,URL>> |1 |The URL to your API versions endpoint. 
|roles |<<credentials_credentials_role_class,CredentialsRole>> |+ |List of the roles this party provides.
|===

Every role needs a unique combination of: `role`, `party_id` and `country_code`.

A party can have the same role more than once, for example when a CPO provides 'white-label' services for 'virtual' CPOs.

One or more roles and thus `party_id` and `country_code` sets are provided here to inform a server about the `party_id` and `country_code`
sets a client will use when pushing <<transport_and_format_client_owned_object_push,Client Owned Objects>>.
This helps a server to determine the URLs a client will use when pushing
a <<transport_and_format_client_owned_object_push,Client Owned Object>>.
The `country_code` is added the make certain the URL used when pushing
a <<transport_and_format_client_owned_object_push,Client Owned Object>> is unique as
there might be multiple parties in the world with the same `party_id`. The combination of `country_id` and `party_id` should always be unique though.
A party operating in multiple countries can always use the home country of the company for all connections.

For example: EVSE IDs can be pushed under the country and provider identification of a company, even if the EVSEs are actually located in a different country.
This way it is not necessary to establish one OCPI connection per country a company operates in.

The `party_id` and `country_code` given here have no direct link with the eMI3 EVSE IDs and Contract IDs that might be used in the different OCPI modules.
A party implementing OCPI MAY push EVSE IDs with an eMI3 `spot operator` different from the OCPI `party_id` and/or the `country_code`.

[[credentials_example]]
==== Examples

Example of a minimal CPO credentials object:
[source,json]
----
include::examples/credentials_example.json[]
----

Example of a combined CPO/eMSP credentials object:
[source,json]
----
include::examples/credentials_example2.json[]
----

Example of a CPO credentials object with full business details:
[source,json]
----
include::examples/credentials_example3.json[]
----

Example of a CPO credentials object for a platform that provides services for 3 CPOs:
[source,json]
----
include::examples/credentials_example4.json[]
----


=== Data types

[[credentials_credentials_role_class]]
==== CredentialsRole _class_

[cols="3,3,1,9",options="header"]
|===
|Property |Type |Card. |Description

|role |<<types_role_enum,Role>> |1 |Type of role.
|business_details |<<mod_locations_businessdetails_class,BusinessDetails>> |1 |Details of this party.
|party_id |<<types_cistring_type,CiString>>(3) |1 |CPO, eMSP (or other role) ID of this party (following the ISO-15118 standard).
|country_code |<<types_cistring_type,CiString>>(2) |1 |ISO-3166 alpha-2 country code of the country this party is operating in.
|===




<<<

:numbered:
[[mod_locations_locations_module]]
== _Locations_ module

*Module Identifier: `locations`*

*Data owner: `CPO`*

*Type:* Functional Module

The Location objects live in the CPO back-end system. They describe the charging locations of an operator.

*Module dependency:* the Receiver endpoint is dependent on the <<mod_tariffs_tariffs_module,Tariffs module>>

[[mod_locations_flow_and_lifecycle]]
=== Flow and Lifecycle

The Locations module has the <<mod_locations_location_object,Location>> as base object. 
Each Location can have multiple EVSEs (1:n) and each EVSE can have multiple Connectors (1:n).
With the methods in the <<mod_locations_emsp_interface,Receiver interface>>,
Location data and status information can be shared with for example an eMSP and NSP.
Updates can be made to a whole Location, but also only to an EVSE or a single Connector.

When a CPO creates Location objects, it pushes them to connected eMSP by calling <<mod_locations_put_method,PUT>> on the Receivers Locations endpoint.
eMSPs who do not support Push mode need to call <<mod_locations_get_method,GET>> on the CPOs Locations endpoint to receive the new object.
This should be done regularly to stay up to date with the CPOs data, but not too often in order to keep the load low.

If the CPO wants to replace a Location related object,
they again push it to the eMSP systems by calling <<mod_locations_put_method,PUT>> on their Locations endpoint.

Any changes to a Location related object can also be pushed to connected eMSPs by calling the <<mod_locations_patch_method,PATCH>> method
on the eMSPs Locations endpoint, but using PATCH mode, only actual changes should be pushed.
Providers who do not support Push mode need to call <<mod_locations_get_method,GET>> on the CPOs Locations endpoint to receive the updates.

When the CPO wants to delete an EVSE from the list of active EVSEs, they MUST update the EVSE's `status` field to `REMOVED`
and call the <<mod_locations_put_method,PUT>> or <<mod_locations_patch_method,PATCH>> on the eMSP system.
A Location without any valid EVSE object can be considered expired and should no longer be displayed.
There is no way to entirely delete Locations, EVSEs and Connectors as there are other modules like 
<<mod_sessions_sessions_module,`sessions`>> that depend on them. 
If it was possible to remove these objects, those links would no longer work.

When the CPO is not sure about the state or existence of a Location, EVSE or Connector object in the eMSP's system,
the CPO can perform a <<mod_locations_get_method_eMSP,GET>> request to validate the object in the eMSP's system.

Private charging Locations, that are not to be used for public charging, SHALL NOT be published via OCPI.


==== No public charging or roaming

When a Location is not available for either Public Charging or Roaming,
it is RECOMMENDED to NOT send that Location via OCPI to receiving parties.

==== Group of Charge Points

OCPP 2.0 supports a 3-tier model:

- Highest level is a Charge Point
- A Charge Point can have one or more EVSEs.
- Every EVSE can have one or more Connectors.

OCPI does not have this model:

- OCPI has Location at the highest level.
- Each location can have multiple EVSE
- Every EVSE can have one or more Connectors.

When mapping OCPP Charge Points to OCPI, there are 2 options:

- One Location for a group of Charge Points at the same location. (preferred)
- One Location per Charge Point at the same location.

OCPI prefers the first method. An EV driver does not care if a Location consists of one Charge Point with a very large amount of EVSEs,
or a large amount of Charge Points with only one EVSE. The EV driver wants to know how many EVSEs are available.
Grouping Charge Points in the same location into one OCPI Location will show better on a map that shows Charging Locations.

NOTE: The definition, an EVSE can only charge one EV at a time.

==== OCPP 1.x Charge Points with multiple connectors per EVSE

OCPP 1.x was not designed to support the 3-tier model. It had no notion of EVSEs.
The Open Charge Alliance has written an Application Note: "Multiple Connectors per EVSE in a OCPP 1.x implementation"

The workaround:

- Define one 'virtual' EVSE per Connector.
- When a connector of an hardware EVSE becomes unavailable, set all 'virtual' EVSEs for all the connectors of the hardware EVSE to unavailable. etc.


[[mod_locations_interfaces_and_endpoints]]
=== Interfaces and endpoints

There are both, a Sender and a Receiver interface for Locations.
It is advised to use the Push direction from Sender to Receiver during normal operation in order to keep the latency of updates low.
The Sender interface is meant to be used when the connection between two parties is established for the first time,
to retrieve the current list of Location objects with the current status,
and when the Receiver is not 100% sure the Location cache is entirely up-to-date (i.e. to perform a full sync).
The Receiver can also use the Sender <<mod_locations_get_object_request_parameters,GET Object interface>> to retrieve a specific Location, EVSE or Connector.
This feature might be used by an Receiver that wants information about a specific Location, but has not implemented the Receiver Locations interface (i.e. cannot receive Push).

[[mod_locations_cpo_interface]]
==== Sender Interface

Typically implemented by market roles like: CPO.

[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_locations_get_method,GET>> |Fetch a list of Locations, last updated between the {date_from} and {date_to} (<<transport_and_format_pagination,paginated>>), or get a specific Location, EVSE or Connector. 
|POST |n/a 
|PUT |n/a 
|PATCH |n/a 
|DELETE |n/a 
|===

[[mod_locations_get_method]]
===== *GET* Method

Depending on the URL Segments provided, the GET request can either be used to retrieve
information about a list of available Locations (with EVSEs and Connectors) at a CPO (<<mod_locations_get_list_request_parameters,GET List>>)
or it can be used to retrieve information about one specific Location, EVSE or Connector (<<mod_locations_get_object_request_parameters,GET Object>>).

[[mod_locations_get_list_request_parameters]]
====== GET List: Request Parameters

Endpoint structure definition:

`{locations_endpoint_url}?[date_from={date_from}]&amp;[date_to={date_to}]&amp;[offset={offset}]&amp;[limit={limit}]`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/locations/?date_from=2019-01-28T12:00:00&date_to=2019-01-29T12:00:00+`

`+https://ocpi.server.com/2.2/locations/?offset=50+`

`+https://www.server.com/ocpi/2.2/locations/?date_from=2019-01-29T12:00:00&limit=100+`

`+https://www.server.com/ocpi/cpo/2.2/locations/?offset=50&limit=100+`


If the optional parameters `{date_from}` and/or `{date_to}` are provided, only Locations with 
(`last_updated`) between the given `{date_from}` (including) and `{date_to}` (excluding) will be returned.
In order for this to work properly, the following logic MUST be implemented accordingly:
If an EVSE is updated, also the 'parent' Location's `last_updated` field needs to be updated. 
Similarly, if a Connector is updated, the EVSE's `last_updated` and the Location's `last_updated` fields need to be updated.

This request is <<transport_and_format_pagination,paginated>>, it supports the <<transport_and_format_paginated_request,pagination>> related URL parameters.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|date_from |<<types_datetime_type,DateTime>> |no |Only return Locations that have `last_updated` after or equal to this Date/Time (inclusive).
|date_to |<<types_datetime_type,DateTime>> |no |Only return Locations that have `last_updated` up to this Date/Time, but not including (exclusive).
|offset |int |no |The offset of the first object returned. Default is 0. 
|limit |int |no |Maximum number of objects to GET. 
|===

[[mod_locations_get_list_response_data]]
====== GET List: Response Data

This endpoint returns a list of Location objects.
The header will contain the <<transport_and_format_paginated_response,pagination>> related headers.

Each object must contain all required fields. Fields that are not specified may be considered as null values.
Any old information that is not specified in the response is considered no longer valid.
For requests that use pagination, the response data provided by all the pages together is the new truth.
Any old information not contained in any of the pages needs to be considered no longer valid.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_locations_location_object,Location>> |* |List of all Locations with valid EVSEs. 
|===

[[mod_locations_get_object_request_parameters]]
====== GET Object: Request Parameters

Endpoint structure definition for retrieving a Location, EVSE or Connector:

`{locations_endpoint_url}/{location_id}[/{evse_uid}][/{connector_id}]`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/locations/LOC1+`

`+https://www.server.com/ocpi/cpo/2.2/locations/LOC1/3256+`

`+https://www.server.com/ocpi/cpo/2.2/locations/LOC1/3256/1+`


The following parameters can be provided as URL segments in the same order.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|location_id |<<types_cistring_type,CiString>>(36) |yes |Location.id of the Location object to retrieve.
|evse_uid |<<types_cistring_type,CiString>>(36) |no |Evse.uid, required when requesting an EVSE or Connector object.
|connector_id |<<types_cistring_type,CiString>>(36) |no |Connector.id, required when requesting a Connector object.
|===

[[mod_locations_get_object_response_data]]
====== GET Object: Response Data

The response contains the requested object. 

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|_Choice: one of three_ | | 
|&gt; <<mod_locations_location_object,Location>> |1 |If a Location object was requested: the Location object. 
|&gt; <<mod_locations_evse_object,EVSE>> |1 |If an EVSE object was requested: the EVSE object. 
|&gt; <<mod_locations_connector_object,Connector>> |1 |If a Connector object was requested: the Connector object. 
|===


[[mod_locations_emsp_interface]]
==== Receiver Interface

Typically implemented by market roles like: eMSP and NSP.

Locations are <<transport_and_format_client_owned_object_push,Client Owned Objects>>,
so the end-points need to contain the required extra fields: 
{<<credentials_credentials_object,party_id>>} and {<<credentials_credentials_object,country_code>>}.

Endpoint structure definition:

`{locations_endpoint_url}/{country_code}/{party_id}/{location_id}[/{evse_uid}][/{connector_id}]`


Examples:

`+https://www.server.com/ocpi/emsp/2.2/locations/BE/BEC/LOC1+`

`+https://server.com/ocpi/2.2/locations/BE/BEC/LOC1/3256+`

`+https://ocpi.server.com/2.2/locations/BE/BEC/LOC1/3256/1+`


[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_locations_get_method_eMSP,GET>> |Retrieve a Location as it is stored in the eMSP system. 
|POST |n/a _(use <<mod_locations_put_method,PUT>>)_ 
|<<mod_locations_put_method,PUT>> |Push new/updated Location, EVSE and/or Connector to the eMSP. 
|<<mod_locations_patch_method,PATCH>> |Notify the eMSP of partial updates to a Location, EVSE or Connector (such as the status). 
|DELETE |n/a _(use <<mod_locations_patch_method,PATCH>> to update the `status` to `REMOVED` as described in <<mod_locations_flow_and_lifecycle,Flow and Lifecycle>>)_ 
|===

[[mod_locations_get_method_eMSP]]
===== *GET* Method

If the CPO wants to check the status of a Location, EVSE or Connector object in the eMSP system,
it might GET the object from the eMSP system for validation purposes.
The CPO is the owner of the objects, so it would be illogical if the eMSP system had a different status or was missing an object.
If a discrepancy is found, the CPO might push an update to the eMSP via a <<mod_locations_put_method,PUT>> or <<mod_locations_patch_method,PATCH>> call.

[[mod_locations_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the CPO requesting data from the eMSP system.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the CPO requesting data from the eMSP system.
|location_id |<<types_cistring_type,CiString>>(36) |yes |Location.id of the Location object to retrieve.
|evse_uid |<<types_cistring_type,CiString>>(36) |no |Evse.uid, required when requesting an EVSE or Connector object.
|connector_id |<<types_cistring_type,CiString>>(36) |no |Connector.id, required when requesting a Connector object.
|===

[[mod_locations_response_data]]
====== Response Data

The response contains the requested object. 

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|_Choice: one of three_ | | 
|&gt; <<mod_locations_location_object,Location>> |1 |If a Location object was requested: the Location object. 
|&gt; <<mod_locations_evse_object,EVSE>> |1 |If an EVSE object was requested: the EVSE object. 
|&gt; <<mod_locations_connector_object,Connector>> |1 |If a Connector object was requested: the Connector object. 
|===


[[mod_locations_put_method]]
===== *PUT* Method

The CPO pushes available Location, EVSE or Connector objects to the eMSP.
PUT can be used to send new Location objects to the eMSP but also to replace existing Locations.

When the PUT only contains a <<mod_locations_connector_object,Connector>> Object,
the Receiver SHALL also set the new `last_updated` value on the parent <<mod_locations_evse_object,EVSE>> and <<mod_locations_location_object,Location>> Objects.

When the PUT only contains a <<mod_locations_evse_object,EVSE>> Object,
the Receiver SHALL also set the new `last_updated` value on the parent <<mod_locations_location_object,Location>> Object.

[[mod_locations_request_parameters_msp]]
====== Request Parameters

This is an information Push message, the objects pushed will not be owned by the eMSP.
To make distinctions between objects being pushed to an eMSP from different CPOs, 
the {<<credentials_credentials_object,party_id>>} and {<<credentials_credentials_object,country_code>>} 
have to be included in the URL (as URL segments, as described in the <<mod_locations_emsp_interface,Receiver Interface>>).

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the CPO requesting this PUT to the eMSP system. This SHALL be the same value as the `country_code` in the Location object being pushed.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the CPO requesting this PUT to the eMSP system. This SHALL be the same value as the `party_id` in the Location object being pushed.
|location_id |<<types_cistring_type,CiString>>(36) |yes |Location.id of the new Location object, or the Location of which an EVSE or Connector object is pushed.
|evse_uid |<<types_cistring_type,CiString>>(36) |no |Evse.uid, required when an EVSE or Connector object is pushed.
|connector_id |<<types_cistring_type,CiString>>(36) |no |Connector.id, required when a Connector object is pushed.
|===

[[mod_locations_request_body]]
====== Request Body

The request body contains the new/updated object.

When the PUT contains a <<mod_locations_connector_object,Connector>> Object,
the Receiver SHALL also set the new `last_updated` value on the parent <<mod_locations_evse_object,EVSE>> and <<mod_locations_location_object,Location>> Objects.

When the PUT contains a <<mod_locations_evse_object,EVSE>> Object,
the Receiver SHALL also set the new `last_updated` value on the parent <<mod_locations_location_object,Location>> Object.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|_Choice: one of three_ | | 
|&gt; <<mod_locations_location_object,Location>> |1 |New Location object, or Location object to replace. 
|&gt; <<mod_locations_evse_object,EVSE>> |1 |New EVSE object, or EVSE object to replace. 
|&gt; <<mod_locations_connector_object,Connector>> |1 |New Connector object, or Connector object to replace. 
|===

[[mod_locations_example_add_an_evse]]
====== Example: add an EVSE

To add an _EVSE_, simply put the full object in an update message, including all its required fields.
Since the id will be new to the eMSP's system, the receiving party will know that it is a new object.
When not all required fields are specified, the object may be discarded.

[source,json]
----
PUT To URL: https://www.server.com/ocpi/emsp/2.2/locations/NL/TNM/1012/3256

include::examples/location_put_example_add_evse.json[]
----


[[mod_locations_patch_method]]
===== *PATCH* Method

Same as the <<mod_locations_put_method,PUT>> method, but only the fields/objects that have to be updated have to be present.
Other fields/objects that are not specified as part of the request are considered unchanged.
Therefore, this method is not suitable to remove information shared earlier.

Any request to the PATCH method SHALL contain the `last_updated` field.

When the PATCH is on a <<mod_locations_connector_object,Connector>> Object,
the Receiver SHALL also set the new `last_updated` value on the parent <<mod_locations_evse_object,EVSE>> and <<mod_locations_location_object,Location>> Objects.

When the PATCH is on a <<mod_locations_evse_object,EVSE>> Object,
the Receiver SHALL also set the new `last_updated` value on the parent <<mod_locations_location_object,Location>> Object.

[[mod_locations_example_a_simple_status_update]]
====== Example: a simple status update

This is the most common type of update message. It is used to notify eMSPs that the status of an EVSE changed.
In this case it is the EVSE with uid `3255` of the Location with id `1012`.


[source,json]
----
PATCH To URL: https://www.server.com/ocpi/emsp/2.2/locations/NL/TNM/1012/3255

include::examples/location_patch_example_status.json[]
----


[[mod_locations_example_change_the_location_name]]
====== Example: change the location name

In this example the name of the Location with id `1012` is being updated.

[source,json]
----
PATCH To URL: https://www.server.com/ocpi/emsp/2.2/locations/NL/TNM/1012


include::examples/location_patch_example_location.json[]
----


[[mod_locations_example_set_tariff_update]]
====== Example: set tariff update

In this example Connector `2` of EVSE `1` of Location `1012` receives a new pricing scheme.

[source,json]
----
PATCH To URL: https://www.server.com/ocpi/emsp/2.2/locations/NL/TNM/1012/3255/2

include::examples/location_patch_example_tariff.json[]
----


[[mod_locations_example_delete_an_evse]]
====== Example: delete an EVSE

An EVSE can be deleted by updating its `status` property.

[source,json]
----
PATCH To URL: https://www.server.com/ocpi/emsp/2.2/locations/NL/TNM/1012/3256

include::examples/location_patch_example_remove_evse.json[]
----


NOTE: To inform eMSPs that an EVSE is scheduled for removal, the status_schedule field can be used._

[[mod_locations_object_description]]
=== Object description

Location, EVSE and Connector have the following relation.

.Location class diagram
image::images/locations-class-diagram.svg[Location class diagram]

[[mod_locations_location_object]]
==== _Location_ Object

The _Location_ object describes the location and its properties where a group of EVSEs that belong together are installed.
Typically, the _Location_ object is the exact location of the group of EVSEs, but it can also be the entrance of a parking garage which contains these EVSEs.
The exact way to reach each EVSE can be further specified by its own properties.

Locations may be shown in apps or on websites etc. when the flag: `publish` is set to `true`.
Locations that have this flag set to `false` SHALL not be shown in an app or on a website etc. unless
it is to the owner of a <<mod_tokens_token_object,Token>> in the `publish_allowed_to` list.
Even parties like NSP or eMSP that do not 'own' this Token MAY show this location on an app or website,
but only to the owner of that Token.
If the user of their app/website has provided information about his/her <<mod_tokens_token_object,Token>>,
And that information matches all the fields of one of the <<mod_locations_publish_token_class,PublishToken>> tokens in the list,
then they are allowed to show this location to their user.
It is not allowed in OCPI to use a Token that is not 'owned' by the eMSP itself to start a charging session.

[cols="7,7,2,16",options="header"]
|===
|Property |Type |Card. |Description 

|country_code |<<types_cistring_type,CiString>>(2) |1 |ISO-3166 alpha-2 country code of the CPO that 'owns' this Location.
|party_id |<<types_cistring_type,CiString>>(3) |1 |CPO ID of the CPO that 'owns' this Location (following the ISO-15118 standard).
|id |<<types_cistring_type,CiString>>(36) |1 |Uniquely identifies the location within the CPOs platform (and suboperator platforms). This field can never be changed, modified or renamed.
|publish |boolean |1 |Defines if a Location may be published on an website or app etc. +
                      When this is set to `false`, only tokens identified in the field: `publish_allowed_to` are allowed to be shown this Location. +
                      When the same location has EVSEs that may be published and may not be published, two 'Locations' should be created.
|publish_allowed_to |<<mod_locations_publish_token_class,PublishTokenType>> |* |This field may only be used when the `publish` field is set to `false` +
                      Only owners of Tokens that match all the set fields of one PublishToken in the list are allowed to be shown this location.
|name |<<types_string_type,string>>(255) |? |Display name of the location.
|address |<<types_string_type,string>>(45) |1 |Street/block name and house number if available. 
|city |<<types_string_type,string>>(45) |1 |City or town. 
|postal_code |<<types_string_type,string>>(10) |? |Postal code of the location, may only be omitted when the location has no postal code: in some countries charging locations at highways don't have postal codes.
|state |<<types_string_type,string>>(20) |? |State or province of the location, only to be used when relevant.
|country |<<types_string_type,string>>(3) |1 |ISO 3166-1 alpha-3 code for the country of this location.
|coordinates |<<mod_locations_geolocation_class,GeoLocation>> |1 |Coordinates of the location. 
|related_locations |<<mod_locations_additionalgeolocation_class,AdditionalGeoLocation>> |* |Geographical location of related points relevant to the user.
|parking_type |<<mod_locations_parkingtype_enum,ParkingType>> |? |The general type of parking at the charge point location.
|evses |<<mod_locations_evse_object,EVSE>> |* |List of EVSEs that belong to this Location.
|directions |<<types_displaytext_class,DisplayText>> |* |Human-readable directions on how to reach the location. 
|operator |<<mod_locations_businessdetails_class,BusinessDetails>> |? |Information of the operator. When not specified, the information retrieved from the <<credentials_credentials_endpoint,Credentials>> module should be used instead.
|suboperator |<<mod_locations_businessdetails_class,BusinessDetails>> |? |Information of the suboperator if available.
|owner |<<mod_locations_businessdetails_class,BusinessDetails>> |? |Information of the owner if available. 
|facilities |<<mod_locations_facility_enum,Facility>> |* |Optional list of facilities this charging location directly belongs to. 
|time_zone |<<types_string_type,string>>(255) |1 |One of IANA tzdata's TZ-values representing the time zone of the location. Examples: "Europe/Oslo", "Europe/Zurich". (http://www.iana.org/time-zones[http://www.iana.org/time-zones])
|opening_times |<<mod_locations_hours_class,Hours>> |? |The times when the EVSEs at the location can be accessed for charging. 
|charging_when_closed |boolean |? |Indicates if the EVSEs are still charging outside the opening hours of the location. E.g. when the parking garage closes its barriers over night, is it allowed to charge till the next morning? Default: *true* 
|images |<<mod_locations_image_class,Image>> |* |Links to images related to the location such as photos or logos. 
|energy_mix |<<mod_locations_energymix_class,EnergyMix>> |? |Details on the energy supplied at this location. 
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this Location or one of its EVSEs or Connectors were last updated (or created). 
|===

Private Charge Points, home or business that do not need to be published on apps, and do not require remote control via OCPI,
SHOULD not be PUT via the OCPI Locations module.  Reimbursement via eMSP is still possible by sending <<mod_cdrs_cdr_object,CDRs>> to eMSP, the Locations module is not needed for this..

[[mod_locations_example]]
===== Example public charging location

This is an example of a public charging location.
Can be used by any EV Driver as long as his eMSP has a roaming agreement with the CPO.
Or the Charge Point has an ad-hoc payment possibility

- `publish` = `true`
- `parking_type` = `ON_STREET` but could also be another value.
- `EVSE.parking_restrictions` not used.

[source,json]
----
include::examples/location_example.json[]
----

[[mod_locations_example_uc2]]
===== Example destination charging location

This is an example of a destination charging location.
This is a Location where only guests, employees or customers can charge.
For an EV driver, it can be useful to know if he/she can charge at his destination.

For example at a restaurant, only customers of the restaurant can charge their EV.
Or at an office building where employees and guest of the office can charge their EV.

Locations you can think of where this is useful:
restaurants, bars, clubs, theme parks, stores, supermarkets, company building, office buildings, etc.

- `publish` = `true`
- `parking_type` = `PARKING_LOT` (but could also be `PARKING_GARAGE`, `ON_DRIVEWAY` or `UNDERGROUND_GARAGE`)
- `EVSE.parking_restrictions` = `CUSTOMERS`

[source,json]
----
include::examples/location_example_uc2_destination_charger.json[]
----

[[mod_locations_example_uc3]]
===== Example destination charging location not published, but paid guest usage possible

This is an example of a destination charging location.
But the owner of the location has requested not to publish the location in Apps or on websites.

Charging is still possible: EV drivers of an eMSP with a roaming agreement can still charge their EV.
The eMSP helpdesk can use the information from the Location module to help the driver, maybe even start a session for a driver.
Starting a session from an App is not possible, because the driver will not be able to select the Charge Point on a map.

In case the EV driver is not billed for charging, there is, in such a case, no reason to publish the location via OCPI.

- `publish` = `false`
- `publish_allowed_to` not used
- `parking_type` = not used`
- `EVSE.parking_restrictions` = `CUSTOMERS` May still be useful so a support desk can also tell this to a customer.

[source,json]
----
include::examples/location_example_uc3_destination_charger_not_published.json[]
----

[[mod_locations_example_uc4]]
===== Example charging location with limited visibility

This is an example of a charging location that only a limited group can see (and use) via an App or website.

Typical examples where this is useful:

- Charge Points in the parking garage of an apartment building. Only owners can see/control the Charge Points.
- Charge Points at an office, for employees only. Only employees can see/control the Charge Points.
- Charge Points at vehicle depot. Any employee can see/control an charge point, even transaction they did not start. Use `group_id` for this.

The locations SHALL NOT be published to the general public.
Only selected <<mod_tokens_token_object,Tokens>> can see (and control) the Charge Points via eMSP app.

- `publish` = `false`
- `publish_allowed_to` contains list with information of <<mod_tokens_token_object,Tokens>> that are allowed to be shown the `Location`.
- `parking_type` = `UNDERGROUND_GARAGE` (but could also be `PARKING_GARAGE`, `ON_DRIVEWAY` or `PARKING_LOT`)

[source,json]
----
include::examples/location_example_uc4_limited_visibility.json[]
----

[[mod_locations_example_uc5]]
===== Example private charge point with eMSP app control

This is an example of a private/home charge point that needs to be controlled via an eMSP App.

The locations SHALL NOT be published to the general public.
Only the owner, identified by his/her <<mod_tokens_token_object,Token>> can see (and control) the Charge Points via an eMSP app.

- `publish` = `false`
- `publish_allowed_to` contains the information of the <<mod_tokens_token_object,Tokens>> of the owner.
- `parking_type` = not used, not relevant, owner knows where his Charge Point is.

[source,json]
----
include::examples/location_example_uc5_home_charge_point.json[]
----

[[mod_locations_example_parking_garage_with_opening_hours]]
===== Example charge point in a parking garage with opening hours

This is an example of a charge point, located in a parking garage with limited opening hours:
7:00 - 18:00.

If the EV is left in the parking garage overnight, the car will still be charged.

- `publish` = `true`
- `parking_type` = `PARKING_GARAGE` but could also be another value.
- `EVSE.parking_restrictions` not used.
- `opening_times` is used.
- `charging_when_closed` = `true`

[source,json]
----
include::examples/location_example_parking_garage_opening_hours.json[]
----


[[mod_locations_evse_object]]
==== _EVSE_ Object

The _EVSE_ object describes the part that controls the power supply to a single EV in a single session.
It always belongs to a <<mod_locations_location_object,Location>> object. 
The object only contains directions to get from the location itself
to the EVSE (i.e. _floor_, _physical_reference_ or _directions_).

When the directional properties of an EVSE are insufficient to reach the EVSE from the _Location_ point,
then it typically indicates that the EVSE should be put in a different _Location_ object
(sometimes with the same address but with different coordinates/directions).

An _EVSE_ object has a list of Connectors which can not be used simultaneously: only one connector per EVSE can be used at the time.

[cols="7,5,2,18",options="header"]
|===
|Property |Type |Card. |Description 

|uid |<<types_cistring_type,CiString>>(36) |1 |Uniquely identifies the EVSE within the CPOs platform (and suboperator platforms). For example a database ID or the actual "EVSE ID". This field can never be changed, modified or renamed. This is the 'technical' identification of the EVSE, not to be used as 'human readable' identification, use the field `evse_id` for that. +
This field is named `uid` instead of `id`, because `id` could be confused with `evse_id` which is an eMI3 defined field.
|evse_id |<<types_cistring_type,CiString>>(48) |? |Compliant with the following specification for EVSE ID from "eMI3 standard version V1.0" (http://emi3group.com/documents-links/[http://emi3group.com/documents-links/]) "Part 2: business objects." Optional because: if an `evse_id` is to be re-used in the real world, the `evse_id` can be removed from an EVSE object if the `status` is set to `REMOVED`.
|status |<<mod_locations_status_enum,Status>> |1 |Indicates the current status of the EVSE. 
|status_schedule |<<mod_locations_statusschedule_class,StatusSchedule>> |* |Indicates a planned status update of the EVSE. 
|capabilities |<<mod_locations_capability_enum,Capability>> |* |List of functionalities that the EVSE is capable of. 
|connectors |<<mod_locations_connector_object,Connector>> |+ |List of available connectors on the EVSE. 
|floor_level |<<types_string_type,string>>(4) |? |Level on which the Charge Point is located (in garage buildings) in the locally displayed numbering scheme.
|coordinates |<<mod_locations_geolocation_class,GeoLocation>> |? |Coordinates of the EVSE. 
|physical_reference |<<types_string_type,string>>(16) |? |A number/string printed on the outside of the EVSE for visual identification. 
|directions |<<types_displaytext_class,DisplayText>> |* |Multi-language human-readable directions when more detailed information on how to reach the EVSE from the _Location_ is required. 
|parking_restrictions |<<mod_locations_parkingrestriction_enum,ParkingRestriction>> |* |The restrictions that apply to the parking spot. 
|images |<<mod_locations_image_class,Image>> |* |Links to images related to the EVSE such as photos or logos. 
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this EVSE or one of its Connectors was last updated (or created). 
|===

NOTE: OCPP 1.x does not have good support for Charge Points that have multiple connectors per EVSE.
To make `StartSession` over OCPI work, the CPO SHOULD present the different connectors of an EVSE as separate EVSE,
as is also written by the OCA in the application note: "Multiple Connectors per EVSE in a OCPP 1.x implementation".


[[mod_locations_connector_object]]
==== _Connector_ Object

A _Connector_ is the _socket_ or _cable and plug_ available for the EV to use. 
A single EVSE may provide multiple Connectors but only one of them can be in use at the same time.
A Connector always belongs to an <<mod_locations_evse_object,EVSE>> object.

[cols="7,5,2,18",options="header"]
|===
|Property |Type |Card. |Description 

|id |<<types_cistring_type,CiString>>(36) |1 |Identifier of the Connector within the EVSE. Two Connectors may have the same id as long as they do not belong to the same _EVSE_ object.
|standard |<<mod_locations_connectortype_enum,ConnectorType>> |1 |The standard of the installed connector. 
|format |<<mod_locations_connectorformat_enum,ConnectorFormat>> |1 |The format (socket/cable) of the installed connector. 
|power_type |<<mod_locations_powertype_enum,PowerType>> |1 | 
|max_voltage |int |1 |Maximum voltage of the connector (line to neutral for AC_3_PHASE), in volt [V]. For example: DC Chargers might vary the voltage during charging when battery almost full.
|max_amperage |int |1 |Maximum amperage of the connector, in ampere [A].
|max_electric_power |int |? |Maximum electric power that can be delivered by this connector, in Watts (W). When the maximum electric power is lower than the calculated value from `voltage` and `amperage`, this value should be set. +
For example: A DC Charge Point which can delivers up to 920V and up to 400A can be limited to a maximum of 150kW (max_electric_power = 150000). Depending on the car, it may supply max voltage or current, but not both at the same time. +
For AC Charge Points, the amount of phases used can also have influence on the maximum power.
|tariff_ids |<<types_cistring_type,CiString>>(36) |* |Identifiers of the currently valid charging tariffs.
                    Multiple tariffs are possible, but only one of each <<mod_tariffs_tariff_object,Tariff.type>> can be active at the same time.
                    Tariffs with the same type are only allowed if they are not active at the same time:
                    <<mod_tariffs_tariff_object,start_date_time>> and <<mod_tariffs_tariff_object,end_date_time>> period not overlapping. +
                    When preference-based smart charging is supported, one tariff for every possible <<mod_sessions_profile_type_enum,ProfileType>> should be provided.
                    These tell the user about the options they have at this Connector, and what the tariff is for every option. +
                    For a "free of charge" tariff, this field should be set and point to a defined "free of charge" tariff.
|terms_and_conditions |<<types_url_type,URL>> |? |URL to the operator's terms and conditions. 
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this Connector was last updated (or created). 
|===


[[mod_locations_data_types]]
=== Data types

[[mod_locations_additionalgeolocation_class]]
==== AdditionalGeoLocation _class_

This class defines an additional geo location that is relevant for the Charge Point. The geodetic system to be used is WGS 84.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|latitude |<<types_string_type,string>>(10) |1 |Latitude of the point in decimal degree. Example: 50.770774. Decimal separator: "." Regex: `-?[0-9]{1,2}\.[0-9]{5,7}`
|longitude |<<types_string_type,string>>(11) |1 |Longitude of the point in decimal degree. Example: -126.104965. Decimal separator: "." Regex: `-?[0-9]{1,3}\.[0-9]{5,7}`
|name |<<types_displaytext_class,DisplayText>> |? |Name of the point in local language or as written at the location. For example the street name of a parking lot entrance or it's number. 
|===

[[mod_locations_businessdetails_class]]
==== BusinessDetails _class_

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|name |<<types_string_type,string>>(100) |1 |Name of the operator. 
|website |<<types_url_type,URL>> |? |Link to the operator's website. 
|logo |<<mod_locations_image_class,Image>> |? |Image link to the operator's logo. 
|===


[[mod_locations_capability_enum]]
==== Capability _enum_

The capabilities of an EVSE.

[cols="5,8",options="header"]
|===
|Value |Description 

|CHARGING_PROFILE_CAPABLE |The EVSE supports charging profiles.
|CHARGING_PREFERENCES_CAPABLE |The EVSE supports <<mod_sessions_set_charging_preferences,charging preferences>>.
|CHIP_CARD_SUPPORT |EVSE has a payment terminal that supports chip cards.
|CONTACTLESS_CARD_SUPPORT |EVSE has a payment terminal that supports contactless cards.
|CREDIT_CARD_PAYABLE |EVSE has a payment terminal that makes it possible to pay for charging using a credit card.
|DEBIT_CARD_PAYABLE |EVSE has a payment terminal that makes it possible to pay for charging using a debit card.
|PED_TERMINAL |EVSE has a payment terminal with a pin-code entry device.
|REMOTE_START_STOP_CAPABLE |The EVSE can remotely be <<mod_commands_startsession_object,started>>/<<mod_commands_stopsession_object,stopped>>.
|RESERVABLE |The EVSE can be <<mod_commands_reservenow_object,reserved>>.
|RFID_READER |Charging at this EVSE can be authorized with an RFID token.
|TOKEN_GROUP_CAPABLE |This EVSE supports token groups, two or more tokens work as one, so that a session can be started with one token and stopped with another (handy when a card and key-fob are given to the EV-driver).
|UNLOCK_CAPABLE |Connectors have mechanical lock that can be requested by the eMSP to be <<mod_commands_unlockconnector_object,unlocked>>.
|===

When a Charge Point supports ad-hoc payments with a payment terminal, please use a combination of the following values to explain the possibilities of the terminal:
CHIP_CARD_SUPPORT, CONTACTLESS_CARD_SUPPORT, CREDIT_CARD_PAYABLE, DEBIT_CARD_PAYABLE, PED_TERMINAL.


[[mod_locations_connectorformat_enum]]
==== ConnectorFormat _enum_

The format of the connector, whether it is a socket or a plug.

[cols="3,10",options="header"]
|===
|Value |Description 

|SOCKET |The connector is a socket; the EV user needs to bring a fitting plug. 
|CABLE |The connector is an attached cable; the EV users car needs to have a fitting inlet. 
|===

[[mod_locations_connectortype_enum]]
==== ConnectorType _enum_

The socket or plug standard of the charging point.

[cols="3,10",options="header"]
|===
|Value |Description 

|CHADEMO |The connector type is CHAdeMO, DC 
|DOMESTIC_A |Standard/Domestic household, type "A", NEMA 1-15, 2 pins 
|DOMESTIC_B |Standard/Domestic household, type "B", NEMA 5-15, 3 pins 
|DOMESTIC_C |Standard/Domestic household, type "C", CEE 7/17, 2 pins 
|DOMESTIC_D |Standard/Domestic household, type "D", 3 pin 
|DOMESTIC_E |Standard/Domestic household, type "E", CEE 7/5 3 pins 
|DOMESTIC_F |Standard/Domestic household, type "F", CEE 7/4, Schuko, 3 pins 
|DOMESTIC_G |Standard/Domestic household, type "G", BS 1363, Commonwealth, 3 pins 
|DOMESTIC_H |Standard/Domestic household, type "H", SI-32, 3 pins 
|DOMESTIC_I |Standard/Domestic household, type "I", AS 3112, 3 pins 
|DOMESTIC_J |Standard/Domestic household, type "J", SEV 1011, 3 pins 
|DOMESTIC_K |Standard/Domestic household, type "K", DS 60884-2-D1, 3 pins 
|DOMESTIC_L |Standard/Domestic household, type "L", CEI 23-16-VII, 3 pins 
|IEC_60309_2_single_16 |IEC 60309-2 Industrial Connector single phase 16 amperes (usually blue) 
|IEC_60309_2_three_16 |IEC 60309-2 Industrial Connector three phase 16 amperes (usually red) 
|IEC_60309_2_three_32 |IEC 60309-2 Industrial Connector three phase 32 amperes (usually red) 
|IEC_60309_2_three_64 |IEC 60309-2 Industrial Connector three phase 64 amperes (usually red) 
|IEC_62196_T1 |IEC 62196 Type 1 "SAE J1772" 
|IEC_62196_T1_COMBO |Combo Type 1 based, DC 
|IEC_62196_T2 |IEC 62196 Type 2 "Mennekes" 
|IEC_62196_T2_COMBO |Combo Type 2 based, DC 
|IEC_62196_T3A |IEC 62196 Type 3A 
|IEC_62196_T3C |IEC 62196 Type 3C "Scame" 
|PANTOGRAPH_BOTTOM_UP|On-board Bottom-up-Pantograph typically for bus charging
|PANTOGRAPH_TOP_DOWN|Off-board Top-down-Pantograph typically for bus charging
|TESLA_R |Tesla Connector "Roadster"-type (round, 4 pin)
|TESLA_S |Tesla Connector "Model-S"-type (oval, 5 pin)
|===

[[mod_locations_energymix_class]]
==== EnergyMix _class_

This type is used to specify the energy mix and environmental impact of the supplied energy at a location or in a tariff.

[cols="3,3,1,9",options="header"]
|===
|Property |Type |Card. |Description 

|is_green_energy |boolean |1 |True if 100% from regenerative sources. (CO2 and nuclear waste is zero) 
|energy_sources |<<mod_locations_energysource_class,EnergySource>> |* |Key-value pairs (enum + percentage) of energy sources of this location's tariff. 
|environ_impact |<<mod_locations_environmentalimpact_class,EnvironmentalImpact>> |* |Key-value pairs (enum + percentage) of nuclear waste and CO2 exhaust of this location's tariff. 
|supplier_name |<<types_string_type,string>>(64) |? |Name of the energy supplier, delivering the energy for this location or tariff.* 
|energy_product_name |<<types_string_type,string>>(64) |? |Name of the energy suppliers product/tariff plan used at this location.* 
|===

_* These fields can be used to look-up energy qualification or to show it directly to the customer (for well-known brands like Greenpeace Energy, etc.)_

[[mod_locations_examples]]
===== Examples

[[mod_locations_simple]]
====== Simple:

[source,json]
----
include::examples/location_energymix_example_simple.json[lines=2..4]
----


[[mod_locations_energy_provider_name]]
====== Tariff energy provider name:

[source,json]
----
include::examples/location_energymix_example_energy_provider.json[lines=2..6]
----


[[mod_locations_complete]]
====== Complete:

[source,json]
----
include::examples/location_energymix_example_complete.json[lines=2..17]
----


[[mod_locations_energysource_class]]
==== EnergySource _class_

Key-value pairs (enum + percentage) of energy sources. All given values of all categories should add up to 100 percent.

[cols="2,4,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|source |<<mod_locations_energysourcecategory_enum,EnergySourceCategory>> |1 |The type of energy source. 
|percentage |<<types_number_type,number>> |1 |Percentage of this source (0-100) in the mix. 
|===

[[mod_locations_energysourcecategory_enum]]
==== EnergySourceCategory _enum_

Categories of energy sources.

[cols="3,10",options="header"]
|===
|Value |Description 

|NUCLEAR |Nuclear power sources. 
|GENERAL_FOSSIL |All kinds of fossil power sources. 
|COAL |Fossil power from coal. 
|GAS |Fossil power from gas. 
|GENERAL_GREEN |All kinds of regenerative power sources. 
|SOLAR |Regenerative power from PV. 
|WIND |Regenerative power from wind turbines. 
|WATER |Regenerative power from water turbines. 
|===

[[mod_locations_environmentalimpact_class]]
==== EnvironmentalImpact _class_

Amount of waste produced/emitted per kWh.

[cols="2,5,1,9",options="header"]
|===
|Property |Type |Card. |Description 

|category |<<mod_locations_environmentalimpactcategory_enum,EnvironmentalImpactCategory>> |1 |The environmental impact category of this value.
|amount |<<types_number_type,number>> |1 |Amount of this portion in g/kWh. 
|===

[[mod_locations_environmentalimpactcategory_enum]]
==== EnvironmentalImpactCategory _enum_

Categories of environmental impact values.

[cols="3,10",options="header"]
|===
|Value |Description 

|NUCLEAR_WASTE |Produced nuclear waste in grams per kilowatthour.
|CARBON_DIOXIDE |Exhausted carbon dioxide in grams per kilowatthour.
|===

[[mod_locations_exceptionalperiod_class]]
==== ExceptionalPeriod _class_

Specifies one exceptional period for opening or access hours.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|period_begin |<<types_datetime_type,DateTime>> |1 |Begin of the exception. In UTC, `time_zone` field can be used to convert to local time.
|period_end |<<types_datetime_type,DateTime>> |1 |End of the exception. In UTC, `time_zone` field can be used to convert to local time.
|===


[[mod_locations_facility_enum]]
==== Facility _enum_

[cols="3,10",options="header"]
|===
|Value |Description 

|HOTEL |A hotel. 
|RESTAURANT |A restaurant. 
|CAFE |A cafe. 
|MALL |A mall or shopping center. 
|SUPERMARKET |A supermarket. 
|SPORT |Sport facilities: gym, field etc. 
|RECREATION_AREA |A recreation area. 
|NATURE |Located in, or close to, a park, nature reserve etc. 
|MUSEUM |A museum. 
|BIKE_SHARING |A bike/e-bike/e-scooter sharing location.
|BUS_STOP |A bus stop.
|TAXI_STAND |A taxi stand. 
|TRAM_STOP | A tram stop/station.
|METRO_STATION |A metro station.
|TRAIN_STATION |A train station.
|AIRPORT |An airport. 
|PARKING_LOT | A parking lot.
|CARPOOL_PARKING |A carpool parking.
|FUEL_STATION |A Fuel station. 
|WIFI |Wifi or other type of internet available. 
|===


[[mod_locations_geolocation_class]]
==== GeoLocation _class_

This class defines the geo location of the Charge Point. The geodetic system to be used is WGS 84.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|latitude |<<types_string_type,string>>(10) |1 |Latitude of the point in decimal degree. Example: 50.770774. Decimal separator: "." Regex: `-?[0-9]{1,2}\.[0-9]{5,7}`
|longitude |<<types_string_type,string>>(11) |1 |Longitude of the point in decimal degree. Example: -126.104965. Decimal separator: "." Regex: `-?[0-9]{1,3}\.[0-9]{5,7}`
|===

NOTE: Five decimal places is seen as a minimum for GPS coordinates of the Charge Point as this gives approximately 1 meter precision.
More is always better. Seven decimal places gives approximately 1cm precision.


[[mod_locations_hours_class]]
==== Hours _class_

Opening and access hours of the location.

[cols="3,3,1,9",options="header"]
|===
|Property |Type |Card. |Description

|twentyfourseven |boolean |1 |True to represent 24 hours a day and 7 days a week, except the given exceptions. 
|regular_hours |<<mod_locations_regularhours_class,RegularHours>> |* |Regular hours, weekday-based. Only to be used if `twentyfourseven=false`, then this field needs to contain at least one <<mod_locations_regularhours_class,RegularHours>> object.
|exceptional_openings |<<mod_locations_exceptionalperiod_class,ExceptionalPeriod>> |* |Exceptions for specified calendar dates, time-range based. Periods the station is operating/accessible. Additional to `regular_hours`. May overlap regular rules. 
|exceptional_closings |<<mod_locations_exceptionalperiod_class,ExceptionalPeriod>> |* |Exceptions for specified calendar dates, time-range based. Periods the station is not operating/accessible. Overwriting `regular_hours` and `exceptional_openings`. Should not overlap `exceptional_openings`. 
|===

[[mod_locations_hours_example_1]]
===== Example: 24/7 open with exceptional closing.

Open 24 hours per day, 7 days a week, except for 25th of December 2018 between 03:00 and 05:00.

[source,json]
----
include::examples/location_hours_247_open_exception_closing.json[]
----

.Diagram showing a representation of the example 24/7 open with exception closing.
image::images/location_hours_247_open_exception_closing.svg[24/7 open with exception closing.]


[[mod_locations_hours_example_2]]
===== Example: Opening Hours with exceptional closing.

Regular opening hours between 01:00 and 06:00. With exceptional closing on 25th of December 2018 between 03:00 and 05:00.

[source,json]
----
include::examples/location_hours_opening_hours_with_exceptional_closing.json[]
----

.Diagram showing a representation of the example Opening Hours with exceptional closing
image::images/location_hours_opening_hours_with_exceptional_closing.svg[Opening Hours with exceptional closing.]


[[mod_locations_hours_example_3]]
===== Example: Opening Hours with exceptional opening.

Regular opening hours between 00:00 and 04:00. With exceptional opening on 25th of December 2018 between 05:00 and 07:00.

[source,json]
----
include::examples/location_hours_opening_hours_with_exceptional_opening.json[]
----

.Diagram showing a representation of the example Opening Hours with exceptional opening.
image::images/location_hours_opening_hours_with_exceptional_opening.svg[Opening Hours with exceptional opening.]


[[mod_locations_image_class]]
==== Image _class_

This class references an image related to an EVSE in terms of a file name or url.
According to the roaming connection between one EVSE Operator and one or more Navigation Service Providers,
the hosting or file exchange of image payload data has to be defined. The exchange of this content data is out of scope of OCPI.
However, the recommended setup is a public available web server hosted and updated by the EVSE Operator.
Per charge point an unlimited number of images of each type is allowed.
Recommended are at least two images where one is a network or provider logo and the second is a station photo.
If two images of the same type are defined, not only one should be selected but both should be displayed together.

Photo Dimensions:
The recommended dimensions for all photos is a minimum width of 800 pixels and a minimum height of 600 pixels.
Thumbnail should always have the same orientation as the original photo with a size of 200 by 200 pixels.

Logo Dimensions:
The recommended dimensions for logos are exactly 512 pixels in width height.
Thumbnail representations of logos should be exactly 128 pixels in width and height.
If not squared, thumbnails should have the same orientation as the original.

[cols="3,3,1,9",options="header"]
|===
|Property |Type |Card. |Description

|url |<<types_url_type,URL>> |1 |URL from where the image data can be fetched through a web browser. 
|thumbnail |<<types_url_type,URL>> |? |URL from where a thumbnail of the image can be fetched through a webbrowser. 
|category |<<mod_locations_imagecategory_enum,ImageCategory>> |1 |Describes what the image is used for. 
|type |<<types_string_type,CiString>>(4) |1 |Image type like: gif, jpeg, png, svg.
|width |int(5) |? |Width of the full scale image. 
|height |int(5) |? |Height of the full scale image. 
|===

[[mod_locations_imagecategory_enum]]
==== ImageCategory _enum_

The category of an image to obtain the correct usage in a user presentation.
The category has to be set accordingly to the image content in order to guarantee the right usage.

[cols="3,10",options="header"]
|===
|Value |Description 

|CHARGER |Photo of the physical device that contains one or more EVSEs. 
|ENTRANCE |Location entrance photo. Should show the car entrance to the location from street side. 
|LOCATION |Location overview photo. 
|NETWORK |Logo of an associated roaming network to be displayed with the EVSE for example in lists, maps and detailed information views.
|OPERATOR |Logo of the charge point operator, for example a municipality, to be displayed in the EVSEs detailed information view or in lists and maps, if no network logo is present. 
|OTHER |Other 
|OWNER |Logo of the charge point owner, for example a local store, to be displayed in the EVSEs detailed information view.
|===

[[mod_locations_parkingrestriction_enum]]
==== ParkingRestriction _enum_

This value, if provided, represents the restriction to the parking spot for different purposes.

[cols="3,10",options="header"]
|===
|Value |Description 

|EV_ONLY |Reserved parking spot for electric vehicles. 
|PLUGGED |Parking is only allowed while plugged in (charging). 
|DISABLED |Reserved parking spot for disabled people with valid ID. 
|CUSTOMERS |Parking spot for customers/guests only, for example in case of a hotel or shop.
|MOTORCYCLES |Parking spot only suitable for (electric) motorcycles or scooters. 
|===

[[mod_locations_parkingtype_enum]]
==== ParkingType _enum_

Reflects the general type of the charge point's location. May be used for user information.

[cols="4,9",options="header"]
|===
|Value |Description

|ALONG_MOTORWAY |Location on a parking facility/rest area along a motorway, freeway, interstate, highway etc.
|PARKING_GARAGE |Multistorey car park.
|PARKING_LOT |A cleared area that is intended for parking vehicles, i.e. at super markets, bars, etc.
|ON_DRIVEWAY |Location is on the driveway of a house/building.
|ON_STREET |Parking in public space along a street.
|UNDERGROUND_GARAGE |Multistorey car park, mainly underground.
|===

[[mod_locations_powertype_enum]]
==== PowerType _enum_

[cols="3,10",options="header"]
|===
|Value |Description 

|AC_1_PHASE |AC single phase. 
|AC_3_PHASE |AC three phase. 
|DC |Direct Current. 
|===


[[mod_locations_publish_token_class]]
==== PublishTokenType _class_

Defines the set of values that identify a token to which a Location might be published.

At least one of the following fields SHALL be set: `uid`, `visual_number`, or `group_id`.

When `uid` is set, `type` SHALL also be set.

When `visual_number` is set, `issuer` SHALL also be set.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|uid |<<types_cistring_type,CiString>>(36) |? |Unique ID by which this Token can be identified.
|type |<<mod_tokens_tokentype_enum,TokenType>> |? |Type of the token.
|visual_number |<<types_string_type,string>>(64) |? |Visual readable number/identification as printed on the Token (RFID card).
|issuer |<<types_string_type,string>>(64) |? |Issuing company, most of the times the name of the company printed on the token (RFID card), not necessarily the eMSP.
|group_id |<<types_cistring_type,CiString>>(36) |? |This ID groups a couple of tokens. This can be used to make two or more tokens work as one.
|===


[[mod_locations_regularhours_class]]
==== RegularHours _class_

Regular recurring operation or access hours.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|weekday |int(1) |1 |Number of day in the week, from Monday (1) till Sunday (7) 
|period_begin |<<types_string_type,string>>(5) |1 |Begin of the regular period, in local time, given in hours and minutes. Must be in 24h format with leading zeros. Example: "18:15". Hour/Minute separator: ":" Regex: `([0-1][0-9]\|2[0-3]):[0-5][0-9]`.
|period_end |<<types_string_type,string>>(5) |1 |End of the regular period, in local time, syntax as for `period_begin`. Must be later than `period_begin`.
|===

[[mod_locations_example_a]]
===== Example

Operating on weekdays from 8am till 8pm with one exceptional opening on
22/6/2014 and one exceptional closing the Monday after:

[source,json]
----
include::examples/location_regularhours_example.json[lines=2..43]
----


This represents the following schedule, where [line-through]#stroked out# days are without operation hours, *bold* days are where exceptions apply and regular displayed days are where the regular schedule applies.

|===
|Weekday |Mo |Tu |We |Th |Fr |Sa |Su |Mo |Tu |We |Th |Fr |Sa |Su 

|Date |16 |17 |18 |19 |20 |*21* |[line-through]#22# |23 |*[line-through]#24#* |25 |26 |27 |[line-through]#28# |[line-through]#29# 
|Open from |08 |08 |08 |08 |08 |09 |`-` |08 |`-` |08 |08 |08 |`-` |`-` 
|Open till |20 |20 |20 |20 |20 |12 |`-` |20 |`-` |20 |20 |20 |`-` |`-` 
|===

[[mod_locations_status_enum]]
==== Status _enum_

The status of an EVSE.

[cols="3,10",options="header"]
|===
|Value |Description 

|AVAILABLE |The EVSE/Connector is able to start a new charging session. 
|BLOCKED |The EVSE/Connector is not accessible because of a physical barrier, i.e. a car. 
|CHARGING |The EVSE/Connector is in use. 
|INOPERATIVE |The EVSE/Connector is not yet active or it is no longer available (deleted). 
|OUTOFORDER |The EVSE/Connector is currently out of order. 
|PLANNED |The EVSE/Connector is planned, will be operating soon. 
|REMOVED |The EVSE/Connector was discontinued/removed. 
|RESERVED |The EVSE/Connector is reserved for a particular EV driver and is unavailable for other drivers. 
|UNKNOWN |No status information available (also used when offline).
|===

[[mod_locations_statusschedule_class]]
==== StatusSchedule _class_

This type is used to schedule status periods in the future.
The eMSP can provide this information to the EV user for trip planning purposes. A period MAY have no end.
Example: "This station will be running as of tomorrow. Today it is still planned and under construction."

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|period_begin |<<types_datetime_type,DateTime>> |1 |Begin of the scheduled period. 
|period_end |<<types_datetime_type,DateTime>> |? |End of the scheduled period, if known. 
|status |<<mod_locations_status_enum,Status>> |1 |Status value during the scheduled period. 
|===

NOTE: The scheduled status is purely informational. When the status actually changes, the CPO must push an update to the EVSEs `status` field itself.


<<<

:numbered:
[[mod_sessions_sessions_module]]
== _Sessions_ module

*Module Identifier: `sessions`*

*Data owner: `CPO`*

*Type:* Functional Module

The Session object describes one charging session.
The Session object is owned by the CPO back-end system, and can be GET from the CPO system, or pushed by the CPO to another system.

[[mod_sessions_flow_and_lifecycle]]
=== Flow and Lifecycle

[[mod_sessions_push_model]]
==== Push model

When the CPO creates a Session object they push it to the corresponding eMSP by calling <<mod_sessions_msp_put_method,PUT>> on the eMSP's Sessions endpoint with the newly created Session object.

Any changes to a Session in the CPO system are sent to the eMSP system by calling <<mod_sessions_patch_method,PATCH>> on the eMSP's Sessions endpoint with the updated Session object.

Sessions cannot be deleted, final status of a session is: `COMPLETED`.

When the CPO is not sure about the state or existence of a Session object in the eMSP's system, the CPO can call <<mod_sessions_msp_get_method,GET>> on the eMSP's Sessions endpoint to validate the Session object in the eMSP's system.

[[mod_sessions_pull_model]]
==== Pull model

eMSPs who do not support the Push model need to call <<mod_sessions_cpo_get_method,GET>> on the CPO's Sessions endpoint to receive a list of Sessions.

This <<mod_sessions_cpo_get_method,GET>> method can also be used in combination with the Push model to retrieve Sessions after the system (re-)connects to a CPO, to get a list Sessions _missed_ during a downtime of the eMSP's system.


[[mod_sessions_set_charging_preferences]]
==== Set: Charging Preferences

For a lot of smart charging use cases, input from the driver is needed.
The smart charging algorithms need to be able to give certain session priority over others.
In other words they need to know how much energy an EV needs before what time.
Via a <<mod_sessions_cpo_put_method,PUT>> request on the Sender Interface, during an ongoing session,
the eMSP can send <<mod_sessions_charging_preferences_object,Charging Preferences>> on behalf of the driver.

The eMSP can determine if an EVSE supports Charging Preferences by checking if the
<<mod_locations_evse_object,EVSE capabilities>> contains:
<<mod_locations_capability_enum,CHARGING_PREFERENCES_CAPABLE>>.

Via <<mod_tariffs_tariff_object,Tariffs>> the CPO can give different Charging Preferences different prices.
A <<mod_locations_connector_object,Connector>> can have multiple <<mod_tariffs_tariff_object,Tariffs>>,
one for each <<mod_sessions_profile_type_enum,ProfileType>>.


[[mod_sessions_reservation]]
==== Reservation

When a EV driver makes a Reservation for a Charge Point/EVSE, the Sender SHALL create a new Session object with `status` = `RESERVED`
When the Push model is used, the CPO SHALL push the new Session object to the Receiver.

When a reservation results in a charging session for the same `Token`, the Session object `status` to: `ACTIVE`

When a reservation does not result in a charging session, the Session object `status` SHALL be set to: `COMPLETED`.

A CDR might be created even if no energy was transferred to the EV, just for the costs of the reservation.


[[mod_sessions_interfaces_and_endpoints]]
=== Interfaces and Endpoints

[[mod_sessions_cpo_interface]]
==== Sender Interface

Typically implemented by market roles like: CPO.

[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_sessions_cpo_get_method,GET>> |Fetch Session objects of charging sessions last updated between the `{date_from}` and `{date_to}`(<<transport_and_format_pagination,paginated>>).
|POST |n/a
|<<mod_sessions_cpo_put_method,PUT>> |Setting Charging Preferences of an ongoing session.
|PATCH |n/a
|DELETE |n/a 
|===

[[mod_sessions_cpo_get_method]]
===== *GET* Method

Fetch Sessions from a CPO system.

Endpoint structure definition:

`{sessions_endpoint_url}?[date_from={date_from}]&amp;[date_to={date_to}]&amp;[offset={offset}]&amp;[limit={limit}]`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/sessions/?date_from=2019-01-28T12:00:00&date_to=2019-01-29T12:00:00+`

`+https://ocpi.server.com/2.2/sessions/?offset=50+`

`+https://www.server.com/ocpi/2.2/sessions/?date_from=2019-01-29T12:00:00&limit=100+`

`+https://www.server.com/ocpi/cpo/2.2/sessions/?offset=50&limit=100+`


[[mod_sessions_cpo_get_request_parameters]]
====== Request Parameters

Only Sessions with `last_update` between the given `{date_from}` (including) and `{date_to}` (excluding) will be returned.

This request is <<transport_and_format_pagination,paginated>>, it supports the <<transport_and_format_paginated_request,pagination>> related URL parameters.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|date_from |<<types_datetime_type,DateTime>> |yes |Only return Sessions that have `last_updated` after or equal to this Date/Time (inclusive).
|date_to |<<types_datetime_type,DateTime>> |no |Only return Sessions that have `last_updated` up to this Date/Time, but not including (exclusive).
|offset |int |no |The offset of the first object returned. Default is 0. 
|limit |int |no |Maximum number of objects to GET. 
|===

[[mod_sessions_cpo_get_response_data]]
====== Response Data

The response contains a list of Session objects that match the given parameters in the request, the header will contain the <<transport_and_format_paginated_response,pagination>> related headers. 

Any older information that is not specified in the response is considered no longer valid.
Each object must contain all required fields. Fields that are not specified may be considered as null values.

|===
|Datatype |Card. |Description 

|<<mod_sessions_session_object,Session>> |* |List of Session objects that match the request parameters.
|===


[[mod_sessions_cpo_put_method]]
===== *PUT* Method

Set/update the driver's Charging Preferences for this charging session.

Endpoint structure definition:

`{sessions_endpoint_url}/{session_id}/charging_preferences`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/sessions/1234/charging_preferences+`

NOTE: The `/charging_preferences` URL suffix is required when setting Charging Preferences.

[[mod_sessions_cpo_post_request_parameters]]
====== Request Parameters

The following parameter has to be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description

|session_id |<<types_cistring_type,CiString>>(36) |yes |Session.id of the Session for which the Charging Preferences are to be set.
|===

[[mod_sessions_cpo_post_request_body]]
====== Request Body

In the body, a <<mod_sessions_charging_preferences_object,ChargingPreferences>> object has to be provided.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description

|<<mod_sessions_charging_preferences_object,ChargingPreferences>> |1 | Updated Charging Preferences of the driver for this Session.
|===

[[mod_sessions_cpo_post_response_data]]
====== Response Data

The response contains a <<mod_sessions_charging_preferences_response_enum,ChargingPreferencesResponse>> value.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description

|<<mod_sessions_charging_preferences_response_enum,ChargingPreferencesResponse>> |1 |Response to the Charging Preferences PUT request.
|===


[[mod_sessions_emsp_interface]]
===== Receiver Interface

Typically implemented by market roles like: eMSP and SCSP.

Sessions are <<transport_and_format_client_owned_object_push,Client Owned Objects>>,
so the endpoints need to contain the required extra fields: {<<credentials_credentials_object,party_id>>} and {<<credentials_credentials_object,country_code>>}.

Endpoint structure definition:

`{sessions_endpoint_url}/{country_code}/{party_id}/{session_id}`

Example:

`+https://www.server.com/ocpi/cpo/2.2/sessions/BE/BEC/1234+`


[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_sessions_msp_get_method,GET>> |Retrieve a Session object from the eMSP's system with Session.id equal to `{session_id}`.
|POST |n/a 
|<<mod_sessions_msp_put_method,PUT>> |Send a new/updated Session object to the eMSP.
|<<mod_sessions_patch_method,PATCH>> |Update the Session object with Session.id equal to `{session_id}`.
|DELETE |n/a 
|===

[[mod_sessions_msp_get_method]]
===== *GET* Method

The CPO system might request the current version of a Session object from the eMSP's system to,
for example, validate the state, or because the CPO has received an error during a PATCH operation.

[[mod_sessions_msp_get_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the CPO performing the GET on the eMSP's system.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the CPO performing the GET on the eMSP's system.
|session_id |<<types_cistring_type,CiString>>(36) |yes |id of the Session object to get from the eMSP's system.
|===

[[mod_sessions_msp_get_response_data]]
====== Response Data

The response contains the requested Session object.

|===
|Datatype |Card. |Description 

|<<mod_sessions_session_object,Session>> |1 |Requested Session object. 
|===

[[mod_sessions_msp_put_method]]
===== *PUT* Method

Inform the eMSP's system about a new/updated Session object in the CPO's system.

[[mod_sessions_request_body]]
====== Request Body

The request contains the new or updated Session object.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_sessions_session_object,Session>> |1 |New or updated Session object.
|===


[[mod_sessions_cpo_put_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the CPO performing this PUT on the eMSP's system. This SHALL be the same value as the `country_code` in the Session object being pushed.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the CPO performing this PUT on the eMSP's system.  This SHALL be the same value as the `party_id` in the Session object being pushed.
|session_id |<<types_cistring_type,CiString>>(36) |yes |id of the new or updated Session object.
|===

[[mod_sessions_patch_method]]
===== *PATCH* Method

Same as the <<mod_sessions_msp_put_method,PUT>> method, but only the fields/objects that need to be updated have to be present.
Fields/objects which are not specified are considered unchanged.

Any request to the PATCH method SHALL contain the `last_updated` field.

The PATCH method of the Session Receiver interface works on the <<mod_sessions_session_object,Session>> Object,
it SHALL NOT be used with a URL that would try to PATCH an Object within the <<mod_sessions_session_object,Session>> Object.

When a PATCH request contains the `charging_periods` field,
this SHALL be processed as a request to add all the <<mod_cdrs_chargingperiod_class,ChargingPeriod>> Objects to the existing <<mod_sessions_session_object,Session>> Object.

If existing <<mod_cdrs_chargingperiod_class,ChargingPeriod>> Objects in
a <<mod_sessions_session_object,Session>> need to be replaced or removed, the Sender SHALL use the <<mod_sessions_msp_put_method,PUT>> method to replace
the entire <<mod_sessions_session_object,Session>> Object.

all the exiting `charging_periods` SHALL be replaced by the once in the PATCH request.


[[mod_sessions_example_update_the_total_cost]]
====== Example: update the total cost

Patching the `total_cost` needs to be done on the <<mod_sessions_session_object,Session>> Object.

[source,json]
----
PATCH https://www.server.com/ocpi/cpo/2.2/sessions/NL/TNM/101

include::examples/session_patch_example_total_cost.json[]
----


[[mod_sessions_example_add_new_charging_period]]
====== Example: adding a new ChargingPeriod

PATCH used to add a new <<mod_cdrs_chargingperiod_class,ChargingPeriod>> to the Session
and updating all related fields.

[source,json]
----
PATCH https://www.server.com/ocpi/cpo/2.2/sessions/NL/TNM/101

include::examples/session_patch_example_charging_period.json[]
----


[[mod_sessions_object_description]]
=== Object description

[[mod_sessions_session_object]]
==== _Session_ Object

The Session object describes one charging session. That doesn't mean it is required that energy has been transferred between EV and the Charge Point.
It is possible that the EV never took energy from the Charge Point because it was instructed not to take energy by the driver.
But as the EV was connected to the Charge Point, some form of start tariff, park tariff or reservation cost might be relevant.

NOTE: Although OCPI supports such pricing mechanisms, local laws might not allow this.

It is recommended to add enough `ChargingPeriods` to a Session so that the eMSP is able to provide feedback to the EV driver
about the progress of the charging session.
The ideal amount of transmitted Charging Periods depends on the charging speed.
The Charging Periods should be sufficient for useful feedback but they should not generate too much unneeded traffic either.
How many Charging Periods are transmitted is left to the CPO to decide. The following are just some points to consider:

- Adding a new Charging Period every minute for an AC charging session can be too much as it will yield 180 Charging Periods for an (assumed to be) average 3h session.
- A new Charging Period every 30 minutes for a DC fast charging session is not enough as it will yield only one Charging Period for an (assumed to be) average 30min session.

It is also recommended to add Charging Periods for all moments that are relevant for the Tariff changes,
see <<mod_cdrs_cdr_object,CDR object description>> for more information.

For more information about how `step_size` impacts the calculation of the cost of charging also see the <<mod_cdrs_step_size,CDR object description>>.


[cols="4,3,1,9",options="header"]
|===
|Property |Type |Card. |Description 

|country_code |<<types_cistring_type,CiString>>(2) |1 |ISO-3166 alpha-2 country code of the CPO that 'owns' this Session.
|party_id |<<types_cistring_type,CiString>>(3) |1 |CPO ID of the CPO that 'owns' this Session (following the ISO-15118 standard).
|id |<<types_cistring_type,CiString>>(36) |1 |The unique id that identifies the charging session in the CPO platform.
|start_date_time |<<types_datetime_type,DateTime>> |1 |The timestamp when the session became <<mod_sessions_sessionstatus_enum,ACTIVE>> in the Charge Point. +
                                                       When the session is still <<mod_sessions_sessionstatus_enum,PENDING>>, this field SHALL be set to the time the Session was created at the Charge Point.
                                                       When a Session goes from <<mod_sessions_sessionstatus_enum,PENDING>> to <<mod_sessions_sessionstatus_enum,ACTIVE>>,
                                                       this field SHALL be update to the moment the Session went to <<mod_sessions_sessionstatus_enum,ACTIVE>> in the Charge Point.
|end_date_time |<<types_datetime_type,DateTime>> |? |The timestamp when the session was completed/finished, charging might have finished before the session ends, for example: EV is full, but parking cost also has to be paid.
|kwh |<<types_number_type,number>> |1 |How many kWh were charged. 
|cdr_token |<<mod_cdrs_cdr_token_object,CdrToken>> |1 |Token used to start this charging session, including all the relevant information to identify the unique token.
|auth_method |<<mod_cdrs_authmethod_enum,AuthMethod>> |1 |Method used for authentication.
|authorization_reference |<<types_cistring_type,CiString>>(36) |? |Reference to the authorization given by the eMSP.
                                             When the eMSP provided an `authorization_reference` in either:
                                             <<mod_tokens_real-time_authorization,real-time authorization>> or
                                             <<mod_commands_startsession_object,StartSession>>, this field SHALL contain the same value.
                                             When different `authorization_reference` values have been given by the eMSP that are relevant to this Session,
                                             the last given value SHALL be used here.
|location_id |<<types_cistring_type,CiString>>(36) |1 |Location.id of the Location object of this CPO, on which the charging session is/was happening.
|evse_uid |<<types_cistring_type,CiString>>(36) |1 |EVSE.uid of the EVSE of this Location on which the charging session is/was happening.
|connector_id |<<types_cistring_type,CiString>>(36) |1 |Connector.id of the Connector of this Location the charging session is/was happening.
|meter_id |<<types_string_type,string>>(255) |? |Optional identification of the kWh meter. 
|currency |<<types_string_type,string>>(3) |1 |ISO 4217 code of the currency used for this session. 
|charging_periods |<<mod_cdrs_chargingperiod_class,ChargingPeriod>> |* |An optional list of Charging Periods that can be used to calculate and verify the total cost. 
|total_cost |<<types_price_class,Price>> |? |The total cost of the session in the specified currency. This is the price that the eMSP will have to pay to the CPO. A total_cost of 0.00 means free of charge. When omitted, i.e. no price information is given in the Session object, it does not imply the session is/was free of charge.
|status |<<mod_sessions_sessionstatus_enum,SessionStatus>> |1 |The status of the session.
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this Session was last updated (or created). 
|===

NOTE: Different `authorization_reference` values might happen when for example a <<mod_commands_reservenow_object,ReserveNow>>  had a different
`authorization_reference` then the value returned by a <<mod_tokens_real-time_authorization,real-time authorization>>.


[[mod_sessions_examples]]
===== Examples

[[mod_sessions_simple_session_example_of_a_just_starting_session]]
====== Simple Session example of just starting a session

[source,json]
----
include::examples/session_example_1_simple_start.json[]
----


[[mod_sessions_simple_session_example_of_a_short_finished_session]]
====== Simple Session example of a short finished session

[source,json]
----
include::examples/session_example_2_short_finished.json[]
----


[[mod_sessions_charging_preferences_object]]
==== _ChargingPreferences_ Object

Contains the charging preferences of an EV driver.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|profile_type |<<mod_sessions_profile_type_enum,ProfileType>> |1 |Type of Smart Charging Profile selected by the driver.
The <<mod_sessions_profile_type_enum,ProfileType>> has to be supported at the <<mod_locations_connector_object,Connector>> and
for every supported <<mod_sessions_profile_type_enum,ProfileType>>, a <<mod_tariffs_tariff_object,Tariff>> MUST be provided.
This gives the EV driver the option between different pricing options.
|departure_time |<<types_datetime_type,DateTime>> |? |Expected departure. The driver has given this Date/Time as expected departure moment. It is only an estimation and not necessarily the Date/Time of the actual departure.
|energy_need |<<types_number_type,number>> |? |Requested amount of energy in kWh. The EV driver wants to have this amount of energy charged.
|discharge_allowed |boolean |? |The driver allows their EV to be discharged when needed, as long as the other preferences are met: EV is charged with the preferred energy (`energy_need`) until the preferred departure moment (`departure_time`). Default if omitted: *false*
|===


[[mod_sessions_data_types]]
=== Data types

[[mod_sessions_charging_preferences_response_enum]]
==== ChargingPreferencesResponse _enum_

Different smart charging profile types.

No value should be returned instead of `NOT_SUPPORTED` when a PUT with `ChargingPreferences` is received for an EVSE that does not have the capability `CHARGING_PROFILE_CAPABLE`. Use HTTP 404 instead.

[cols="5,8",options="header"]
|===
|Value |Description

|ACCEPTED |Charging Preferences accepted, EVSE will try to accomplish them, although this is no guarantee that they will be fulfilled.
|DEPARTURE_REQUIRED |CPO requires `departure_time` to be able to perform Charging Preference based Smart Charging.
|ENERGY_NEED_REQUIRED |CPO requires `energy_need` to be able to perform Charging Preference based Smart Charging.
|NOT_POSSIBLE |Charging Preferences contain a demand that the EVSE knows it cannot fulfill.
|PROFILE_TYPE_NOT_SUPPORTED |`profile_type` contains a value that is not supported by the EVSE.
|===


[[mod_sessions_profile_type_enum]]
==== ProfileType _enum_

Different smart charging profile types.

[cols="3,10",options="header"]
|===
|Value |Description

|CHEAP   |Driver wants to use the cheapest charging profile possible.
|FAST    |Driver wants his EV charged as quickly as possible and is willing to pay a premium for this, if needed.
|GREEN   |Driver wants his EV charged with as much regenerative (green) energy as possible.
|REGULAR |Driver does not have special preferences.
|===


[[mod_sessions_sessionstatus_enum]]
==== SessionStatus _enum_

Defines the state of a session.

[cols="3,10",options="header"]
|===
|Value |Description

|ACTIVE |The session has been accepted and is active. All pre-conditions were met: Communication between EV and EVSE (for example: cable plugged in correctly), EV or driver is authorized. EV is being charged, or can be charged. Energy is, or is not, being transfered.
|COMPLETED |The session has been finished successfully. No more modifications will be made to the Session object using this state. 
|INVALID |The Session object using this state is declared invalid and will not be billed. 
|PENDING |The session is pending, it has not yet started. Not all pre-conditions are met. This is the initial state. The session might never become an _active_ session.
|RESERVATION |The session is started due to a reservation, charging has not yet started. The session might never become an _active_ session.

|===


<<<

:numbered:
[[mod_cdrs_cdrs_module]]
== _CDRs_ module

*Module Identifier: `cdrs`*

*Data owner: `CPO`*

*Type:* Functional Module

A *Charge Detail Record* is the description of a concluded charging session. The CDR is the only billing-relevant object.
CDRs are sent from the CPO to the eMSP after the charging session has ended.
Although there is no requirement to send CDRs in (semi-) realtime, it is seen as good practice to send them as soon as possible.
But if there is an agreement between parties to send them, for example, once a month, that is also allowed by OCPI.

[[mod_cdrs_flow_and_lifecycle]]
=== Flow and Lifecycle

CDRs are created by the CPO. They most likely will be sent only to the eMSP that needs to pay the bill of the underlying charging session.
Because a CDR is for billing purposes, it cannot be changed or replaced once sent to the eMSP. Changes are simply not allowed.
Instead, a <<mod_cdrs_credit_cdrs,Credit CDR>> can be sent.

CDRs may be send for charging locations that have not been published via the <<mod_locations_locations_module,Location>> module.
This is typically for home chargers.


[[mod_cdrs_credit_cdrs]]
==== Credit CDRs

As CDRs are used for billing and can be seen as a kind of invoice, they cannot be deleted. Instead, they have to be credited.

When a CPO wants to make changes to a CDR that was already sent to the eMSP, the CPO has to send a Credit CDR for the first CDR.
This credit CDR SHALL have a different CDR.id which can be a completely different number,
or it can be the id of the original CDR with something appended like for example: `-C` to make it unique again.
To indicate that a CDR is a Credit CDR, the <<mod_cdrs_cdr_object,`credit`>> field has to be set to `true`.
The Credit CDR references the old CDR via the <<mod_cdrs_cdr_object,`credit_reference_id`>> field,
which SHALL contain the <<mod_cdrs_cdr_object,`id`>> of the original CDR.
The Credit CDR will contain all the data of the original CDR.
Only the values in the <<mod_cdrs_cdr_object,`total_cost`>> field SHALL contain the negative amounts of the original CDR.

After having sent the Credit CDR, the CPO can send a new CDR with a new unique ID
and the fields: <<mod_cdrs_cdr_object,`credit`>> and <<mod_cdrs_cdr_object,`credit_reference_id`>> omitted.

NOTE: How far back in time a CPO can send a Credit CDR is not defined by OCPI.
It is up the business contracts between the different parties involved, as there might be local laws involved etc.


[[mod_cdrs_push_model]]
==== Push model

When the CPO creates CDR(s) they push them to the relevant eMSP by calling <<mod_cdrs_post_method,POST>> on the eMSPs CDRs endpoint with the newly created CDR(s). A CPO is not required to send _all_ CDRs to _all_ eMSPs, it is allowed to only send CDRs to the eMSP that a CDR is relevant to.

CDRs should contain enough information (dimensions) to allow the eMSP to validate the total cost.
It is advised to send enough information to the eMSP so that they can calculate their own costs for billing their customers.
An eMSP might have a very different contract/pricing model with their EV drivers than the tariff structure of the CPO.

If the CPO, for any reason, wants to view a CDR it has posted to an eMSP's system, the CPO can retrieve the CDR by performing a <<mod_cdrs_msp_get_method,GET>> request on the eMSP's CDRs endpoint at the URL returned in the response to the <<mod_cdrs_post_method,POST>>.

[[mod_cdrs_pull_model]]
==== Pull model

eMSPs who do not support the Push model need to call
<<mod_cdrs_cpo_get_method,GET>> on the CPO's CDRs endpoint to receive a list of CDRs.

This <<mod_cdrs_cpo_get_method,GET>> can also be used in combination with the Push model to retrieve CDRs after the system (re-)connects to a CPO, to get a list of CDRs _missed_ during a downtime of the eMSP's system.

A CPO is not required to return all known CDRs, the CPO is allowed to return only the CDRs that are relevant for the requesting eMSP.

[[mod_cdrs_interfaces_and_endpoints]]
=== Interfaces and Endpoints

There are both, a Sender and a Receiver interface for CDRs. Depending on business requirements, parties can decide to use
the Sender Interface (Pull model), or the Receiver Interface (Push model), or both.
Push is the preferred model to use, because the Receiver will receive CDRs in semi-realtime when they are created by the CPO.

[[mod_cdrs_cpo_interface]]
==== Sender Interface

Typically implemented by market roles like: CPO.

The CDRs endpoint can be used retrieve CDRs.

Endpoint structure definition:

`{cdr_endpoint_url}?[date_from={date_from}]&amp;[date_to={date_to}]&amp;[offset={offset}]&amp;[limit={limit}]`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/cdrs/?date_from=2019-01-28T12:00:00&date_to=2019-01-29T12:00:00+`

`+https://ocpi.server.com/2.2/cdrs/?offset=50+`

`+https://www.server.com/ocpi/2.2/cdrs/?date_from=2019-01-29T12:00:00&limit=100+`

`+https://www.server.com/ocpi/cpo/2.2/cdrs/?offset=50&limit=100+`


[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_cdrs_cpo_get_method,GET>> |Fetch CDRs last updated (which in the current version of OCPI can only be the creation Date/Time) between the `{date_from}` and `{date_to}` (<<transport_and_format_pagination,paginated>>). 
|POST |n/a 
|PUT |n/a 
|PATCH |n/a 
|DELETE |n/a 
|===

[[mod_cdrs_cpo_get_method]]
===== *GET* Method

Fetch CDRs from the CPO's system.

[[mod_cdrs_request_parameters]]
====== Request Parameters

If additional parameters: `{date_from}` and/or `{date_to}` are provided, only CDRs with `last_updated`
between the given `{date_from}` (including) and `{date_to}` (excluding) will be returned.

This request is <<transport_and_format_pagination,paginated>>, it supports the <<transport_and_format_paginated_request,pagination>> related URL parameters.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|date_from |<<types_datetime_type,DateTime>> |no |Only return CDRs that have `last_updated` after or equal to this Date/Time (inclusive).
|date_to |<<types_datetime_type,DateTime>> |no |Only return CDRs that have `last_updated` up to this Date/Time, but not including (exclusive).
|offset |int |no |The offset of the first object returned. Default is 0. 
|limit |int |no |Maximum number of objects to GET. 
|===

[[mod_cdrs_cpo_get_response_data]]
====== Response Data

The endpoint returns a list of CDRs matching the given parameters in the GET request, the header will contain the <<transport_and_format_paginated_response,pagination>> related headers. 

Any older information that is not specified in the response is considered no longer valid.
Each object must contain all required fields. Fields that are not specified may be considered as null values.

|===
|Datatype |Card. |Description 

|<<mod_cdrs_cdr_object,CDR>> |* |List of CDRs. 
|===

[[mod_cdrs_emsp_interface]]
==== Receiver Interface

Typically implemented by market roles like: eMSP.

The CDRs endpoint can be used to create and retrieve CDRs.

[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_cdrs_msp_get_method,GET>> |Retrieve an existing CDR.
|<<mod_cdrs_post_method,POST>> |Send a new CDR. 
|PUT |n/a (CDRs cannot be replaced) 
|PATCH |n/a (CDRs cannot be updated) 
|DELETE |n/a (CDRs cannot be removed) 
|===

[[mod_cdrs_msp_get_method]]
===== GET Method

Fetch CDRs from the receivers system.

Endpoint structure definition:

No structure defined. This is open to the eMSP to define, the URL is provided to the CPO by the eMSP in the result of the POST request.
Therefore, OCPI does not define variables.

Example:

`+https://www.server.com/ocpi/2.2/cdrs/1234+`


[[mod_cdrs_response_url]]
====== Response URL

To retrieve an existing URL from the eMSP's system, the URL, returned in the response to a POST of a new CDR, has to be used.

[[mod_cdrs_msp_get_response_data]]
====== Response Data

The endpoint returns the requested CDR, if it exists.

|===
|Datatype |Card. |Description 

|<<mod_cdrs_cdr_object,CDR>> |1 |Requested CDR object. 
|===

[[mod_cdrs_post_method]]
===== POST Method

Creates a new CDR.

The POST method should contain the full and final CDR object.

Endpoint structure definition:

`{cdr_endpoint_url}`

Example:

`+https://www.server.com/ocpi/2.2/cdrs/+`



[[mod_cdrs_request_body]]
====== Request Body

In the POST request the new CDR object is sent.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_cdrs_cdr_object,CDR>> |1 |New CDR object. 
|===

[[mod_cdrs_response_headers]]
====== Response Headers

The response should contain the URL to the just created CDR object in the eMSP's system.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|Location |<<types_url_type,URL>> |yes |URL to the newly created CDR in the eMSP's system, can be used by the CPO system to perform a GET on the same CDR. 
|===

The eMSP returns the URL where the newly created CDR can be found. OCPI does not define a specific structure for this URL.

Example:

`+https://www.server.com/ocpi/emsp/2.2/cdrs/123456+`

[[mod_cdrs_object_description]]
=== Object description

[[mod_cdrs_cdr_object]]
==== _CDR_ Object

The _CDR_ object describes the charging session and its costs, how these costs are composed, etc.

The CDR object is different from the <<mod_sessions_session_object,Session>> object.
The <<mod_sessions_session_object,Session>> object is dynamic as it reflects the current state of the charging session.
The information is meant to be viewed by the driver while the charging session is ongoing.

The CDR on the other hand can be thought of as _sealed_,
preserving the information valid at the moment in time the underlying session was started.
This is a requirement of the main use case for CDRs, namely invoicing.
If e.g. a street is renamed the day after a session took place, the driver should be presented with the name valid at the time the session was started.
This guarantees that the CDR will be recognized as correct by the driver and is not going to be contested.

The _CDR_ object shall always contain information like Location, EVSE, Tariffs and Token as they were *at the start* of the charging session.

[[mod_cdrs_charging_period]]
*ChargingPeriod:*
A CPO SHALL at least start (and add) a <<mod_cdrs_chargingperiod_class,ChargingPeriod>> every moment/event that has relevance for the total costs of a CDR.
During a charging session, different parameters change all the time, like the amount of energy used, or the time of day.
These changes can result in another Tariff Element of the Tariff becoming active.
When another Tariff Element becomes active,
the CPO SHALL add a new Charging Period with at least all the relevant information for the change to the other Tariff Element.
The CPO is allowed to add more _in-between_ Charging Periods to a CDR though. Examples of additional Charging Periods:

- When an energy based Tariff changes in price after 17:00. The CPO SHALL start a new Charging Period at 17:00,
which contains at least the energy in kWh consumed until 17:00.
- When the price of a Tariff is higher when the EV is charging faster than 32A,
a new Charging Period SHALL be added the moment the charging power goes over 32A.
This may be a moment that is calculated by the CPO, as the Charge Point might not send the information to the CPO,
but it can be interpolated by the CPO using the metering information before and after that moment.

[[mod_cdrs_step_size]]
*step_size:*
When calculating the cost of a charging session, `step_size` SHALL only be taken into account once per session for
the <<mod_tariffs_tariffdimensiontype_enum,TariffDimensionType>> <<mod_tariffs_tariffdimensiontype_enum,`ENERGY`>>
and once for <<mod_tariffs_tariffdimensiontype_enum,`PARKING_TIME`>> and <<mod_tariffs_tariffdimensiontype_enum,`TIME`>> combined.
Only the last <<mod_cdrs_chargingperiod_class,ChargingPeriod>> that is relevant for calculating <<mod_tariffs_tariffdimensiontype_enum,`ENERGY`>> based cost shall take into account the `step_size`.
Only the last <<mod_cdrs_chargingperiod_class,ChargingPeriod>> that is relevant for calculating <<mod_tariffs_tariffdimensiontype_enum,`TIME`>> or <<mod_tariffs_tariffdimensiontype_enum,`PARKING_TIME`>> based cost shall take into account the `step_size`.

This means that `step_size` is not taken into account when switching from paying for charging to paying for parking (charging has stopped but EV still connected).
Example: `step_size` for both charging (<<mod_tariffs_tariffdimensiontype_enum,`TIME`>>) and parking is 5 minutes. After 21 minutes of charging,
the EV is full but remains connected for 7 more minutes. The cost of charging will be calculated based on 21 minutes (not 25).
The cost of parking will be calculated based on 10 minutes (`step_size` is 5).

`step_size` is not taken into account when switching from (for example) one <<mod_tariffs_tariffdimensiontype_enum,`ENERGY`>>
based tariff to another.
Example: when charging is more expensive after 17:00. The `step_size` of the tariff before 17:00 will not be used when charging starts before 17:00 and ends after 17:00.
Only the `step_size` of the tariff (<<mod_tariffs_pricecomponent_class,PriceComponent>>) after 17:00 is taken into account.

The `step_size` for the <<mod_tariffs_pricecomponent_class,PriceComponent>> that is used to calculate the cost of such
a 'last' <<mod_cdrs_chargingperiod_class,ChargingPeriod>> SHALL be used. If the `step_size` differs for
the different <<mod_tariffs_tariffelement_class,TariffElements>>,
the `step_size` of the last relevant <<mod_tariffs_pricecomponent_class,PriceComponent>> is used.

The `step_size` is not taken into account when switching between two Tariffs
Example: A driver selects a different <<mod_sessions_set_charging_preferences,Charging Preference>>
<<mod_sessions_profile_type_enum,`profile_type`>>) during an ongoing charging session, the different profile might have a different tariff.

The `step_size` uses the total amount of a certain unit used during a session, not only the last ChargingPeriod.
In other words, when charging tariff per kWh of time differs during a session, the total amount of kWh of time is used in calculations with `step_size`.
Example: Charging cost 0.20 euro before 17:00 and 0.27 after 17:00 both have a `step_size` of 500 Wh.
If a driver charges 4.3 kWh before 17:00 and 1.1 kWh after 17:00, a total of 5.4 kWh is charged. The `step_size` rounds this up to 5.5 kWh total.
It does NOT round the energy used after 17:00 to 1.5 kWh.

In the cases that <<mod_tariffs_tariffdimensiontype_enum,`TIME`>>
and <<mod_tariffs_tariffdimensiontype_enum,`PARKING_TIME`>> Tariff Elements are both used, the total duration is used for the `step_size`
Example: Charging cost 1.00 euro/hour, parking 2.00 euro/hour both have a `step_size` of 10 minutes.
If a driver charges 20 minutes, and keeps his EV connected while it is full for another 20 minutes, a total of 40 minutes is charged.
The `step_size` rounds this up to 45 minutes total.
It does NOT round the parking duration to 30 minutes, making it a total of 50 minutes.


[cols="4,3,1,9",options="header"]
|===
|Property |Type |Card. |Description 

|country_code |<<types_cistring_type,CiString>>(2) |1 |ISO-3166 alpha-2 country code of the CPO that 'owns' this CDR.
|party_id |<<types_cistring_type,CiString>>(3) |1 |CPO ID of the CPO that 'owns' this CDR (following the ISO-15118 standard).
|id |<<types_cistring_type,CiString>>(39) |1 |Uniquely identifies the CDR within the CPO's platform (and suboperator platforms). This field is longer than the usual 36 characters to allow for credit CDRs to have <<mod_cdrs_credit_cdrs,something appended>> to the original ID. Normal (non-credit) CDRs SHALL only have an ID with a maximum length of 36.
|start_date_time |<<types_datetime_type,DateTime>> |1 |Start timestamp of the charging session, or in-case of a reservation (before the start of a session) the start of the reservation.
|end_date_time |<<types_datetime_type,DateTime>> |1 |The timestamp when the session was completed/finished, charging might have finished before the session ends, for example: EV is full, but parking cost also has to be paid.
|session_id |<<types_cistring_type,CiString>>(36) |? |Unique ID of the Session for which this CDR is sent. Is only allowed to be omitted when the CPO has not implemented the Sessions module or this CDR is the result of a reservation that never became a charging session, thus no OCPI Session.
|cdr_token |<<mod_cdrs_cdr_token_object,CdrToken>> |1 |Token used to start this charging session, includes all the relevant information to identify the unique token.
|auth_method |<<mod_cdrs_authmethod_enum,AuthMethod>> |1 |Method used for authentication. 
|authorization_reference |<<types_cistring_type,CiString>>(36) |? |Reference to the authorization given by the eMSP.
                                             When the eMSP provided an `authorization_reference` in either:
                                             <<mod_tokens_real-time_authorization,real-time authorization>> or
                                             <<mod_commands_startsession_object,StartSession>>, this field SHALL contain the same value.
                                             When different `authorization_reference` values have been given by the eMSP that are relevant to this Session,
                                             the last given value SHALL be used here.
|cdr_location |<<mod_cdrs_cdr_location_class,CdrLocation>> |1 |Location where the charging session took place, including only the relevant <<mod_locations_evse_object,EVSE>> and <<mod_locations_connector_object,Connector>>.
|meter_id |<<types_string_type,string>>(255) |? |Identification of the Meter inside the Charge Point.
|currency |<<types_string_type,string>>(3) |1 |Currency of the CDR in ISO 4217 Code. 
|tariffs |<<mod_tariffs_tariff_object,Tariff>> |* |List of relevant Tariff Elements, see: <<mod_tariffs_tariff_object,Tariff>>. When relevant, a _Free of Charge_ tariff should also be in this list, and point to a defined _Free of Charge_ Tariff. 
|charging_periods |<<mod_cdrs_chargingperiod_class,ChargingPeriod>> |+ |List of Charging Periods that make up this charging session. A session consists of 1 or more periods, where each period has a different relevant Tariff.
|signed_data |<<mod_cdrs_signed_data_class,SignedData>> |? |Signed data that belongs to this charging Session.
|total_cost |<<types_price_class,Price>> |1 |Total sum of all the costs of this transaction in the specified currency.
|total_fixed_cost |<<types_price_class,Price>> |? |Total sum of all the fixed costs in the specified currency, except fixed price components of parking and reservation. The cost not depending on amount of time/energy used etc. Can contain costs like a start tariff.
|total_energy |<<types_number_type,number>> |1 |Total energy charged, in kWh.
|total_energy_cost |<<types_price_class,Price>> |? |Total sum of all the cost of all the energy used, in the specified currency.
|total_time |<<types_number_type,number>> |1 |Total duration of the charging session (including the duration of charging and not charging), in hours.
|total_time_cost |<<types_price_class,Price>> |? |Total sum of all the cost related to duration of charging during this transaction, in the specified currency.
|total_parking_time |<<types_number_type,number>> |? |Total duration of the charging session where the EV was not charging (no energy was transferred between EVSE and EV), in hours.
|total_parking_cost |<<types_price_class,Price>> |? |Total sum of all the cost related to parking of this transaction, including fixed price components, in the specified currency.
|total_reservation_cost |<<types_price_class,Price>> |? |Total sum of all the cost related to a reservation of a Charge Point, including fixed price components, in the specified currency.
|remark |<<types_string_type,string>>(255) |? |Optional remark, can be used to provide additional human readable information to the CDR, for example: reason why a transaction was stopped.
|invoice_reference_id |<<types_cistring_type,CiString>>(39) |? |This field can be used to reference an invoice, that will later be send for this CDR. Making it easier to link a CDR to a given invoice. Maybe even group CDRs that will be on the same invoice.
|credit |boolean |? |When set to `true`, this is a Credit CDR, and the field `credit_reference_id` needs to be set as well.
|credit_reference_id |<<types_cistring_type,CiString>>(39) |? |Is required to be set for a Credit CDR. This SHALL contain the `id` of the CDR for which this is a Credit CDR.
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this CDR was last updated (or created).
|===

NOTE: The actual charging duration (energy being transferred between EVSE and EV) of a charging session can be calculated: `total_charging_time = total_time - total_parking_time`. 

NOTE: Having both a `credit` and a `credit_reference_id` might seem redundant.
But it is seen as an advantage as a boolean flag used in queries is much faster than simple string comparison of references.

NOTE: Different `authorization_reference` values might happen when for example a <<mod_commands_reservenow_object,ReserveNow>>  had a different
`authorization_reference` then the value returned by a <<mod_tokens_real-time_authorization,real-time authorization>>.


[[mod_cdrs_example_of_a_cdr]]
===== Example of a CDR

[source,json]
----
include::examples/cdr_example.json[]
----


[[mod_cdrs_data_types]]
=== Data types

[[mod_cdrs_authmethod_enum]]
==== AuthMethod _enum_

[cols="3,10",options="header"]
|===
|Value |Description 

|AUTH_REQUEST |Authentication request has been sent to the eMSP.
|COMMAND |Command like <<mod_commands_startsession_object,StartSession>>
          or <<mod_commands_reservenow_object,ReserveNow>> used to start the Session,
          the Token provided in the Command was used as authorization.
|WHITELIST |Whitelist used for authentication, no request to the eMSP has been performed.
|===

[[mod_cdrs_cdrdimension_class]]
==== CdrDimension _class_

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|type |<<mod_cdrs_cdrdimensiontype_enum,CdrDimensionType>> |1 |Type of CDR dimension.
|volume |<<types_number_type,number>> |1 |Volume of the dimension consumed, measured according to the dimension type. 
|===

[[mod_cdrs_cdrdimensiontype_enum]]
==== CdrDimensionType _enum_

This enumeration contains allowed values for CdrDimensions, which are used to define dimensions of ChargingPeriods in both `CDRs` and `Sessions`.
Some of these values are not useful for `CDRs`, and SHALL therefor only be used in `Sessions`, these are marked in the column: Session Only

[cols="7,3,24",options="header"]
|===
|Value |Session +
        Only| Description

|CURRENT          |Y| Average charging current during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>: defined in A (Ampere). When negative, the current is flowing from the EV to the grid.
|ENERGY           | | Total amount of energy (dis-)charged during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>: defined in kWh. When negative, more energy was feed into the grid then charged into the EV. Default step_size is 1.
|ENERGY_EXPORT    |Y| Total amount of energy feed back into the grid: defined in kWh.
|ENERGY_IMPORT    |Y| Total amount of energy charged, defined in kWh.
|MAX_CURRENT      | | Sum of the maximum current over all phases, reached during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>: defined in A (Ampere).
|MIN_CURRENT      | | Sum of the minimum current over all phases, reached during  this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>, when negative, current has flowed from the EV to the grid. Defined in A (Ampere).
|MAX_POWER        | | Maximum power reached during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>: defined in kW (Kilowatt).
|MIN_POWER        | | Minimum power reached during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>: defined in kW (Kilowatt), when negative, the power has flowed from the EV to the grid.
|PARKING_TIME     | | Time during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>> not charging: defined in hours, default step_size multiplier is 1 second.
|POWER            |Y| Average power during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>: defined in kW (Kilowatt). When negative, the power is flowing from the EV to the grid.
|RESERVATION_TIME | | Time during this  <<mod_cdrs_chargingperiod_class,ChargingPeriod>> Charge Point has been reserved and not yet been in use for this customer: defined in hours, default step_size multiplier is 1 second.
|STATE_OF_CHARGE  |Y| Current state of charge of the EV, in percentage, values allowed: 0 to 100. See note below.
|TIME             | | Time charging during this <<mod_cdrs_chargingperiod_class,ChargingPeriod>>: defined in hours, default step_size multiplier is 1 second.
|===

NOTE: OCPI makes it possible to provide SoC in the Session object.
This information can be useful to show the current State of Charge to an EV driver during charging.
Implementers should be aware that SoC is only available at some DC Chargers.
Which is currently a small amount of the total amount of Charge Points.
Of these DC Chargers, only a small percentage currently provides SoC via OCPP to the CPO.
Then there is also the question if SoC is allowed to be provided to third-parties as it can be seen as privacy-sensitive information.
So if an implementer wants to show SoC in, for example an App, care should be taken,
to make the App work without SoC, as this will probably not always be available.


[[mod_cdrs_cdr_location_class]]
==== CdrLocation _class_

The _CdrLocation_ class contains only the relevant information from the <<mod_locations_location_object,Location>> object that is needed in a CDR.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|id |<<types_cistring_type,CiString>>(36) |1 |Uniquely identifies the location within the CPO's platform (and suboperator platforms). This field can never be changed, modified or renamed.
|name |<<types_string_type,string>>(255) |? |Display name of the location.
|address |<<types_string_type,string>>(45) |1 |Street/block name and house number if available.
|city |<<types_string_type,string>>(45) |1 |City or town.
|postal_code |<<types_string_type,string>>(10) |1 |Postal code of the location.
|country |<<types_string_type,string>>(3) |1 |ISO 3166-1 alpha-3 code for the country of this location.
|coordinates |<<mod_locations_geolocation_class,GeoLocation>> |1 |Coordinates of the location.
|evse_uid |<<types_cistring_type,CiString>>(36) |1 |Uniquely identifies the EVSE within the CPO's platform (and suboperator platforms). For example a database unique ID or the actual _EVSE ID_. This field can never be changed, modified or renamed. This is the _technical_ identification of the EVSE, not to be used as _human readable_ identification, use the field: `evse_id` for that.
|evse_id |<<types_cistring_type,CiString>>(48) |1 |Compliant with the following specification for EVSE ID from "eMI3 standard version V1.0" (http://emi3group.com/documents-links/[http://emi3group.com/documents-links/]) "Part 2: business objects.".
|connector_id |<<types_cistring_type,CiString>>(36) |1 |Identifier of the connector within the EVSE.
|connector_standard |<<mod_locations_connectortype_enum,ConnectorType>> |1 |The standard of the installed connector.
|connector_format |<<mod_locations_connectorformat_enum,ConnectorFormat>> |1 |The format (socket/cable) of the installed connector.
|connector_power_type |<<mod_locations_powertype_enum,PowerType>> |1 |
|===


[[mod_cdrs_cdr_token_object]]
==== CdrToken _class_

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|uid |<<types_cistring_type,CiString>>(36) |1 |Unique ID by which this Token can be identified. +
This is the field used by the CPO's system (RFID reader on the Charge Point) to identify this token. +
Currently, in most cases: `type=RFID`, this is the RFID hidden ID as read by the RFID reader, but that is not a requirement. +
If this is a `type=APP_USER` Token, it will be a unique, by the eMSP, generated ID.
|type |<<mod_tokens_tokentype_enum,TokenType>> |1 |Type of the token
|contract_id |<<types_cistring_type,CiString>>(36) |1 |Uniquely identifies the EV driver contract token within the eMSP's platform (and suboperator platforms). Recommended to follow the specification for eMA ID from "eMI3 standard version V1.0" (http://emi3group.com/documents-links/[http://emi3group.com/documents-links/]) "Part 2: business objects."
|===



[[mod_cdrs_chargingperiod_class]]
==== ChargingPeriod _class_

A Charging Period consists of a start timestamp and a list of possible values that influence this period, for example: amount of energy charged this period, maximum current during this period etc.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|start_date_time |<<types_datetime_type,DateTime>> |1 |Start timestamp of the charging period. A period ends when the next period starts. The last period ends when the session ends. 
|dimensions |<<mod_cdrs_cdrdimension_class,CdrDimension>> |+ |List of relevant values for this charging period.
|tariff_id |<<types_cistring_type,CiString>>(36) |? |Unique identifier of the Tariff that is relevant for this Charging Period. If not provided, no Tariff is relevant during this period.
|===


[[mod_cdrs_signed_data_class]]
==== SignedData _class_

This class contains all the information of the signed data.
Which encoding method is used, if needed, the public key and a list of signed values.

[cols="4,2,1,9",options="header"]
|===
|Property |Type |Card. |Description

|encoding_method         | <<types_cistring_type,CiString>>(36)  |1 |The name of the encoding used in the SignedData field. This is the name given to the encoding by a company or group of companies. See note below.
|encoding_method_version | int                                                  |? |Version of the EncodingMethod (when applicable)
|public_key              | <<types_cistring_type,CiString>>(512) |? |Public key used to sign the data, base64 encoded.
|signed_values           | <<mod_cdrs_signed_value_class,SignedValue>>          |+ |One or more signed values.
|url                     | <<types_cistring_type,CiString>>(512) |? |URL that can be shown to an EV driver. This URL gives the EV driver the possibility to check the signed data from a charging session.
|===

NOTE: For the German Eichrecht, different solutions are used,
all have (somewhat) different encodings. Below the table with known implementations and the contact information for more information.

[cols="5,8,4",options="header"]
|===
|Name |Description |Contact

|OCMF                      |Proposed by SAFE  | https://has-to-be.com[]
|Alfen Eichrecht           | Alfen Eichrecht encoding / implementation. | https://alfen.com/de/downloads[]
|EDL40 E-Mobility Extension|eBee smart technologies implementation | https://www.ebee.berlin[]
|EDL40 Mennekes            |Mennekes implementation |
|===


[[mod_cdrs_signed_value_class]]
==== SignedValue _class_

This class contains the signed and the plain/unsigned data.
By decoding the data, the receiver can check if the content has not been altered.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|nature      |<<types_cistring_type,CiString>>(32)  |1 |Nature of the value, in other words, the event this value belongs to. +
                                                                       Possible values at moment of writing: +
                                                                       - Start (value at the start of the Session) +
                                                                       - End (signed value at the end of the Session) +
                                                                       - Intermediate (signed values take during the Session, after Start, before End) +
                                                                       Others might be added later.
|plain_data  |<<types_cistring_type,CiString>>(512) |1 |The unencoded string of data. The format of the content depends on the EncodingMethod field.
|signed_data |<<types_cistring_type,CiString>>(512) |1 |Blob of signed data, base64 encoded. The format of the content depends on the EncodingMethod field.
|===


<<<

:numbered:
[[mod_tariffs_tariffs_module]]
== _Tariffs_ module

*Module Identifier: `tariffs`*

*Data owner: `CPO`*

*Type:* Functional Module

The Tariffs module gives eMSPs information about the tariffs used by the CPO.

[[mod_tariffs_flow_and_lifecycle]]
=== Flow and Lifecycle

[[mod_tariffs_push_model]]
==== Push model

When the CPO creates a new Tariff they push them to the eMSPs by calling the <<mod_tariffs_put_method,PUT>> method on the eMSPs
Tariffs endpoint with the newly created Tariff object.

Any changes to the Tariff(s) in the CPO's system can be sent to the eMSPs systems by calling the <<mod_tariffs_put_method,PUT>>
method on the eMSPs Tariffs endpoint with the updated Tariff object.

When the CPO deletes a Tariff, they will update the eMSPs systems by calling <<mod_tariffs_delete_method,DELETE>>
on the eMSPs Tariffs endpoint with the ID of the Tariff that was deleted.

When the CPO is not sure about the state or existence of a Tariff object in the system of an eMSP, the
CPO can use a <<mod_tariffs_msp_get_method,GET>> request to validate the Tariff object in the eMSP's system. 

[[mod_tariffs_pull_model]]
==== Pull model

eMSPs who do not support the Push model need to call
<<mod_tariffs_cpo_get_method,GET>> on the CPO's Tariff endpoint to receive
all Tariffs, replacing the current list of known Tariffs with the newly received list.

[[mod_tariffs_interfaces_and_endpoints]]
=== Interfaces and Endpoints

There is both a Sender and a Receiver interface for Tariffs. Advised is to use the push direction from Sender to Receiver during normal operation.
The Sender interface is meant to be used when the connection between two parties is established to retrieve the current list of Tariffs objects, and when the Receiver is not 100% sure the Tariff cache is still up-to-date.

[[mod_tariffs_cpo_interface]]
==== Sender Interface

Typically implemented by market roles like: CPO.

The Sender's Tariffs interface gives the Receiver the ability to request Tariffs information.


[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_tariffs_cpo_get_method,GET>> |Returns Tariff objects from the CPO, last updated between the `{date_from}` and `{date_to}` (<<transport_and_format_pagination,paginated>>) 
|POST |n/a 
|PUT |n/a 
|PATCH |n/a 
|DELETE |n/a 
|===

[[mod_tariffs_cpo_get_method]]
===== *GET* Method

Fetch information about all Tariffs.

Endpoint structure definition:

`{tariffs_endpoint_url}?[date_from={date_from}]&[date_to={date_to}]&[offset={offset}]&[limit={limit}]`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/tariffs/?date_from=2019-01-28T12:00:00&date_to=2019-01-29T12:00:00+`

`+https://ocpi.server.com/2.2/tariffs/?offset=50+`

`+https://www.server.com/ocpi/2.2/tariffs/?date_from=2019-01-29T12:00:00&limit=100+`

`+https://www.server.com/ocpi/cpo/2.2/tariffs/?offset=50&limit=100+`


[[mod_tariffs_cpo_get_request_parameters]]
====== Request Parameters

If additional parameters: `{date_from}` and/or `{date_to}` are provided,
only Tariffs with `last_updated` between the given `{date_from}` (including) and `{date_to}` (excluding) will be returned.

This request is <<transport_and_format_pagination,paginated>>, it supports the <<transport_and_format_paginated_request,pagination>> related URL parameters.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|date_from |<<types_datetime_type,DateTime>> |no |Only return Tariffs that have `last_updated` after or equal to this Date/Time (inclusive).
|date_to |<<types_datetime_type,DateTime>> |no |Only return Tariffs that have `last_updated` up to this Date/Time, but not including (exclusive).
|offset |int |no |The offset of the first object returned. Default is 0. 
|limit |int |no |Maximum number of objects to GET. 
|===

[[mod_tariffs_cpo_get_response_data]]
====== Response Data

The endpoint returns an object with a list of valid Tariffs, the header will contain the <<transport_and_format_paginated_response,pagination>> related headers.

Any older information that is not specified in the response is considered no longer valid.
Each object must contain all required fields. Fields that are not specified may be considered as null values.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tariffs_tariff_object,Tariff>> |* |List of all tariffs. 
|===

[[mod_tariffs_emsp_interface]]
==== Receiver Interface

Typically implemented by market roles like: eMSP and NSP.

Tariffs are <<transport_and_format_client_owned_object_push,Client Owned Objects>>, so the endpoints need to contain the required extra fields: {<<credentials_credentials_object,party_id>>} and {<<credentials_credentials_object,country_code>>}.

Endpoint structure definition:

`{tariffs_endpoint_url}/{country_code}/{party_id}/{tariff_id}`

Example:

`+https://www.server.com/ocpi/cpo/2.2/tariffs/BE/BEC/12+`


[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_tariffs_msp_get_method,GET>> |Retrieve a Tariff as it is stored in the eMSP's system. 
|POST |n/a 
|<<mod_tariffs_put_method,PUT>> |Push new/updated Tariff object to the eMSP. 
|PATCH|n/a
|<<mod_tariffs_delete_method,DELETE>> |Remove a Tariff object which is no longer in use and will not be used in future either. 
|===

[[mod_tariffs_msp_get_method]]
===== *GET* Method

If the CPO wants to check the status of a Tariff in the eMSP's system, it might GET the object from the eMSP's system for validation purposes.
After all, the CPO is the owner of the object, so it would be illogical if the eMSP's system had a different status or was missing the object entirely.

[[mod_tariffs_msp_get_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the CPO performing the PUT request on the eMSP's system.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the CPO performing the PUT request on the eMSP's system.
|tariff_id |<<types_cistring_type,CiString>>(36) |yes |Tariff.id of the Tariff object to retrieve.
|===

[[mod_tariffs_msp_get_response_data]]
====== Response Data

The response contains the requested object.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tariffs_tariff_object,Tariff>> |1 |The requested Tariff object. 
|===

[[mod_tariffs_put_method]]
===== *PUT* Method

New or updated Tariff objects are pushed from the CPO to the eMSP.

[[mod_tariffs_request_body]]
====== Request Body

In the PUT request, the new or updated Tariff object is sent in the body.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tariffs_tariff_object,Tariff>> |1 |New or updated Tariff object.
|===

[[mod_tariffs_msp_put_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the CPO performing the PUT request on the eMSP's system. This SHALL be the same value as the `country_code` in the Tariff object being pushed.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the CPO performing the PUT request on the eMSP's system. This SHALL be the same value as the `party_id` in the Tariff object being pushed.
|tariff_id |<<types_cistring_type,CiString>>(36) |yes |Tariff.id of the Tariff object to create or replace.
|===

[[mod_tariffs_example_new_tariff_2_euro_per_hour]]
====== Example: New Tariff 2 euro per hour charging time (not parking).

[source,json]
----
PUT To URL: https://www.server.com/ocpi/emsp/2.2/tariffs/NL/TNM/12

include::examples/tariff_put_example.json[]
----


[[mod_tariffs_delete_method]]
===== *DELETE* Method

Delete a Tariff object which is not used any more and will not be used in future either.

NOTE: Before deleting a Tariff object, it is RECOMMENDED to ensure that the Tariff object is not referenced by any <<mod_locations_connector_object,Connector object>> within the `tariff_ids` anymore.

[[mod_tariffs_msp_delete_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the CPO performing the PUT request on the eMSP's system.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the CPO performing the PUT request on the eMSP's system.
|tariff_id |<<types_cistring_type,CiString>>(36) |yes |Tariff.id of the Tariff object to delete.
|===

[[mod_tariffs_object_description]]
=== Object description

[[mod_tariffs_tariff_object]]
==== _Tariff_ Object

A Tariff object consists of a list of one or more Tariff Elements, which can be used to create complex Tariff structures.

When the list of Tariff Elements contains more than one Element with the same Tariff Dimension (ENERGY/FLAT/TIME etc.),
than the first Tariff Element with that Dimension in the list with matching Tariff Restrictions will be used.
Only one Tariff per Element type can be active at any point in time, but multiple Tariff Types can be active at once.
IE you can have an `ENERGY` element and `TIME` element active at the same time, but only the first valid element of each.

When no Tariff Element with a specific Dimension is found for which the Restrictions match,
and there is no Tariff Element in the list with the given Dimension without Restrictions,
there will be no costs for that Tariff Dimension.

It is advised to always add a "default" Tariff Element per Dimension (ENERGY/FLAT/TIME etc.).
This can be achieved by adding a Tariff Element without Restrictions after all other occurrences of the same Dimension
in the list of Tariff Elements (the order is important).
Such a Tariff Element will act as fallback when no other Tariff Element of a specific Dimension matches the relevant parameters (Restrictions).

To define a "Free of Charge" tariff in OCPI, a Tariff with `type` = `FLAT` and `price` = `0.00` has to be provided.
See: <<mod_tariffs_free_of_charge_tariff_example,Free of Charge Tariff example>>

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|country_code |<<types_cistring_type,CiString>>(2) |1 |ISO-3166 alpha-2 country code of the CPO that _owns_ this Tariff.
|party_id |<<types_cistring_type,CiString>>(3) |1 |CPO ID of the CPO that _owns_ this Tariff (following the ISO-15118 standard).
|id |<<types_cistring_type,CiString>>(36) |1 |Uniquely identifies the tariff within the CPO's platform (and suboperator platforms).
|currency |<<types_string_type,string>>(3) |1 |ISO-4217 code of the currency of this tariff.
|type |<<mod_tariffs_tariff_type,TariffType>> |? | Defines the type of the tariff. This allows for distinction in case of given <<mod_sessions_set_charging_preferences,Charging Preferences>>. When omitted, this tariff is valid for all sessions.
|tariff_alt_text |<<types_displaytext_class,DisplayText>> |* |List of multi-language alternative tariff info texts.
|tariff_alt_url |<<types_url_type,URL>> |? |URL to a web page that contains an explanation of the tariff information in human readable form.
|min_price |<<types_price_class,Price>> |? |When this field is set, a Charging Session with this tariff will at least cost this amount.
      This is different from a `FLAT` fee (Start Tariff, Transaction Fee), as a `FLAT` fee is a fixed amount that has to be paid for any Charging Session.
      A minimum price indicates that when the cost of a Charging Session is lower than this amount, the cost of the Session will be equal to this amount. (Also see note below)
|max_price |<<types_price_class,Price>> |? |When this field is set, a Charging Session with this tariff will NOT cost more than this amount. (See note below)
|elements |<<mod_tariffs_tariffelement_class,TariffElement>> |+ |List of Tariff Elements.
|start_date_time |<<types_datetime_type,DateTime>> |? |The time when this tariff becomes active, in UTC, `time_zone` field of the <<mod_locations_location_object,Location>> can be used to convert to local time.
                                                                     Typically used for a new tariff that is already given with the location, before it becomes active. (See note below)
|end_date_time |<<types_datetime_type,DateTime>> |? |The time after which this tariff is no longer valid, in UTC, `time_zone` field if the <<mod_locations_location_object,Location>> can be used to convert to local time.
                                                                    Typically used when this tariff is going to be replaced with a different tariff in the near future. (See note below)
|energy_mix |<<mod_locations_energymix_class,EnergyMix>> |? |Details on the energy supplied with this tariff.
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this Tariff was last updated (or created). 
|===

NOTE: `min_price`: As the VAT might be built up of different parts, there might be situations where minimum cost including VAT is reached earlier or later than the minimum cost excluding VAT.
So as a rule, they both apply:
 - The total cost of a Charging Session excluding VAT can never be lower than the `min_price` excluding VAT.
 - The total cost of a Charging Session including VAT can never be lower than the `min_price` including VAT.

NOTE: `max_price`: As the VAT might be built up of different parts, there might be situations where maximum cost including VAT is reached earlier or later than the maximum cost excluding VAT.
So as a rule, they both apply:
 - The total cost of a Charging Session excluding VAT can never be higher than the `max_price` excluding VAT.
 - The total cost of a Charging Session including VAT can never be higher than the `max_price` including VAT.

NOTE: `start_date_time` and `end_date_time`: When the Tariff of a Charge Point (Location) is changed during an ongoing charging session,
it is common to not switch the Tariff until the ongoing session is finished. But this is NOT a rule of OCPI.
When charging at a Charge Point, a driver accepts the tariff which is valid when they start their charging session.
If the Tariff of the Charge Point would change during the charging session,
the driver might get billed something they didn't agree to when starting the session.

NOTE: The fields: `tariff_alt_text` and `tariff_alt_url` may be used separately,
or in combination with each other or even combined with the structured tariff `elements`.
When a Tariff contains both the `tariff_alt_text` and `elements` fields,
the `tariff_alt_text` SHALL only contain additional tariff information in human-readable text,
not the price information that is also available via the `elements` field.
Reason for this: the eMSP might have additional fees they want to include in communication with their customer.


[[mod_tariffs_examples]]
===== Examples

In the following section, a few different pricing strategies will be explained with some Tariff examples.
For simplicity, we will use euro as currency in all of the examples if not mentioned otherwise.

[[mod_tariffs_simple_tariff_example_0_25_euro_per_kwh]]
====== Simple Tariff example 0.25 euro per kWh

* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

This tariff will result in costs of 5.00 euro (excl. VAT) or 5.50 euro (incl. VAT) when 20 kWh are charged.

[source,json]
----
include::examples/tariff_8_simple_025kwh.json[]
----


[[mod_tariffs_tariff_example_0_25_euro_per_kwh_start]]
====== Tariff example 0.25 euro per kWh + start fee

* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

This tariff will result in total cost of 5.50 euro (excl. VAT) or 6.10 euro (incl. VAT) when 20 kWh are charged.

[source,json]
----
include::examples/tariff_9_025kwh_start.json[]
----


[[mod_tariffs_tariff_example_0_25_euro_per_kwh_min_price]]
====== Tariff example 0.25 euro per kWh + minimum price

* Minimum price
** 0.50 euro (excl. VAT)
** 0.55 euro (incl. VAT, which is 10%)
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

This tariff will result in costs of 5.00 euro (excl. VAT) or 5.50 euro (incl. VAT) when 20 kWh are charged.
But if less than 2 kWh is charged, 0.50 euro (excl. VAT) or 0.55 euro (incl. VAT) will be billed.

This is different from a start fee as can be seen when compared to the example above.

[source,json]
----
include::examples/tariff_12_025kwh_min_price.json[]
----


[[mod_tariffs_tariff_example_0_25_euro_per_kwh_parking_start]]
====== Tariff example 0.25 euro per kWh + parking fee + start fee

* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh
* Parking
[disc]
** 2.00 euro per hour (excl. VAT)
** 20% VAT
** Billed per 15 min (900 seconds)

For a charging session where 20 kWh are charged and the vehicle is parked for 40 minutes after the session ended,
this tariff will result in costs of 7.00 euro (excl. VAT) or 7.90 euro (incl. VAT).
Because the parking time is billed per 15 minutes, the driver has to pay for 45 minutes of parking even though
they left 40 minutes after their vehicle stopped charging.

[source,json]
----
include::examples/tariff_10_025kwh_parking_start.json[]
----


[[mod_tariffs_tariff_example_0_25_euro_per_kwh_start_max_price]]
====== Tariff example 0.25 euro per kWh + start fee + max price + tariff end date

* Maximum price
[disc]
** 10 euro (excl. VAT)
** 11 euro (incl. VAT, which is 10%)
* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

This tariff has an end date: 30 June 2019, which is typically used when a tariff is going to be replaced by a new tariff.
A <<mod_locations_connector_object,Connector>> of a <<mod_locations_location_object,Location>> can have multiple Tariffs (IDs) assigned.
By assigning both, the old and the new tariff ID, they will automatically be replaced.
It is not required to update all Locations at the same time, the old tariff can also be removed later.

For a charging session where 50 kWh are charged,
this tariff will result in costs of 10.00 euro (excl. VAT) or 11.00 euro (incl. VAT) due to the price limit.
If only 30 kWh were charged, the costs would be 8.00 euro (excl. VAT) and 8.85 euro (incl. VAT),
as the start fee combined with the energy costs would be lower than the defined max price.

[source,json]
----
include::examples/tariff_6_025kwh_start_max_price.json[]
----


[[mod_tariffs_simple_tariff_example_2_euro_per_hour]]
====== Simple Tariff example 2 euro per hour

An example of a tariff where the driver does not pay per kWh, but for the time of using the Charge Point.

* Charging Time
[disc]
** 2.00 euro per hour (excl. VAT)
** 10% VAT
** Billed per 1 min (60 seconds)

As this is tariff only has a `TIME` price_component, the driver will not be billed for time they are not charging: `PARKING_TIME`

For a charging session of 2.5 hours,
this tariff will result in costs of 5.00 euro (excl. VAT) or 5.50 euro (incl. VAT).

[source,json]
----
include::examples/tariff_1_simple_2hour.json[]
----


[[mod_tariffs_simple_tariff_example_3_euro_per_hour_5_euro_parking]]
====== Simple Tariff example 3 euro per hour, 5 euro per hour parking

Example of a tariff where the driver pays for the time of using the Charge Point, but pays more when the car is no longer charging,
to discourage the EV driver of leaving his EV connected when it is already full.

* Charging Time
[disc]
** 3.00 euro per hour (excl. VAT)
** 10% VAT
** Billed per 1 min (60 seconds)
* Parking
[disc]
** 5.00 euro per hour (excl. VAT)
** 20% VAT
** Billed per 5 min (300 seconds)

A charging session of 2.5 hours (charging), where the vehicle is parked for 42 more minutes after charging ended,
results in a total session time of 150 minutes (charging) + 42 minutes (parking).
This session with this tariff will result in total cost of 11.25 euro (excl. VAT) or 12.75 euro (incl. VAT).
Because the parking time is billed per 5 minutes, the driver has to pay for 45 minutes of parking even though
they left 42 minutes after their vehicle stopped charging.

[source,json]
----
include::examples/tariff_13_simple_3hour_5parking.json[]
----


[[mod_tariffs_simple_tariff_example_with_alternative_multi_language_text]]
====== Ad-Hoc simple Tariff example with multiple languages

For ad-hoc charging (paying for charging without a contract), the tariff `elements` are less needed.
The eMSP is not involved when a driver uses ad-hoc payment at the Charge Point, so no CDR is send to an eMSP.
Having a good human readable text is much more useful.

* Charging Time
[disc]
** 1.9 euro per hour (excl. VAT)
** 5.2% VAT
** Billed per 5 minutes (300 seconds)

For a charging session of 2.5 hours,
this tariff will result in costs of 4.75 euro (excl. VAT) or 5.00 euro (incl. VAT).

[source,json]
----
include::examples/tariff_2_alt_text.json[]
----


[[mod_tariffs_adhoc_tariff_example_not_possible_with_ocpi]]
====== Ad-Hoc Tariff example not possible with OCPI

For this example, the credit card start tariff is 0.50 euro, but when using a debit card it is only 0.25 euro.

Such a tariff cannot be modeled with OCPI. +
But by modeling it as 0.50 euro start tariff where debit card users are given a discount in the final CDR of 0.25 euro, nobody is likely to complain.
The `tariff_alt_text` explains this clearly.

[source,json]
----
include::examples/tariff_11_not_possible_alt_text.json[]
----


[[mod_tariffs_simple_tariff_example_with_alternative_url]]
====== Simple Tariff example with alternative URL

This examples shows the use of `tariff_alt_url`.

This examples shows a `PROFILE_CHEAP` tariff, which is a smart charging tariff.
Drivers are able to select this tariff by setting the `profile_type` in their
<<mod_sessions_set_charging_preferences,Charging Preferences>> to `CHEAP`.
In such case, the price might not be fixed, but depend on the real-time energy prices.
To explain this to the driver, a short text inside `tariff_alt_text` might not be the best solution.
Showing a graph could be better.
Therefore it is also possible to provide an URL in `tariff_alt_url` to a site that explains
the tariff better and in more detail.

* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 0.1 kWh (100 Wh)

For a charging session where 20.45 kWh are charged:
this tariff will result in:

* Start fee: 0.50 euro (excl. VAT), 0.60 euro (incl. VAT)
* Energy costs: 5.13 euro (excl. VAT), 5.64 euro (incl. VAT)
* Total: 5.63 euro (excl. VAT), 6.24 euro (incl. VAT)

if the announced prices were billed.
Because the energy is billed per 0.1 kWh, the driver has to pay for 20.5 kWh even though
they only charged 20.45 kWh.
Total cost of this session including the transaction fee:

The twist here is that this tariff makes use of `tariff_alt_url` which links to a page
with real-time energy prices of the operator, where is shown that the actual price per kWh is different.
With an assumed current energy price of 0.22 euro per kWh (excl. VAT), which is shown or explained on
the page linked by `tariff_alt_url`, the resulting costs:

* Start fee: 0.50 euro (excl. VAT), 0.60 euro (incl. VAT)
* Energy costs: 4.51 euro (excl. VAT), 4.96 (incl. VAT)
* Total: 5.01 euro (excl. VAT), 5.56 euro (incl. VAT)


[source,json]
----
include::examples/tariff_3_alt_url.json[]
----


[[mod_tariffs_complex_tariff_example]]
====== Complex Tariff example

* Start or transaction fee
[disc]
** 2.50 euro (excl. VAT)
** 15% VAT
* Charging Time
[disc]
** When charging with less than 32A
[disc]
*** 1.00 euro per hour (excl. VAT)
*** 20% VAT
*** Billed per 15 min (900 seconds)
** When charging with more than 32A on weekdays
[disc]
*** 2.00 euro per hour (excl. VAT)
*** 20% VAT
*** Billed per 10 min (600 seconds)
** When charging with more than 32A on weekends
[disc]
*** 1.25 euro per hour (excl. VAT)
*** 20% VAT
*** Billed per 10 min (600 seconds)
* Parking
[disc]
** On weekdays between 09:00 and 18:00
[disc]
*** 5 euro per hour (excl. VAT)
*** 10% VAT
*** Billed per 5 min (300 seconds)
** On Saturday between 10:00 and 17:00
[disc]
*** 6 euro per hour (excl. VAT)
*** 10% VAT
*** Billed per 5 min (300 seconds)

For a charging session on a Monday morning starting at 09:30 which takes 2:45 hours (165 minutes),
where the driver uses a maximum of 16A of power and is parking for additional 42 minutes afterwards,
this tariff will result in costs of 9.00 euro (excl. VAT) or 10.30 euro (incl. VAT)
for a total session time of 147 minutes (charging) + 42 minutes (parking).
As the tariff switches from a `TIME` based tariff to `PARKING_TIME`, `step_size` is not used on the charging time, only on the parking time.
The driver has to pay for 165 minutes charging (2.75 euro excl. VAT) and 45 minutes of parking as its billed per 5 minutes (3.75 euro excl. VAT).

For a charging session on a Saturday afternoon starting at 13:30 which takes 1:54 hours,
where the driver uses a minimum of 43A of power (all the time, which is only theoretically possible) and is parking for additional 71 minutes afterwards,
this tariff will result in a total cost of 12.375 euro (excl. VAT) or 13.975 euro (incl. VAT).
Total charging time of 114 minutes (2.375 euro excl. VAT) + 71 minutes (parking) due to `step_size`: 75 minutes (7.50 euro excl VAT).


[source,json]
----
include::examples/tariff_4_complex.json[]
----


[[mod_tariffs_free_of_charge_tariff_example]]
====== Free of Charge Tariff example
In this example no VAT is given because it is not necessary (as the `price` is `0.00`).
This might not always be the case though and it is of course permitted to add a VAT,
even if the `price` is set to zero.

[source,json]
----
include::examples/tariff_5_free_of_charge.json[]
----


[[mod_tariffs_first_hour_free_energy]]
====== First hour free energy example

In this example, we have the following scenario:

* The first hour of parking time is free.
* From the second to the fourth hour, parking costs 2.00 euro per hour
* From the fourth hour on, parking costs 3.00 euro per hour.
* The first kWh of energy is free, every additional kWh costs 0.20 euro.

Translated into our tariff schema, the pricing model looks like this:

* Energy
[disc]
** First kWh: free
** Any additional energy
[disc]
*** 0.20 euro per kWh (excl. VAT)
*** Billed per 1 Wh
* Parking
[disc]
** First hour of parking: free
** Second to fourth hours of parking
[disc]
*** 2.00 euro per hour (excl. VAT)
*** Billed per 1 min (60 seconds)
** Any parking after four hours
[disc]
*** 3.00 euro per hour (excl. VAT)
*** Billed per 1 min (60 seconds)

For a charging session where the driver charges 20 kWh and where the vehicle is parked for 2:45 more hours after charging ended,
this tariff will result in costs of 7.30 euro (excl. VAT).

Cost breakdown:

* Energy: 19 kWh (first kWh is free) = 3.80 euro.
* Parking: 2:45 hours = 1:45 hours of paid parking (105 minutes) = 3.50 euro

As no VAT information is given, it is not possible to calculate total costs including VAT.

[source,json]
----
include::examples/tariff_7_first_hour_kwh_free.json[]
----


[[mod_tariffs_tariff_example_15_reservation_5_euro_per_hour]]
====== Tariff example with reservation price

* Reservation
[disc]
** 5.00 euro per hour (excl. VAT)
** 20% VAT
** Billed per 1 min (60 seconds)
* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

For a charging session that was started 15 minutes after the reservation time, where the driver charges 20 kWh,
this tariff will result in costs of 6.75 euro (excl. VAT) or 7.60 euro (incl. VAT).

Cost breakdown:

* Start fee: 0.50 euro excl VAT, 0.60 incl. VAT.
* Energy: 20 kWh = 5.00 euro excl. VAT, 5.50 euro incl. VAT.
* Reservation: 0:15 hours (15 minutes) = 1.25 euro excl. VAT, 1.50 euro incl. VAT.


[source,json]
----
include::examples/tariff_15_reservation_5_euro_per_hour.json[]
----


[[mod_tariffs_tariff_example_16_reservation_2_euro_fee_5_euro_per_hour]]
====== Tariff example with reservation price and fee

* Reservation
[disc]
** 2.00 euro reservation fee (excl. VAT)
** 5.00 euro per hour (excl. VAT)
** 20% VAT
** Billed per 5 min (300 seconds)
* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

For a charging session that was started 13 minutes after the reservation time, where the driver charges 20 kWh,
this tariff will result in costs of 8.75 euro (excl. VAT) or 10.00 euro (incl. VAT).
Because the reservation fee is billed per 5 minutes, the driver has to pay for 15 minutes of reservation even though
they started the charging session 13 minutes after the reservation time.

Cost breakdown:

* Start fee: 0.50 euro excl VAT, 0.60 incl. VAT.
* Energy: 20 kWh = 5.00 euro excl. VAT, 5.50 euro incl. VAT.
* Reservation fee: 2.00 euro excl VAT, 2.00 incl. VAT.
* Reservation: 0:15 hours (15 minutes) = 1.25 euro excl. VAT, 1.50 euro incl. VAT.


[source,json]
----
include::examples/tariff_16_reservation_2_euro_fee_5_euro_per_hour.json[]
----


[[mod_tariffs_tariff_example_17_reservation_with_expire_fee]]
====== Tariff example with reservation price and expire fee

* Reservation
[disc]
** 4.00 euro reservation expiration fee (excl. VAT) (_billed when a reservation expires and is not followed by a charging session_)
** 2.00 euro per hour (excl. VAT)
** 20% VAT
** Billed per 10 min (600 seconds)
* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

This example is very similar to <<mod_tariffs_tariff_example_15_reservation_5_euro_per_hour,Tariff example with reservation price>>
with the difference that expired reservations cost something and that reservation time is billed per 10 minutes.
Also, the price for reservation is different.

For a charging session that was started 22 minutes after the reservation time, where the driver charges 20 kWh,
this tariff will result in costs of 6.50 euro (excl. VAT) or 7.30 euro (incl. VAT).
Because the reservation fee is billed per 10 minutes, the driver has to pay for 30 minutes of reservation even though
they started the charging session 22 minutes after the reservation time.

If the driver did not start a charging session and the reservation expired after the reserved time of 1 hour,
the tariff would have resulted in costs of 6.00 euro (excl. VAT) or 7.20 euro (incl. VAT).
In case a reservation is not used, the driver has to pay the full amount of reserved time
as well as an additional expiration fee as compensation for not charging at all.


[source,json]
----
include::examples/tariff_17_reservation_with_expire_fee.json[]
----


[[mod_tariffs_tariff_example_18_reservation_with_expire_time]]
====== Tariff example with reservation time and expire time

* Reservation
[disc]
** 3.00 euro per hour (excl. VAT)
** 6.00 euro per hour (excl. VAT) (_billed when a reservation expires and is not followed by a charging session_)
** 20% VAT
** Billed per 10 min (600 seconds)
* Start or transaction fee
[disc]
** 0.50 euro (excl. VAT)
** 20% VAT
* Energy
[disc]
** 0.25 euro per kWh (excl. VAT)
** 10% VAT
** Billed per 1 Wh

This example is very similar to <<mod_tariffs_tariff_example_15_reservation_5_euro_per_hour,Tariff example with reservation price>>
with the difference that expired reservations cost something and that reservation time is billed per 10 minutes.
Also, the price for reservation is different.

For a charging session that was started 22 minutes after the reservation time, where the driver charges 20 kWh,
this tariff will result in costs of 7.00 euro (excl. VAT) or 7.90 euro (incl. VAT).
Because the reservation fee is billed per 10 minutes, the driver has to pay for 30 minutes of reservation even though
they started the charging session 22 minutes after the reservation time.

If the driver did not start a charging session and the reservation expired after the reserved time of 1.5 hours,
the tariff would have resulted in costs of 9.00 euro (excl. VAT) or 10.80 euro (incl. VAT).
In case a reservation is not used, the driver has to pay the expiration fee as compensation for not charging at all.

[source,json]
----
include::examples/tariff_18_reservation_with_expire_time.json[]
----


[[mod_tariffs_data_types]]
=== Data types

[[mod_tariffs_dayofweek_enum]]
==== DayOfWeek _enum_

[cols="3,10",options="header"]
|===
|Value |Description 

|MONDAY |Monday 
|TUESDAY |Tuesday 
|WEDNESDAY |Wednesday 
|THURSDAY |Thursday 
|FRIDAY |Friday 
|SATURDAY |Saturday 
|SUNDAY |Sunday 
|===

[[mod_tariffs_pricecomponent_class]]
==== PriceComponent _class_

[cols="3,4,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|type |<<mod_tariffs_tariffdimensiontype_enum,TariffDimensionType>> |1 |Type of tariff dimension.
|price |<<types_number_type,number>> |1 |Price per unit (excl. VAT) for this tariff dimension.
|vat |<<types_number_type,number>> |? |Applicable VAT percentage for this tariff dimension. If omitted, no VAT is applicable. Not providing a VAT is different from 0% VAT, which would be a value of 0.0 here.
|step_size |int |1 |Minimum amount to be billed. This unit will be billed in this `step_size` blocks. Amounts that are less then this `step_size` are rounded up to the given `step_size`.
For example: if `type` is `TIME` and `step_size` has a value of `300`, then time will be billed in blocks of 5 minutes. If 6 minutes were used, 10 minutes (2 blocks of `step_size`) will be billed.
|===

NOTE: `step_size`: depends on the `type` and every `type` (except `FLAT`) defines a `step_size` multiplier, which is the size of every _step_ for that `type` in the given unit. +
 +
For example: `PARKING_TIME` has the `step_size` multiplier: _1 second_, which means that the `step_size` of a `PriceComponent` is multiplied by _1 second_.
Thus a `step_size = 300` means `300 seconds` (`5 minutes`). This means that when someone parked for 8 minutes they will be billed for 10 minutes.
The parking time will be simply rounded up to the next larger chunk of `step_size` (i.e. blocks of `300 seconds` in this example). +
 +
Another example: `ENERGY` has the `step_size` multiplied: _1 Wh_, which means that the `step_size` of a `PriceComponent` is multiplied by _1 Wh_.
Thus a `step_size = 1` with a `price = 0.25` will result in a cost calculation that uses the charged Wh as precision. +
If someone charges their EV with 115.2 Wh, then they are billed for 116 Wh, resulting in total cost of 0.029 euro. +
When `step_size = 25`, then the same amount would be billed for 101 to 125 Wh: 0.031 euro. +
When `step_size = 500`, then the same amount will be billed for 1 to 500 Wh: 0.125 euro.

NOTE: For more information about how `step_size` impacts the calculation of the cost of charging see: <<mod_cdrs_step_size,CDR object description>>

NOTE: Take into account that using `step_size` can be confusing for customers/drivers.
There may be local or national regulations that define max `step_size`.
E.g. in The Netherlands telecom companies are required to at least offer one subscription which is paid per second.
To prevent confusion by the customer, we recommend to keep the `step_size` as small as possible and mention them clearly in your offering.

===== Example Tariff
Example Tariff to explain the `step_size` when switching from one <<mod_tariffs_tariffelement_class,`TariffElement`>> to another:

- Charging fee of 1.20 euro per hour (excl. VAT) before 17:00 with a `step_size` of 30 minutes (1800 seconds)
- Charging fee of 2.40 euro per hour (excl. VAT) after 17:00 with a `step_size` of 15 minutes (900 seconds)
- Parking fee of 1.00 euro per hour (excl. VAT) before 20:00 with a `step_size` of 15 minutes (900 seconds)

[source,json]
----
include::examples/tariff_14_step_size.json[]
----

====== Example: switching to different Tariff Element #1

An EV driver plugs in at 16:55 and charges for 10 minutes (`TIME`).
They then stop charging but stay plugged in for 2 more minutes (`PARKING_TIME`).
The total session time is therefore 12 minutes, resulting in the following costs:

- 5 billable minutes of charging time before 17:00, generating costs of 0.10 euro.
- 5 billable minutes of charging time after 17:00, generating costs of 0.20 euro.
  (`step_size` is not taken into account as we are switching to another time based Tariff Element).
- 5 billable minutes of parking time (due to the `step_size`, total duration of 12 minutes is rounded to 15 minutes), generating costs of 0.083 euro.
- The total for this charging session is therefore *0.383 euro* (excl. VAT).


====== Example: switching to different Tariff Element #2

An EV driver plugs in at 16:35 and charges for 35 minutes (`TIME`).
After that they immediately unplug, leaving with a total session time of 35 minutes and a bill over the following costs:

- 25 billable minutes of charging time before 17:00, generating costs of 0.50 euro.
- 20 billable minutes of charging time after 17:00, generating costs of 0.80 euro.
    As the Price Component of the last Tariff Element being used has a `step_size` of 15 minutes,
    the total duration is rounded to up to 45 minutes.
    When considering the already billed 25 minutes of charging time before 17:00,
    we are left with 20 minutes to bill after 17:00.
- The total for this charging session is therefore *1.30 euro* (excl. VAT).


====== Example: switching to Free-of-Charge Tariff Element

When parking becomes free after 20:00, the new <<mod_tariffs_tariffelement_class,`TariffElement`>> after 20:00 will not contain a
<<mod_tariffs_tariffdimensiontype_enum,`PARKING_TIME`>> (or <<mod_tariffs_tariffdimensiontype_enum,`TIME`>>) <<mod_tariffs_pricecomponent_class,`PriceComponent`>>.
So the last parking period that needs to be paid, which is before 20:00, will be billed according to the `step_size`
of the <<mod_tariffs_tariffdimensiontype_enum,`PARKING_TIME`>> <<mod_tariffs_pricecomponent_class,`PriceComponent`>> before 20:00.

An EV driver plugs in at 19:40 and charges for 12 minutes (`TIME`).
They then stop charging but stay plugged in for 20 more minutes (`PARKING_TIME`).
The total session time is therefore 12 minutes, resulting in the following costs:

- 12 billable minutes of charging time, generating costs of 0.48 euro.
- 18 billable minutes of parking time, generating costs of 0.30 euro.
    As the Price Component of the last Tariff Element being used has a `step_size` of 15 minutes,
    we bill a total duration of 30 minutes.
    When considering the already billed 12 minutes of charging time,
    we are left with 18 minutes of parking time to bill. The fact that parking is free after 20:00 has no impact on `step_size`
- The total for this charging session is therefore *0.78 euro* (excl. VAT).


[[mod_tariffs_reservation_restriction_type]]
==== ReservationRestrictionType _enum_

[cols="3,10",options="header"]
|===
|Value |Description
|RESERVATION |Used in TariffElements to describe costs for a reservation.
|RESERVATION_EXPIRES |Used in TariffElements to describe costs for a reservation that expires (i.e. driver does not start a charging session before <<mod_commands_reservenow_object,expiry_date>> of the reservation).
|===

NOTE: When a Tariff has both, `RESERVATION` and `RESERVATION_EXPIRES` TariffElements,
where both TariffElements have a <<mod_tariffs_tariffdimensiontype_enum,TIME>> PriceComponent,
then the time based cost of an expired reservation will be calculated based on the `RESERVATION_EXPIRES` TariffElement.

[[mod_tariffs_tariffelement_class]]
==== TariffElement _class_

[cols="3,4,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|price_components |<<mod_tariffs_pricecomponent_class,PriceComponent>> |+ |List of price components that describe the pricing of a tariff.
|restrictions |<<mod_tariffs_tariffrestrictions_class,TariffRestrictions>> |? |Restrictions that describe the applicability of a tariff.
|===

[[mod_tariffs_tariffdimensiontype_enum]]
==== TariffDimensionType _enum_

[cols="3,10",options="header"]
|===
|Value |Description 

|ENERGY |Defined in kWh, `step_size` multiplier: 1 Wh 
|FLAT |Flat fee without unit for `step_size`
|PARKING_TIME |Time not charging: defined in hours, `step_size` multiplier: 1 second 
|TIME |Time charging: defined in hours, `step_size` multiplier: 1 second +
Can also be used in combination with a <<mod_tariffs_tariffrestrictions_class,RESERVATION>> restriction to describe the price of the reservation time.
|===


[[mod_tariffs_tariffrestrictions_class]]
==== TariffRestrictions _class_

These restrictions are not for the entire Charging Session. They only describe if and when a TariffElement becomes active or inactive during a Charging Session.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|start_time |<<types_string_type,string>>(5) |? |Start time of day in local time, the time zone is defined in the `time_zone` field of the
                                                                <<mod_locations_location_object,Location>>, for example 13:30,
                                                                valid from this time of the day. Must be in 24h format with leading zeros. Hour/Minute separator: ":" Regex: `([0-1][0-9]\|2[0-3]):[0-5][0-9]`
|end_time |<<types_string_type,string>>(5) |? |End time of day in local time, the time zone is defined in the `time_zone` field of the
                                                              <<mod_locations_location_object,Location>>, for example 19:45,
                                                              valid until this time of the day. Same syntax as `start_time`.
                                                              If end_time < start_time then the period wraps around to the next day.
                                                              To stop at end of the day use: 00:00.
|start_date |<<types_string_type,string>>(10) |? |Start date in local time, the time zone is defined in the `time_zone` field of the
                                                                 <<mod_locations_location_object,Location>>, for example: 2015-12-24,
                                                                 valid from this day (inclusive). Regex: `([12][0-9]{3})-(0[1-9]\|1[0-2])-(0[1-9]\|[12][0-9]\|3[01])`
|end_date |<<types_string_type,string>>(10) |? |End date in local time, the time zone is defined in the `time_zone` field of the
                                                               <<mod_locations_location_object,Location>>, for example: 2015-12-27,
                                                               valid until this day (exclusive). Same syntax as `start_date`.
|min_kwh |<<types_number_type,number>> |? |Minimum consumed energy in kWh, for example 20, valid from this amount of energy (inclusive) being used.
|max_kwh |<<types_number_type,number>> |? |Maximum consumed energy in kWh, for example 50, valid until this amount of energy (exclusive) being used.
|min_current |<<types_number_type,number>> |? |Sum of the minimum current (in Amperes) over all phases, for example 5.
      When the EV is charging with more than, or equal to, the defined amount of current, this TariffElement is/becomes active.
      If the charging current is or becomes lower, this TariffElement is not or no longer valid and becomes inactive.
      This describes NOT the minimum current over the entire Charging Session.
      This restriction can make a TariffElement become active when the charging current is above the defined value,
      but the TariffElement MUST no longer be active when the charging current drops below the defined value.
|max_current |<<types_number_type,number>> |? |Sum of the maximum current (in Amperes) over all phases, for example 20.
      When the EV is charging with less than the defined amount of current, this TariffElement becomes/is active.
      If the charging current is or becomes higher, this TariffElement is not or no longer valid and becomes inactive.
      This describes NOT the maximum current over the entire Charging Session.
      This restriction can make a TariffElement become active when the charging current is below this value,
      but the TariffElement MUST no longer be active when the charging current raises above the defined value.
|min_power |<<types_number_type,number>> |? |Minimum power in kW, for example 5.
      When the EV is charging with more than, or equal to, the defined amount of power, this TariffElement is/becomes active.
      If the charging power is or becomes lower, this TariffElement is not or no longer valid and becomes inactive.
      This describes NOT the minimum power over the entire Charging Session.
      This restriction can make a TariffElement become active when the charging power is above this value,
      but the TariffElement MUST no longer be active when the charging power drops below the defined value.
|max_power |<<types_number_type,number>> |? |Maximum power in kW, for example 20.
      When the EV is charging with less than the defined amount of power, this TariffElement becomes/is active.
      If the charging power is or becomes higher, this TariffElement is not or no longer valid and becomes inactive.
      This describes NOT the maximum power over the entire Charging Session.
      This restriction can make a TariffElement become active when the charging power is below this value,
      but the TariffElement MUST no longer be active when the charging power raises above the defined value.
|min_duration |int |? |Minimum duration in seconds the Charging Session MUST last (inclusive).
      When the duration of a Charging Session is longer than the defined value, this TariffElement is or becomes active.
      Before that moment, this TariffElement is not yet active.
|max_duration |int |? |Maximum duration in seconds the Charging Session MUST last (exclusive).
      When the duration of a Charging Session is shorter than the defined value, this TariffElement is or becomes active.
      After that moment, this TariffElement is no longer active.
|day_of_week |<<mod_tariffs_dayofweek_enum,DayOfWeek>> |* |Which day(s) of the week this TariffElement is active.
|reservation |<<mod_tariffs_reservation_restriction_type,ReservationRestrictionType>> |? |When this field is present, the TariffElement describes reservation costs.
A reservation starts when the reservation is made, and ends when the driver starts charging on the reserved EVSE/Location, or when the reservation expires.
A reservation can only have: <<mod_tariffs_tariffdimensiontype_enum,FLAT>> and <<mod_tariffs_tariffdimensiontype_enum,TIME>> TariffDimensions, where `TIME` is for the duration of the reservation.
|===


===== Example: Tariff with max_power Tariff Restrictions

Example Tariff to explain the `max_power` Tariff Restriction:

- Charging fee of 0.20 euro per kWh (excl. VAT) when charging with a power of less than 16 kW.
- Charging fee of 0.35 euro per kWh (excl. VAT) when charging with a power between 16 and 32 kW.
- Charging fee of 0.50 euro per kWh (excl. VAT) when charging with a power above 32 kW (implemented as fallback tariff without Restriction).

For a charging session where the EV charges the first kWh with a power of 6 kW,
increases the power to 48 kW for the next 40 kWh and reduces it again to 4 kW after that for another 0.5 kWh
(probably due to physical limitations, i.e. temperature of the battery),
this tariff will result in costs of 20.30 euro (excl. VAT). The costs are composed of the following components:

- 1 kWh at 6 kW: 0.20 euro
- 40 kWh at 48 kW: 20.00 euro
- 0.5 kWh at 4 kW: 0.10 euro

[source,json]
----
include::examples/tariffrestriction_example_max_power.json[]
----


===== Example: Tariff with max_duration Tariff Restrictions

A supermarket wants to allow their customer to charge for free.
As most customers will be out of the store in 20 minutes, they allow free charging for 30 minutes.
If a customer charges longer than that, they will charge them the normal price per kWh.
But as they want to discourage long usage of their Charge Points, charging becomes much more expensive after 1 hour:

- First 30 minutes of charging is free.
- Charging fee of 0.25 euro per kWh (excl. VAT) after 30 minutes.
- Charging fee of 0.40 euro per kWh (excl. VAT) after 60 minutes.

For a charging session with a duration of 40 minutes where 5 kWh are charged during the first 30 minutes
and another 1.2 kWh in the remaining 10 minutes of the session,
this tariff will result in costs of 0.30 euro (excl. VAT). The costs are composed of the following components:

- 5 kWh for free: 0.00 euro
- 1.2 kWh at 0.25/kWh: 0.30 euro

[source,json]
----
include::examples/tariffrestriction_example_max_duration.json[]
----


[[mod_tariffs_tariff_type]]
==== TariffType _enum_

[cols="3,10",options="header"]
|===
|Value |Description

|AD_HOC_PAYMENT |Used to describe that a Tariff is valid when ad-hoc payment is used at the Charge Point (for example: Debit or Credit card payment terminal).
|PROFILE_CHEAP |Used to describe that a Tariff is valid when <<mod_sessions_set_charging_preferences,Charging Preference>>: <<mod_sessions_profile_type_enum,CHEAP>> is set for the session.
|PROFILE_FAST |Used to describe that a Tariff is valid when <<mod_sessions_set_charging_preferences,Charging Preference>>: <<mod_sessions_profile_type_enum,FAST>> is set for the session.
|PROFILE_GREEN |Used to describe that a Tariff is valid when <<mod_sessions_set_charging_preferences,Charging Preference>>: <<mod_sessions_profile_type_enum,GREEN>> is set for the session.
|REGULAR |Used to describe that a Tariff is valid when using an RFID, without any Charging Preference, or when <<mod_sessions_set_charging_preferences,Charging Preference>>: <<mod_sessions_profile_type_enum,REGULAR>> is set for the session.
|===


<<<

:numbered:
[[mod_tokens_tokens_module]]
== _Tokens_ module

*Module Identifier: `tokens`*

*Data owner: `MSP`*

*Type:* Functional Module

The tokens module gives CPOs knowledge of the token information of an eMSP.
eMSPs can push Token information to CPOs, CPOs can build a cache of known Tokens.
When a request to authorize comes from a Charge Point, the CPO can check against this cache.
With this cached information they know to which eMSP they can later send a CDR. 

[[mod_tokens_flow_and_lifecycle]]
=== Flow and Lifecycle

[[mod_tokens_push_model]]
==== Push model

When the eMSP creates a new Token object they push it to the CPO by calling <<mod_tokens_put_method,PUT>> on the CPO's Tokens endpoint with the newly created Token object.

Any changes to Token in the eMSP system are sent to the CPO system by calling either the <<mod_tokens_put_method,PUT>> or the <<mod_tokens_patch_method,PATCH>> on the CPO's Tokens endpoint with the updated Token(s).

When the eMSP invalidates a Token (deleting is not possible), the eMSP will send the updated Token (with the field: valid set to `false`, by calling, either the <<mod_tokens_put_method,PUT>> or the <<mod_tokens_patch_method,PATCH>> on the CPO's Tokens endpoint with the updated Token. 

When the eMSP is not sure about the state or existence of a Token object in the CPO system, the
eMSP can call the <<mod_tokens_cpo_get_method,GET>> to validate the Token object in the CPO system. 

[[mod_tokens_pull_model]]
==== Pull model

When a CPO is not sure about the state of the list of known Tokens, or wants to request the full
list as a start-up of their system, the CPO can call the <<mod_tokens_msp_get_method,GET>> on the eMSP's Token endpoint to receive
all Tokens, updating already known Tokens and adding new received Tokens to it own list of Tokens.
This is not intended for real-time operation, requesting the full list of tokens for every authorization will put to much strain on systems.
It is intended for getting in-sync with the server, or to get a list of all tokens (from a server without Push mode) every X hours.

[[mod_tokens_real-time_authorization]]
==== Real-time authorization

An eMSP might want their Tokens to be authorized 'real-time', not white-listed.
For this the eMSP has to implement the <<mod_tokens_post_method,POST Authorize request>>
and set the Token.whitelist field to `NEVER` for Tokens they want to have authorized 'real-time'.

If an eMSP doesn't want real-time authorization, the <<mod_tokens_post_method,POST Authorize request>> doesn't
have to be implemented as long as all their Tokens have Token.whitelist set to `ALWAYS`.

When an eMSP does not want to Push the full list of tokens to CPOs,
the CPOs will need to call the <<mod_tokens_post_method,POST Authorize request>> to check if a Token is known by the eMSP, and if it is valid.

NOTE: Doing real-time authorization of RFID will mean a longer delay of the authorization process, which might result in bad user experience at the Charge Point.
So care should be taken to keep delays in processing the request to an absolute minimum.

NOTE: Real-time authorization might be asked for a charging location that is not published via the <<mod_locations_locations_module,Location>> module,
typically a private charger. In most cases this is expected to result in: `ALLOWED`.

NOTE: If real-time authorization is asked for a location, the eMSP SHALL NOT validate that charging is possible based on information like opening hours or EVSE status etc,
this information might not be update to date.


[[mod_tokens_interfaces_and_endpoints]]
=== Interfaces and endpoints

There is both a Sender and a Receiver interface for Tokens. It is advised to use the Push direction from Sender to Receiver during normal operation.
The Sender interface is meant to be used when the Receiver is not 100% sure the Token cache is still correct.

[[mod_tokens_cpo_interface]]
==== Receiver Interface

Typically implemented by market roles like: CPO.

With this interface the Sender can push the Token information to the Receiver.
Tokens is a <<transport_and_format_client_owned_object_push,Client Owned Object>>, so the end-points need to contain the required extra fields: {<<credentials_credentials_object,party_id>>} and {<<credentials_credentials_object,country_code>>}.

Endpoint structure definition:

`{token_endpoint_url}{country_code}/{party_id}/{token_uid}[?type={type}]`

Example:

`+https://www.server.com/ocpi/cpo/2.2/tokens/NL/TNM/012345678+`


[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_tokens_cpo_get_method,GET>> |Retrieve a Token as it is stored in the CPO system. 
|POST |n/a 
|<<mod_tokens_put_method,PUT>> |Push new/updated Token object to the CPO. 
|<<mod_tokens_patch_method,PATCH>> |Notify the CPO of partial updates to a Token. 
|DELETE |n/a, (Use <<mod_tokens_put_method,PUT>>, Tokens cannot be removed). 
|===

[[mod_tokens_cpo_get_method]]
===== *GET* Method

If the eMSP wants to check the status of a Token in the CPO system it might GET the object from the CPO system for validation purposes. The eMSP is the owner of the objects, so it would be illogical if the CPO system had a different status or was missing an object.

[[mod_tokens_cpo_get_request_parameters]]
====== Request Parameters

The following parameters: `country_code`, `party_id`, `token_uid` have to be provided as URL segments.

The parameter: `type` may be provided as an URL parameter

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the eMSP requesting this GET from the CPO system.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the eMSP requesting this GET from the CPO system.
|token_uid |<<types_cistring_type,CiString>>(36) |yes |Token.uid of the Token object to retrieve.
|type |<<mod_tokens_tokentype_enum,TokenType>> |no |Token.type of the Token to retrieve. Default if omitted: <<mod_tokens_tokentype_enum,RFID>>
|===

[[mod_tokens_cpo_get_response_data]]
====== Response Data

The response contains the requested object. 

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tokens_token_object,Token>> |1 |The requested Token object. 
|===

[[mod_tokens_put_method]]
===== *PUT* Method

New or updated Token objects are pushed from the eMSP to the CPO. 

[[mod_tokens_put_request_body]]
====== Request Body

In the put request a new or updated Token object is sent.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tokens_token_object,Token>> |1 |New or updated Token object. 
|===

[[mod_tokens_cpo_put_request_parameters]]
====== Request Parameters

The following parameters: `country_code`, `party_id`, `token_uid` have to be provided as URL segments.

The parameter: `type` may be provided as an URL parameter

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the eMSP sending this PUT request to the CPO system. This SHALL be the same value as the `country_code` in the `Token object being pushed.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the eMSP sending this PUT request to the CPO system. This SHALL be the same value as the `party_id` in the Token object being pushed.
|token_uid |<<types_cistring_type,CiString>>(36) |yes |Token.uid of the (new) Token object (to replace).
|type |<<mod_tokens_tokentype_enum,TokenType>> |no |Token.type of the Token of the (new) Token object (to replace). Default if omitted: <<mod_tokens_tokentype_enum,RFID>>
|===

[[mod_tokens_example_put_a_new_token]]
====== Example: put a new Token

[source,json]
----
PUT To URL: https://www.server.com/ocpi/cpo/2.2/tokens/NL/TNM/012345678

include::examples/token_put_example.json[]
----


[[mod_tokens_patch_method]]
===== *PATCH* Method

Same as the <<mod_tokens_put_method,PUT>> method, but only the fields/objects that have to be updated have to be present, other fields/objects that are not specified are considered unchanged.

Any request to the PATCH method SHALL contain the `last_updated` field.

[[mod_tokens_example_invalidate_a_token]]
====== Example: invalidate a Token

[source,json]
----
PATCH To URL: https://www.server.com/ocpi/cpo/2.2/tokens/NL/TNM/012345678

include::examples/token_patch_example.json[]
----

[[mod_tokens_emsp_interface]]
==== Sender Interface

Typically implemented by market roles like: eMSP.

This interface enables the Receiver to request the current list of Tokens, when needed.
Via the POST method it is possible to authorize a single token.

[cols="2,12",options="header"]
|===
|Method |Description 

|<<mod_tokens_msp_get_method,GET>> |Get the list of known Tokens, last updated between the {date_from} and {date_to} (<<transport_and_format_pagination,paginated>>) 
|<<mod_tokens_post_method,POST>> |Real-time authorization request 
|PUT |n/a 
|PATCH |n/a 
|DELETE |n/a 
|===

[[mod_tokens_msp_get_method]]
===== *GET* Method

Fetch information about Tokens known in the eMSP systems.

Endpoint structure definition:

`{tokens_endpoint_url}?[date_from={date_from}]&amp;[date_to={date_to}]&[offset={offset}]&[limit={limit}]`

Examples:

`+https://www.server.com/ocpi/emsp/2.2/tokens/?date_from=2019-01-28T12:00:00&date_to=2019-01-29T12:00:00+`

`+https://ocpi.server.com/2.2/tokens/?offset=50+`

`+https://www.server.com/ocpi/2.2/tokens/?date_from=2019-01-29T12:00:00&limit=100+`

`+https://www.server.com/ocpi/emsp/2.2/tokens/?offset=50&limit=100+`


[[mod_tokens_msp_get_request_parameters]]
====== Request Parameters

If additional parameters: `{date_from}` and/or `{date_to}` are provided, only Tokens with (`last_updated`)
between the given `{date_from}` (including) and `{date_to}` (excluding) will be returned.

This request is <<transport_and_format_pagination,paginated>>, it supports the <<transport_and_format_paginated_request,pagination>> related URL parameters.
This request is <<transport_and_format_pagination,paginated>>, it supports the <<transport_and_format_paginated_request,pagination>> related URL parameters.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|date_from |<<types_datetime_type,DateTime>> |no |Only return Tokens that have `last_updated` after or equal to this Date/Time (inclusive).
|date_to |<<types_datetime_type,DateTime>> |no |Only return Tokens that have `last_updated` up to this Date/Time, but not including (exclusive).
|offset |int |no |The offset of the first object returned. Default is 0. 
|limit |int |no |Maximum number of objects to GET. 
|===

[[mod_tokens_msp_get_response_data]]
====== Response Data

The endpoint response with list of valid Token objects, the header will contain the <<transport_and_format_paginated_response,pagination>> related headers. 

Any older information that is not specified in the response is considered as no longer valid.
Each object must contain all required fields. Fields that are not specified may be considered as null values.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tokens_token_object,Token>> |* |List of all tokens. 
|===

[[mod_tokens_post_method]]
===== *POST* Method

Do a 'real-time' authorization request to the eMSP system, validating if a Token might be used (at the optionally given Location). 

Endpoint structure definition:

`{tokens_endpoint_url}{token_uid}/authorize[?type={type}]`


The `/authorize` is required for the real-time authorize request.

Examples:

`+https://www.server.com/ocpi/emsp/2.2/tokens/012345678/authorize+`

`+https://ocpi.server.com/2.2/tokens/012345678/authorize?type=RFID+`


When the eMSP does not know the Token, the eMSP SHALL respond with an HTTP status code: 404 (Not Found).

When the eMSP receives a 'real-time' authorization request from a CPO that contains too little information (no LocationReferences provided) to determine if the Token might be used, the eMSP SHALL respond with the OCPI status: <<status_codes_2xxx_client_errors,2002>>

[[mod_tokens_msp_post_request_parameters]]
====== Request Parameters

The parameter: `token_uid` has to be provided as URL segments.

The parameter: `type` may be provided as an URL parameter


[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|token_uid |<<types_cistring_type,CiString>>(36) |yes |Token.uid of the Token for which authorization is requested.
|type |<<mod_tokens_tokentype_enum,TokenType>> |no |Token.type of the Token for which this authorization is. Default if omitted: <<mod_tokens_tokentype_enum,RFID>>
|===

[[mod_tokens_post_request_body]]
====== Request Body

In the body an optional <<mod_tokens_locationreferences_class,LocationReferences>> object can be given. The eMSP SHALL then validate if the Token is allowed to be used at this Location, and if applicable: which of the Locations EVSEs.
The object with valid Location and EVSEs will be returned in the response.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tokens_locationreferences_class,LocationReferences>> |? |Location and EVSEs for which the Token is requested to be authorized.
|===

[[mod_tokens_post_response_data]]
====== Response Data

When the token is known by the Sender, the response SHALL contain a <<mod_tokens_authorizationinfo_object,AuthorizationInfo>> object.

If the token is not known, the response SHALL contain the status code: `2004: Unknown Token`, and no `data` field.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description 

|<<mod_tokens_authorizationinfo_object,AuthorizationInfo>> |1 |Contains information about the authorization, if the Token is allowed to charge and optionally which EVSEs are allowed to be used.
|===

[[mod_tokens_object_description]]
=== Object description

[[mod_tokens_authorizationinfo_object]]
==== _AuthorizationInfo_ Object

[cols="4,2,1,9",options="header"]
|===
|Property |Type |Card. |Description 

|allowed |<<mod_tokens_allowed_enum,AllowedType>> |1 |Status of the Token, and whether charging is allowed at the optionally given location.
|token   |<<mod_tokens_token_object,Token>> |1 |The complete Token object for which this authorization was requested.
|location |<<mod_tokens_locationreferences_class,LocationReferences>> |? |Optional reference to the location if it was included in the request, and if the EV driver is allowed to charge at that location. Only the EVSEs the EV driver is allowed to charge at are returned.
|authorization_reference |<<types_cistring_type,CiString>>(36) |? |Reference to the authorization given by the eMSP, when given,
                                             this reference will be provided in the relevant <<mod_sessions_session_object,Session>>
                                             and/or <<mod_cdrs_cdr_object,CDR>>.
|info |<<types_displaytext_class,DisplayText>> |? |Optional display text, additional information to the EV driver.
|===


[[mod_tokens_token_object]]
==== _Token_ Object

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|country_code |<<types_cistring_type,CiString>>(2) |1 |ISO-3166 alpha-2 country code of the MSP that 'owns' this Token.
|party_id |<<types_cistring_type,CiString>>(3) |1 |CPO ID of the MSP that 'owns' this Token (following the ISO-15118 standard).
|uid |<<types_cistring_type,CiString>>(36) |1 |Unique ID by which this Token can be identified. +
                                      This is the field used by CPO system (RFID reader on the Charge Point) to identify this token. +
                                      Currently, in most cases: type=RFID, this is the RFID hidden ID as read by the RFID reader, but that is not a requirement. +
                                      If this is a `APP_USER` or `AD_HOC_USER` Token, it will be a uniquely, by the eMSP, generated ID. +
                                      This field is named `uid` instead of `id` to prevent confusion with: `contract_id`.
|type |<<mod_tokens_tokentype_enum,TokenType>> |1 |Type of the token 
|contract_id |<<types_cistring_type,CiString>>(36) |1 |Uniquely identifies the EV Driver contract token within the eMSP's platform (and suboperator platforms). Recommended to follow the specification for eMA ID from "eMI3 standard version V1.0" (http://emi3group.com/documents-links/[http://emi3group.com/documents-links/]) "Part 2: business objects."
|visual_number |<<types_string_type,string>>(64) |? |Visual readable number/identification as printed on the Token (RFID card), might be equal to the contract_id.
|issuer |<<types_string_type,string>>(64) |1 |Issuing company, most of the times the name of the company printed on the token (RFID card), not necessarily the eMSP.
|group_id |<<types_cistring_type,CiString>>(36) |? |This ID groups a couple of tokens. This can be used to make two or more tokens work as one, so that a session can be started with one token and stopped with another, handy when a card and key-fob are given to the EV-driver. +
Beware that OCPP 1.5/1.6 only support group_ids (it is called parentId in OCPP 1.5/1.6) with a maximum length of 20.
|valid |boolean |1 |Is this Token valid
|whitelist |<<mod_tokens_whitelisttype_enum,WhitelistType>> |1 |Indicates what type of white-listing is allowed. 
|language |<<types_string_type,string>>(2) |? |Language Code ISO 639-1. This optional field indicates the Token owner's preferred interface language. If the language is not provided or not supported then the CPO is free to choose its own language. 
|default_profile_type |<<mod_sessions_profile_type_enum,ProfileType>> |? | The default <<mod_sessions_set_charging_preferences,Charging Preference>>. When this is provided,
                                        and a charging session is started on an Charge Point that support Preference base Smart Charging and support this <<mod_sessions_profile_type_enum,ProfileType>>,
                                        the Charge Point can start using this <<mod_sessions_profile_type_enum,ProfileType>>, without this having to be set via: <<mod_sessions_set_charging_preferences,Set Charging Preferences>>.
|energy_contract |<<mod_tokens_energy_contract,EnergyContract>> |? |When the Charge Point supports using your own energy supplier/contract at a Charge Point, information about the energy supplier/contract is needed so the CPO knows which energy supplier to use.  +
                            NOTE: In a lot of countries it is currently not allowed/possible to use a drivers own energy supplier/contract at a Charge Point.
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this Token was last updated (or created).
|===


The combination of _uid_ and _type_ should be unique for every token within the eMSP's system.

NOTE: OCPP supports group_id (or ParentID as it is called in OCPP 1.5/1.6) OCPP 1.5/1.6 only support group ID's with maximum length of string(20), case insensitive.
As long as EV-driver can be expected to charge at an OCPP 1.5/1.6 Charge Point, it is adviced to not used a group_id longer then 20.

[[mod_tokens_examples]]
===== Examples

====== Simple APP_USER example

[source,json]
----
include::examples/token_example_1_app_user.json[]
----


====== Full RFID example

[source,json]
----
include::examples/token_example_2_full_rfid.json[]
----


[[mod_tokens_data_types]]
=== Data types

[[mod_tokens_allowed_enum]]
==== AllowedType _enum_

[cols="3,10",options="header"]
|===
|Value |Description 

|ALLOWED |This Token is allowed to charge (at this location).
|BLOCKED |This Token is blocked. 
|EXPIRED |This Token has expired. 
|NO_CREDIT |This Token belongs to an account that has not enough credits to charge (at the given location).
|NOT_ALLOWED |Token is valid, but is not allowed to charge at the given location. 
|===


[[mod_tokens_energy_contract]]
==== EnergyContract _class_

Information about a energy contract that belongs to a Token so a driver could use his/her own energy contract when charging at a Charge Point.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|supplier_name |<<types_string_type,string>>(64) |1 | Name of the energy supplier for this token.
|contract_id |<<types_string_type,string>>(64) |? | Contract ID at the energy supplier, that belongs to the owner of this token.
|===


[[mod_tokens_locationreferences_class]]
==== LocationReferences _class_

References to location details.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|location_id |<<types_cistring_type,CiString>>(36) |1 |Unique identifier for the location.
|evse_uids |<<types_cistring_type,CiString>>(36) |* |Unique identifiers for EVSEs within the CPO's platform for the EVSE within the given location.
|===

[[mod_tokens_tokentype_enum]]
==== TokenType _enum_

[cols="3,10",options="header"]
|===
|Value |Description 

|AD_HOC_USER |One time use Token ID generated by a server (or App.) The eMSP uses this to bind a Session to a customer, probably an app user.
|APP_USER |Token ID generated by a server (or App.) to identify a user of an App. The same user uses the same Token for every Session.
|OTHER |Other type of token
|RFID |RFID Token 
|===

NOTE: The eMSP is RECOMMENDED to push Tokens with type: `AD_HOC_USER` or `APP_USER` with `whitelist` set to `NEVER`.
Whitelists are very useful for RFID type Tokens, but the `AD_HOC_USER`/`APP_USER` Tokens are used to start Sessions from an App etc. so whitelisting them has no advantages.

[[mod_tokens_whitelisttype_enum]]
==== WhitelistType _enum_

Defines when authorization of a Token by the CPO is allowed.

The validity of a Token has no influence on this. If a Token is: `valid = false`,
when the `whitelist` field requires real-time authorization, the CPO SHALL do a <<mod_tokens_real-time_authorization,real-time authorization>>,
the state of the Token might have changed.

[cols="3,10",options="header"]
|===
|Value |Description 

|ALWAYS |Token always has to be whitelisted, <<mod_tokens_real-time_authorization,realtime authorization>> is not possible/allowed. CPO shall always allow any use of this Token.
|ALLOWED |It is allowed to whitelist the token, <<mod_tokens_real-time_authorization,realtime authorization>> is also allowed. The CPO may choose which version of authorization to use.
|ALLOWED_OFFLINE |In normal situations <<mod_tokens_real-time_authorization,realtime authorization>> shall be used. But when the CPO cannot get a response from the eMSP (communication between CPO and eMSP is offline), the CPO shall allow this Token to be used.
|NEVER |Whitelisting is forbidden, only <<mod_tokens_real-time_authorization,realtime authorization>> is allowed. CPO shall always send a <<mod_tokens_real-time_authorization,realtime authorization>> for any use of this Token to the eMSP.
|===

<<<

:numbered:
[[mod_commands_commands_module]]
== _Commands_ module

*Module Identifier: `commands`*

*Type:* Functional Module

The Commands module enables remote commands to be sent to a Location/EVSE.
The following commands are supported:

- `RESERVE_NOW`
- `CANCEL_RESERVATION`
- `START_SESSION`
- `STOP_SESSION`
- `UNLOCK_CONNECTOR`

See <<mod_commands_commandtype_enum,CommandType>> for a description of the different commands.
_Use the `UNLOCK_CONNECTOR` command with care, please read the note at <<mod_commands_commandtype_enum,CommandType>>._ 

*Module dependency:* <<mod_locations_locations_module,Locations module>>, <<mod_sessions_sessions_module,Sessions module>>

[[mod_commands_flow]]
=== Flow

With the Commands module, commands can be sent from the eMSP, via the CPO to a Charge Point.
Most Charge Point are hooked up to the internet via a relative slow wireless connection. To prevent long blocking calls,
the commands module is designed to work asynchronously.

The Sender (typically eMSP) send a request to a Receiver (typically CPO), via the Receivers Commands interface.
The Receiver checks if it can send the request to a Charge Point and will respond to the request with a status, indicating if the request can be sent to a Charge Point.

The Receiver (typically CPO) sends the requested command (via another protocol, for example: OCPP) to a Charge Point.
The Charge Point will respond if it understands the command and will try to execute the command.
This response doesn't always mean that the command was executed successfully.
The Receiver (typically CPO) will forward the result in a new POST request to the Senders Commands interface.

The following examples try to give insight into the message flow and the asynchronous nature of the OCPI Commands.

Example of a `START_SESSION` that is accepted, but no new Session is started because EV not plugged in before end of time-out.
This is an example for Charge Point that allows a remote start when the cable is not yet plugged in.
Some Charge Points even require this, there might, for example, be a latch in front of the socket to prevent vandalism.

.START_SESSION failed
image::images/command_start_session_timeout.svg[START_SESSION failed]


Example of a `START_SESSION` that is accepted, but no new Session is started because the EV is not plugged in,
and this Charge Point does not allow a remote start without a cable already being plugged in.

.START_SESSION failed
image::images/command_start_session_no_cable.svg[START_SESSION failed]


Example of a `START_SESSION` that is accepted and results in a new Session.

.START_SESSION successful
image::images/command_start_session_succesful.svg[START_SESSION successful]


Example of a `START_SESSION` with a Token that is Whitelist: NEVER.

The CPO does not check the Token in the START_SESSION. If needed, the Charge Point does an OCPP Authorize request.
In case of a Token whitelist NEVER or ALLOWED_OFFLINE, the CPO does an <<mod_tokens_real-time_authorization,realtime authorization>>.

.START_SESSION whitelist NEVER
image::images/command_start_session_whitelist_never.svg[START_SESSION whitelist NEVER]


Example of a `UNLOCK_CONNECTOR` that fails because the Location is not known by the CPO.

.UNLOCK_CONNECTOR Unknown Location
image::images/command_unlock_unknow_location.svg["UNLOCK_CONNECTOR Unknown Location"]


Example of a `RESERVE_NOW` that is rejected by the Charge Point.

.RESERVE_NOW rejected by Charge Point
image::images/command_reservenow_rejected.svg[RESERVE_NEW rejected by Charge Point]

Example of a successful `RESERVE_NOW`.

.Successful RESERVE_NOW
image::images/command_reservenow_successful.svg[Successful RESERVE_NOW]


Reservation canceled by the CPO. +
OCPI makes it possible for a CPO to cancel a reservation.
This is not to be taken lightly. When a driver makes a reservation of a Charge Point/EVSE, he/she wants to be sure to have a charging location.
So if the CPO cancel the reservation, the driver will for sure not like it.
But there are some circumstances where the CPO is forced to cancel a reservation.
For example: Charge Point has become defect, or the CPO is notified of ongoing roadworks which makes the Charge Point unreachable etc.

To Cancel a reservation the CPO call the Senders interface with the same URL as was given by the Sender (eMSP) when the `RESERVE_NOW` command was send.

The sequence diagram below continues after the sequence diagram above.

.Reservation canceled by the CPO
image::images/command_reservenow_canceled_by_cpo.svg[Reservation canceled by the CPO]

_These examples use OCPP 1.6 based commands between CPO and Charge Point, but that is not a requirement for OCPI.

If the Sender (typically eMSP) wants to have a reference between the calls send to the Receivers interface and the asynchronous result received from the Charge Point via the CPO,
the Sender can make some unique identifier part of the`response_url` that is part of every method in the Receiver interface.
The Receiver will call this URL when the result is received from the Charge Point. The Sender can then match the unique identifier from the URL called with the request.

[[mod_commands_interfaces_and_endpoints]]
=== Interfaces and endpoints

The commands module consists of two interfaces: a Receiver interface that enables a Sender (typically eMSP) (and its clients) to send commands to a Location/EVSE
and an Sender interface to receive the response from the Location/EVSE asynchronously.

[[mod_commands_cpo_interface]]
==== Receiver Interface

Typically implemented by market roles like: CPO.

Endpoint structure definition:

`{commands_endpoint_url}{command}`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/commands/START_SESSION+`

`+https://ocpi.server.com/commands/STOP_SESSION+`

`+https://server.com/ocpi/cpo/2.2/commands/RESERVE_NOW+`

Example endpoint structure: ``

[cols="2,12",options="header"]
|===
|Method |Description 

|GET |n/a 
|<<mod_commands_cpo_post_method,POST>> |Send a command to the CPO, requesting the CPO to send the command to the Charge Point 
|PUT |n/a 
|PATCH |n/a 
|DELETE |n/a 
|===


[[mod_commands_cpo_post_method]]
===== *POST* Method

[[mod_commands_msp_post_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description 

|command |<<mod_commands_commandtype_enum,CommandType>> |yes |Type of command that is requested. 
|===

[[mod_commands_cpo_post_request_body]]
===== Request Body

Depending on the `command` parameter the body SHALL contain the applicable object for that command. 

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description

|_Choice: one of five_ | |
|&gt; <<mod_commands_cancelreservation_object,CancelReservation>> |1 |CancelReservation object, for the `CANCEL_RESERVATION` command, with information needed to cancel an existing reservation.
|&gt; <<mod_commands_reservenow_object,ReserveNow>> |1 |ReserveNow object, for the `RESERVE_NOW` command, with information needed to reserve a (specific) connector of a Charge Point for a given Token.
|&gt; <<mod_commands_startsession_object,StartSession>> |1 |StartSession object, for the `START_SESSION` command, with information needed to start a sessions.
|&gt; <<mod_commands_stopsession_object,StopSession>> |1 |StopSession object, for the `STOP_SESSION` command, with information needed to stop a sessions. 
|&gt; <<mod_commands_unlockconnector_object,UnlockConnector>> |1 |UnlockConnector object, for the `UNLOCK_CONNECTOR` command, with information needed to unlock a connector of a Charge Point. 
|===

[[mod_commands_response_data]]
====== Response Data

The response contains the direct response from the Receiver, not the response from the Charge Point itself,
that will be sent via an asynchronous POST on the Sender interface if this response is `ACCEPTED`.

[cols="4,1,12",options="header"]
|===
|Datatype |Card. |Description 

|<<mod_commands_commandresponse_object,CommandResponse>> |1 |Result of the command request, by the CPO (not the Charge Point). So this indicates if the CPO understood the command request and was able to send it to the Charge Point. This is not the response by the Charge Point 
|===

[[mod_commands_emsp_interface]]
==== Sender Interface

Typically implemented by market roles like: eMSP.

The Sender interface receives the asynchronous responses.

Endpoint structure definition:

No structure defined. This is open to the Sender to define, the URL is provided to the Receiver by the Sender in the POST to the Receiver interface.
Therefor OCPI does not define variables.

Example:

`+https://www.server.com/ocpi/emsp/2.2/commands/{command}+`

`+https://ocpi.server.com/commands/{command}/{uid}+`

[cols="2,12",options="header"]
|===
|Method |Description 

|GET |n/a 
|<<mod_commands_msp_post_method,POST>> |Receive the asynchronous response from the Charge Point. 
|PUT |n/a 
|PATCH |n/a 
|DELETE |n/a 
|===


[[mod_commands_msp_post_method]]
===== *POST* Method

Endpoint structure definition:

It is up to the implementation of the eMSP to determine what parameters are put in the URL.
The eMSP sends a URL in the POST method body to the CPO. The CPO is required to use this URL for the asynchronous response by the Charge Point.
It is advised to make this URL unique for every request to differentiate simultaneous commands, for example by adding a unique id as a URL segment.

Examples:

`+https://www.server.com/ocpi/emsp/2.2/commands/RESERVE_NOW/1234+`

`+https://www.server.com/ocpi/emsp/2.2/commands/UNLOCK_CONNECTOR/2+`

[[mod_commands_msp_post_request_body]]
===== Request Body

[cols="4,1,12",options="header"]
|===
|Datatype |Card. |Description 

|<<mod_commands_commandresult_object,CommandResult>> |1 |Result of the command request, from the Charge Point.
|===


[[mod_commands_object_description]]
=== Object description

[[mod_commands_cancelreservation_object]]
==== _CancelReservation_ Object

With CancelReservation the Sender can request the Cancel of an existing Reservation.
The CancelReservation needs to contain the `reservation_id` that was given by the Sender to the `ReserveNow`.

As there might be cost involved for a Reservation, canceling a reservation might still result in a CDR being send for the reservation.

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|response_url |<<types_url_type,URL>> |1 |URL that the CommandResult POST should be send to. This URL might contain an unique ID to be able to distinguish between CancelReservation requests.
|reservation_id |<<types_cistring_type,CiString>>(36) |1 |Reservation id, unique for this reservation. If the Charge Point already has a reservation that matches this reservationId the Charge Point will replace the reservation.
|===


[[mod_commands_commandresponse_object]]
==== _CommandResponse_ Object

The CommandResponse object is send in the HTTP response body.

Because OCPI does not allow/require retries, it could happen that the asynchronous result url given by the eMSP is never successfully called.
The eMSP might have had a glitch, HTTP 500 returned, was offline for a moment etc.
For the eMSP to be able to give a quick as possible response to another system or driver app. it is important for the eMSP to known the timeout on a certain command.

[cols="2,4,1,10",options="header"]
|===
|Property |Type |Card. |Description

|result |<<mod_commands_commandresponsetype_enum,CommandResponseType>> |1 |Response from the CPO on the command request.
|timeout |int |1 |Timeout for this command in seconds. When the Result is not received within this timeout, the eMSP can assume that the message might never be send.
|message|<<types_displaytext_class,DisplayText>>|*|Human-readable description of the result (if one can be provided), multiple languages can be provided.|
|===


[[mod_commands_commandresult_object]]
==== _CommandResult_ Object

[cols="2,4,1,10",options="header"]
|===
|Property |Type |Card. |Description

|result |<<mod_commands_commandresulttype_enum,CommandResultType>> |1 |Result of the command request as sent by the Charge Point to the CPO.
|message|<<types_displaytext_class,DisplayText>>|*|Human-readable description of the reason (if one can be provided), multiple languages can be provided.|
|===


[[mod_commands_reservenow_object]]
==== _ReserveNow_ Object

The `evse_uid` is optional. If no EVSE is specified, the Charge Point should keep one EVSE available for the EV Driver identified by the given Token. (This might not be supported by all Charge Points).
A reservation can be replaced/updated by sending a `RESERVE_NOW` request with the same Location (Charge Point) and the same `reservation_id`.

A successful reservation will result in a new `Session` object being created by the CPO.

A not used Reservation of a Charge Point/EVSE MAY result in cost being made, thus also a CDR.

The eMSP provides a Token that has to be used by the Charge Point.
The Token provided by the eMSP for the `ReserveNow` SHALL be authorized by the eMSP before sending it to the CPO.
Therefor the CPO SHALL NOT check the validity of the Token provided before sending the request to the Charge Point.

If this is an OCPP Charge Point, the Charge Point decides if it needs to validate the given Token, in such case:

- If this Token is of type: `AD_HOC_USER` or `APP_USER` the CPO SHALL NOT do a <<mod_tokens_real-time_authorization,realtime authorization>> at the eMSP for this .
- If this Token is of type: `RFID`, the CPO SHALL NOT do a <<mod_tokens_real-time_authorization,realtime authorization>>
at the eMSP for this Token at the given EVSE/Charge Point within 15 minutes after having received this `ReserveNow`.

The eMSP MAY use Tokens that have not been pushed via the <<mod_tokens_tokens_module,Token>> module,
especially `AD_HOC_USER` or `APP_USER` Tokens are only used by commands send by an eMSP. As these are never used locally at the Charge Point like `RFID`.

Unknown Tokens received by the CPO in the `ReserveNow` Object don't need to be stored in the <<mod_tokens_tokens_module,Token>> module.
In other words, when a Token has been received via `ReserveNow`, the same `Token` does not have to be returned in a Token GET request from the eMSP.

An eMSP sending a `ReserveNow` SHALL only use Token that are owned by this eMSP in `ReserveNow`, using Tokens of other eMSPs is not allowed.

The `reservation_id` send by the Sender (eMSP) to the Receiver (CPO) SHALL NOT be send directly to a Charge Point.
The CPO SHALL make sure the Reservation ID send to the Charge Point is unique, is not used by another Sender (eMSP).
We don't want a Sender (eMSP) to replace or cancel a reservation of another Sender (eMSP).

[cols="4,2,1,9",options="header"]
|===
|Property |Type |Card. |Description

|response_url |<<types_url_type,URL>> |1 |URL that the CommandResult POST should be send to. This URL might contain an unique ID to be able to distinguish between ReserveNow requests.
|token |<<mod_tokens_token_object,Token>> |1 |Token object for how to reserve this Charge Point (and specific EVSE).
|expiry_date |<<types_datetime_type,DateTime>> |1 |The Date/Time when this reservation ends, in UTC.
|reservation_id |<<types_cistring_type,CiString>>(36) |1 |Reservation id, unique for this reservation. If the Receiver (typically CPO) Point already has a reservation that matches this reservationId for that Location it will replace the reservation.
|location_id |<<types_cistring_type,CiString>>(36) |1 |Location.id of the Location (belonging to the CPO this request is send to) for which to reserve an EVSE.
|evse_uid |<<types_cistring_type,CiString>>(36) |? |Optional EVSE.uid of the EVSE of this Location if a specific EVSE has to be reserved.
|authorization_reference |<<types_cistring_type,CiString>>(36) |? |Reference to the authorization given by the eMSP, when given,
                                             this reference will be provided in the relevant <<mod_sessions_session_object,Session>>
                                             and/or <<mod_cdrs_cdr_object,CDR>>.
|===


[[mod_commands_startsession_object]]
==== _StartSession_ Object

The `evse_uid` is optional. If no EVSE is specified, the Charge Point can itself decide on which EVSE to start a new session. (this might not be supported by all Charge Points).

The eMSP provides a Token that has to be used by the Charge Point.
The Token provided by the eMSP for the `StartSession` SHALL be authorized by the eMSP before sending it to the CPO.
Therefor the CPO SHALL NOT check the validity of the Token provided before sending the request to the Charge Point.

If this is an OCPP Charge Point, the Charge Point decides if it needs to validate the given Token, in such case:

- If this Token is of type: `AD_HOC_USER` or `APP_USER` the CPO SHALL NOT do a <<mod_tokens_real-time_authorization,realtime authorization>>
  at the eMSP for this .
- If this Token is of type: `RFID`, the CPO SHALL NOT do a <<mod_tokens_real-time_authorization,realtime authorization>>
  at the eMSP for this Token at the given EVSE/Charge Point within 15 minutes after having received this `StartSession`.
(This means that if the driver decided to use his RFID within 15 minutes at the same Charge Point, because the app is not working somehow, the RFID is already authorized)

The eMSP MAY use Tokens that have not been pushed via the <<mod_tokens_tokens_module,Token>> module,
especially `AD_HOC_USER` or `APP_USER` Tokens are only used by commands send by an eMSP. As these are never used locally at the Charge Point like `RFID`.

Unknown Tokens received by the CPO in the `StartSession` Object don't need to be stored in the <<mod_tokens_tokens_module,Token>> module.
In other words, when a Token has been received via `StartSession`, the same `Token` does not have to be returned in a Token GET request from the eMSP.
However, the information of the Token SHALL be put in the `Session` and `CDR`.

An eMSP sending a `StartSession` SHALL only use Token that are owned by this eMSP in `StartSession`, using Tokens of other eMSPs is not allowed.

[cols="4,2,1,9",options="header"]
|===
|Property |Type |Card. |Description

|response_url |<<types_url_type,URL>> |1 |URL that the CommandResult POST should be sent to. This URL might contain an unique ID to be able to distinguish between StartSession requests.
|token |<<mod_tokens_token_object,Token>> |1 |Token object the Charge Point has to use to start a new session. The Token provided in this request is authorized by the eMSP.
|location_id |<<types_cistring_type,CiString>>(36) |1 |Location.id of the Location (belonging to the CPO this request is send to) on which a session is to be started.
|evse_uid |<<types_cistring_type,CiString>>(36) |? |Optional EVSE.uid of the EVSE of this Location on which a session is to be started.
|authorization_reference |<<types_cistring_type,CiString>>(36) |? |Reference to the authorization given by the eMSP, when given,
                                             this reference will be provided in the relevant <<mod_sessions_session_object,Session>>
                                             and/or <<mod_cdrs_cdr_object,CDR>>.
|===

NOTE: In case of an OCPP 1.x Charge Point, the EVSE ID should be mapped to the connector ID of a Charge Point.
OCPP 1.x does not have good support for Charge Points that have multiple connectors per EVSE.
To make StartSession over OCPI work, the CPO SHOULD present the different connectors of an EVSE as separate EVSE,
as is also written by the OCA in the application note: "Multiple Connectors per EVSE in a OCPP 1.x implementation".


[[mod_commands_stopsession_object]]
==== _StopSession_ Object

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|response_url |<<types_url_type,URL>> |1 |URL that the CommandResult POST should be sent to. This URL might contain an unique ID to be able to distinguish between StopSession requests.
|session_id |<<types_cistring_type,CiString>>(36) |1 |Session.id of the Session that is requested to be stopped.
|===


[[mod_commands_unlockconnector_object]]
==== _UnlockConnector_ Object

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|response_url |<<types_url_type,URL>> |1 |URL that the CommandResult POST should be sent to. This URL might contain an unique ID to be able to distinguish between UnlockConnector requests.
|location_id |<<types_cistring_type,CiString>>(36) |1 |Location.id of the Location (belonging to the CPO this request is send to) of which it is requested to unlock the connector.
|evse_uid |<<types_cistring_type,CiString>>(36) |1 |EVSE.uid of the EVSE of this Location of which it is requested to unlock the connector.
|connector_id |<<types_cistring_type,CiString>>(36) |1 |Connector.id of the Connector of this Location of which it is requested to unlock.
|===


[[mod_commands_data_types]]
=== Data types

[[mod_commands_commandresponsetype_enum]]
==== CommandResponseType _enum_

Response to the command request from the eMSP to the CPO.

[cols="3,10",options="header"]
|===
|Value |Description 

|NOT_SUPPORTED |The requested command is not supported by this CPO, Charge Point, EVSE etc.
|REJECTED |Command request rejected by the CPO. (Session might not be from a customer of the eMSP that send this request)
|ACCEPTED |Command request accepted by the CPO.
|UNKNOWN_SESSION |The Session in the requested command is not known by this CPO.
|===


[[mod_commands_commandresulttype_enum]]
==== CommandResultType _enum_

Result of the command that was send to the Charge Point.

[cols="4,10",options="header"]
|===
|Value |Description

|ACCEPTED |Command request accepted by the Charge Point.
|CANCELED_RESERVATION |The Reservation has been canceled by the CPO.
|EVSE_OCCUPIED |EVSE is currently occupied, another session is ongoing. Cannot start a new session
|EVSE_INOPERATIVE | EVSE is currently inoperative or faulted.
|FAILED |Execution of the command failed at the Charge Point.
|NOT_SUPPORTED |The requested command is not supported by this Charge Point, EVSE etc.
|REJECTED |Command request rejected by the Charge Point.
|TIMEOUT |Command request timeout, no response received from the Charge Point in a reasonable time.
|UNKNOWN_RESERVATION |The Reservation in the requested command is not known by this Charge Point.
|===


[[mod_commands_commandtype_enum]]
==== CommandType _enum_

The command requested.
[cols="3,10",options="header"]
|===
|Value |Description 

|CANCEL_RESERVATION |Request the Charge Point to cancel a specific reservation.
|RESERVE_NOW |Request the Charge Point to reserve a (specific) EVSE for a Token for a certain time, starting now.
|START_SESSION |Request the Charge Point to start a transaction on the given EVSE/Connector. 
|STOP_SESSION |Request the Charge Point to stop an ongoing session. 
|UNLOCK_CONNECTOR |Request the Charge Point to unlock the connector (if applicable). This functionality is for help desk operators only! 
|===

*The command `UNLOCK_CONNECTOR` may only be used by an operator or the eMSP. This command SHALL never be allowed to be sent directly by the EV-Driver.
The `UNLOCK_CONNECTOR` is intended to be used in the rare situation that the connector is not unlocked successfully after a transaction is stopped. The mechanical unlock of the lock mechanism might get stuck, for example: fail when there is tension on the charging cable when the Charge Point tries to unlock the connector.
In such a situation the EV-Driver can call either the CPO or the eMSP to retry the unlocking.*

<<<

:numbered:
[[mod_charging_profiles_module]]
== _ChargingProfiles_ module

*Module Identifier: `chargingprofiles`*

*Type:* Functional Module

With the ChargingProfiles module, parties (SCSP but also MSPs) can send (Smart) Charging Profiles to a Location/EVSE.
It is also possible to request the 'ActiveChargingProfile' from a Location/EVSE.

The ActiveChargingProfile is the charging profile as calculated by the EVSE.
It is the result of the calculation of all smart charging inputs present in the EVSE, also Local Limits might be taken into account.

The ChargingProfile is similar to the concept of Charging Profiles in OCPP,
but exposes this functionality to third parties.
These objects and the accompanying interfaces make certain abstractions that make them more suitable for energy parties to signal their intent.
The data structures are base on OCPP 1.6 and 2.0 to make conversion of messages between OCPI and OCPP easy.

NOTE: Charging Profiles set via this module are no guarantee that the EV will charge with the exact given limit,
it is a maximum limit, not a target.
A lot of factors influence the charging speed. The EV might not take the amount of energy that the EVSE is willing to provide to it,
the battery might be too warm or almost full. A single phase cable might be used on a three phase Charge Point.
There can be local energy limits (load balancing between EVSEs on a relative small energy connection to a group of EVSEs)
that might limit the energy offered by the EVSE to the EV even further.

ChargingProfile can be created by the owner of a Token on Sessions that belong to that token.
If another party sends a ChargingProfile and the CPO has no contract that allows that party to set profiles on sessions,
the CPO is allowed to reject such profiles.

This module can be used by the eMSP, but can also be used by another party that provide "Smart Charging Services" (Smart Charging Service Provider (SCSP) / Aggregator / Energy Service Broker etc.)
These SCSPs then depend on the CPO sending session information to them. They need to know which session is ongoing to be able to influence it.
If a SCSP uses this module, read eMSP as SCSP.

NOTE: OCPI provides the means for SCSPs to do this.
Parties doing this have to adhere to local privacy laws, have to have setup contracts etc.
Local laws might oblige explicit consent from the driver etc.

*Module dependency:* <<mod_sessions_sessions_module,Sessions module>>


[[mod_charging_profiles_toplogies]]
=== Smart Charging Topologies

There are different Smart Charging Topologies possible. Which topology can be used depends on the contracts between different parties.

NOTE: Care has to be taken to prevent mixing the different topologies.
When multiple parties start sending Charging Profiles, the resulting charging speed might be unpredictable.
In case of OCPP Charge Points, the result will be the minimum of all the Charging Profiles, resulting in a slower than needed charging speed.


[[mod_charging_profiles_toplogies_emsp]]
==== The eMSP generates ChargingProfiles.

The most straight forward topology, the eMSP generates ChargingProfiles for its own customers, no SCSP is involved.
The eMSP 'owns' the customer, so if the eMSP knows that its customer agrees with the eMSP manipulating the charging speed, the eMSP is free to do this.

.Smart Charging Topology: The eMSP generates ChargingProfiles.
image::images/topology_sc_emsp.svg[Smart Charging Topology: The eMSP generates ChargingProfiles]

[cols="1,10",options="header"]
|===
| Interface | Role
| Sender   | eMSP
| Receiver | CPO
|===


[[mod_charging_profiles_toplogies_emsp_scspp]]
==== The eMSP delegated Smart Charging to SCSP.

In the topology, the eMSP has delegated the generation of ChargingProfiles to a SCSP.
For this, the eMSP and SCSP have agreed to use OCPI as the interface.

The eMSP 'owns' the customer, so if the eMSP knows that its customer agrees with the eMSP manipulating the charging speed, the eMSP is free to do this.
The eMSP can forward OCPI <<mod_sessions_session_object,Session>> Objects to the SCSP.
the SCSP can act on the received/updated <<mod_sessions_session_object,Session>> Objects, by sending Charging Profile commands via the eMSP to the CPO.

The eMSP and SCSP have to take into account that they have to oblige to local privacy laws when exchanging information about eMSPs customers.

From the CPO point of view, this topology is similar to the one above, the CPO will not know the difference.

.Smart Charging Topology: The eMSP generates ChargingProfiles.
image::images/topology_scsp_emsp.svg[Smart Charging Topology: The eMSP generates ChargingProfiles]

[cols="3,2,10",options="header"]
|===
| Connection   | Interface | Role
| SCSP - eMSP | Sender   | SCSP
| SCSP - eMSP | Receiver | eMSP
| eMSP - CPO  | Sender   | eMSP
| eMSP - CPO  | Receiver | CPO
|===


[[mod_charging_profiles_toplogies_cpo_scspp]]
==== The CPO delegated Smart Charging to SCSP.

In this topology, the CPO has delegated the generation of ChargingProfiles to a SCSP.
For this, the CPO and SCSP have agreed to use OCPI as the interface.

The CPO 'owns' the EVSE on which charging happens.
As the CPO does not 'own' the customers, the CPO needs to make sure the EV driver knows that the charging speed might not
be the maximum the driver has expected, this could be something as simple as a sticker on the Charge Point,
or might even be part of the tariff text.

The CPO might generate ChargingProfiles themselves, but as OCPI is then not used this is not part of this document.

The CPO can forward OCPI <<mod_sessions_session_object,Session>> Objects to the SCSP.
the SCSP can act on the received/updated <<mod_sessions_session_object,Session>> Objects, by sending Charging Profile commands to the CPO.

The CPO and SCSP have to take into account that they have to oblige to local privacy laws when exchanging information about eMSPs customers.

In this topology, the eMSP is not aware that the CPO is using OCPI to receive Charging Profiles from the SCSP.

.Smart Charging Topology: The eMSP generates ChargingProfiles.
image::images/topology_scsp_cpo.svg[Smart Charging Topology: The eMSP generates ChargingProfiles]

[cols="1,10",options="header"]
|===
| Interface | Role
| Sender   | SCSP
| Receiver | CPO
|===


[[mod_charging_profiles_use_cases]]
=== Use Cases

This module is designed to support the following use cases, for all the above mentioned topologies.

- The eMSP/SCSP sends/updates a ChargingProfile to manipulate an ongoing charging session.
- The eMSP/SCSP request to remove the set ChargingProfile from an ongoing charging session.
- The eMSP/SCSP request the ActiveChargingProfile for an ongoing charging session.
- The CPO updates the eMSP/SCSP of changes to an ActiveChargingProfile.


[[mod_charging_profiles_flow]]
=== Flow

The ChargingProfile creation is a request to activate a charging profile on a running charging session.

Most Charge Points are hooked up to the internet via a relative slow wireless connection. To prevent long blocking calls,
the ChargingProfile module is designed to work asynchronously. (similar to the <<mod_commands_commands_module,`Commands`>> module.

The Sender (Typically SCSP) sends a request to a Receiver (Typically CPO), via the Receiver interface.
The Receiver checks if it can send the request to a Charge Point and will respond to the request with a status, indicating if the request can be sent to a Charge Point.

The Receiver sends the requested command (via another protocol, for example: OCPP) to a Charge Point.
The Charge Point will respond if it understands the command and will try to execute the command.
This response doesn't always mean that the ChargingProfile will be executed.
The CPO will forward the result in a new POST request to the Sender (Typically SCSP) ChargingProfile interface.

The Sender (Typically SCSP) can send the Charging Profile to the EVSE via the CPO by using the <<mod_charging_profiles_cpo_put_method,CPO PUT method>> for an ongoing session.
The Sender can request the current profile the EVSE has calculated, based on different inputs, and is planned to be used for the ongoing session by calling the <<mod_charging_profiles_cpo_get_method,CPO GET method>>.
The Sender has the ability to remove the Charging Profile for the session by calling the <<mod_charging_profiles_cpo_delete_method,CPO DELETE method>>

When the Sender has (at least once) successfully sent a Charging Profile for an ongoing charging session,
the Receiver (Typically CPO) SHALL keep the Sender updated with changes to the ActiveChargingProfile of that Session.
If the Receiver is aware of any changes, he notifies the Sender by calling the <<mod_charging_profiles_msp_put_method,MSP PUT method>>.
The changes might be triggered by the CPO sending additional Charging Profiles, or the some local limit being applied to the Charge Point,
and the Charge Point notifies the CPO of the Changes.

The Receiver can cancel/remove an existing ChargingProfile, it can let the eMSP know by calling the <<mod_charging_profiles_msp_put_method,MSP PUT method>>

For calculating optimum ChargingProfiles it might be useful for the eMSP or SCSP to know the ChargingProfile that the Charge Point has planned for the Session: ActiveChargingProfile.
The ActiveChargingProfile might differ from ChargingProfile requested via OCPI. There might be other limiting factors being taken into account by the CPO and or Charge Point,
that limit the ChargingProfile.
The ActiveChargingProfile profile can be requested by the Sender by calling the <<mod_charging_profiles_cpo_get_method,CPO GET method>> on the Charging Profile Receiver interface.
The CPO will then ask the Charge Point   for the planned ActiveChargingProfile. When that is received it is forwarded to the URL given by the eMSP or SCSP.

The CPO can limit the amount of request that can be done on the Charging Profiles interface, this too prevent creating a too high load or data usages.
To do this the CPO can reject a request on the Charging Profile Receiver interface be responding with: TOO_OFTEN.

If the Sender  (typically eMSP or SCSP) wants to have a reference between the calls send to the Receivers interface and the asynchronous result received from the Charge Point via the CPO,
the Sender can make some unique identifier part of the`response_url` that is part of every method in the Receiver interface.
The Receiver will call this URL when the result is received from the Charge Point. The Sender can then match the unique identifier from the URL called with the request.


==== Example of setting/updating a ChargingProfile by the Sender (typically the SCSP or eMSP)

When a new <<mod_sessions_session_object,Session>> is started,
or when an update to an existing <<mod_sessions_session_object,Session>> is available,
the CPO sends the Session object to the eMSP or SCSP.
The eMSP or SCSP calculates a Charging Profile and sends it to the CPO by calling the Charging Profiles <<mod_charging_profiles_cpo_put_method,PUT>> method on the Receiver interface.

The CPO responds to the eMSP or SCSP, the response body will contain the response to the request,
acknowledging the request was understood and can be forwarded to the Charge Point.

The CPO sends the requests to the Charge Point.
When the CPO receives a response from the Charge Point,
that result is sent to the eMSP or SCSP by call the <<mod_charging_profiles_msp_post_method,POST>> method,
on the URL provided by the eMSP of SCSP in the <<mod_charging_profiles_cpo_put_method,PUT>> request,
this call will contain a <<mod_charging_profiles_charging_profiles_result_object,ChargingProfileResult>> Object.

.Example of a SetChargingProfile.
image::images/sd_charging_profile_set.svg[Example of a SetChargingProfile]


==== Example of a setting/updating a ChargingProfile by the SCSP via the eMSP

When a new Session is started, the CPO sends the Session object to the eMSP, the eMSP forwards the Session object to the SCSP.

When a new <<mod_sessions_session_object,Session>> is started,
or when an update to an existing <<mod_sessions_session_object,Session>> is available,
the CPO sends the Session object to the eMSP.
The eMSP forwards the <<mod_sessions_session_object,Session>> Object to the SCSP.
The SCSP calculates a Charging Profile and sends it to the eMSP by calling the Charging Profiles <<mod_charging_profiles_cpo_put_method,PUT>> method on the Sender interface implemented by the eMSP.
The eMSP forwards it to the CPO by calling the Charging Profiles <<mod_charging_profiles_cpo_put_method,PUT>> method on the Receiver interface.

The CPO responds to the eMSP, the response body will contain the response to the request,
acknowledging the request was understood and can be forwarded to the Charge Point.
The eMSP forwards this response to the SCSP.

The CPO sends the requests to the Charge Point.
When the CPO receives a response from the Charge Point,
that result is send to the eMSP by call the <<mod_charging_profiles_msp_post_method,POST>> method,
on the URL provided by the eMSP in the <<mod_charging_profiles_cpo_put_method,PUT>> request of the eMSP.
The eMSP forwards this result to the the URL provided by the SCSP in the <<mod_charging_profiles_cpo_put_method,PUT>> request of the SCSP,
this call will contain a <<mod_charging_profiles_charging_profiles_result_object,ChargingProfileResult>> Object.

.Example of a SetChargingProfile via the MSP.
image::images/sd_charging_profile_set_via_msp.svg[Example of a SetChargingProfile via the MSP]


====  Example of a removing/clearing ChargingProfile sent by the Sender (typically the eMSP or SCSP)

The Sender might want to remove the charging profile,
for example the EV driver has selected to switch to charging with the highest speed possible.
The Sender can ask the CPO to remove the set charging profile.
This can be done by calling the <<mod_charging_profiles_cpo_delete_method,DELETE>> method on the Receiver interface.

The CPO responds to the eMSP or SCSP, the response body will contain the response to the request,
acknowledging the request was understood and can be forwarded to the Charge Point.

The CPO sends the clear requests to the Charge Point.
When the CPO receives a response from the Charge Point,
that result is sent to the eMSP by call the <<mod_charging_profiles_msp_post_method,POST>> method,
on the URL provided by the eMSP in the <<mod_charging_profiles_cpo_delete_method,DELETE>> request of the eMSP,
this call will contain a <<mod_charging_profiles_clear_profiles_result_object,ClearProfileResult>> Object.

.Example of a ClearChargingProfile.
image::images/sd_charging_profile_clear.svg[Example of a ClearChargingProfile]


====  Example of a removing/clearing ChargingProfile send by the SCSP via the eMSP

The SCSP might want to remove the charging profile,
for example the EV driver has selected to switch to charging with the highest speed possible.
The SCSP can ask the eMSP to ask the CPO to remove the set charging profile.
This can be done by calling the <<mod_charging_profiles_cpo_delete_method,DELETE>> method on the eMSPs Charging Profile Receiver interface.
The eMSP forwards this to the CPO by calling
the <<mod_charging_profiles_cpo_delete_method,DELETE>> method on the CPOs Charging Profile Receiver interface.

The CPO responds to the eMSP, the response body will contain the response to the request,
acknowledging the request was understood and can be forwarded to the Charge Point.
The eMSP forwards this response to the SCSP.

The CPO send the clear requests to the Charge Point.
When the CPO receives a response from the Charge Point,
that result is sent to the eMSP by call the <<mod_charging_profiles_msp_post_method,POST>> method,
on the URL provided by the eMSP in the <<mod_charging_profiles_cpo_delete_method,DELETE>> request of the eMSP.
The eMSP forwards this result to the the URL provided by the SCSP in the <<mod_charging_profiles_cpo_delete_method,DELETE>> request of the SCSP,
this call will contain a <<mod_charging_profiles_clear_profiles_result_object,ClearProfileResult>> Object.

.Example of a ClearChargingProfile via the MSP.
image::images/sd_charging_profile_clear_via_msp.svg[Example of a ClearChargingProfile via the MSP]


==== Example of a GET ActiveChargingProfile send by the Sender (typically the eMSP or SCSP)

When the Sender wants to know the current planned charging profile for a session,
the Sender can ask the CPO for the ActiveChargingProfile by calling the <<mod_charging_profiles_cpo_get_method,GET>> method on the Receiver interface.

The CPO responds to the eMSP or SCSP, the response body will contain the response to the request,
acknowledging the request was accepted and can be forwarded to the Charge Point.

The CPO sends a message to the Charge Point to retrieve the current active charging profile.
When the CPO receives a response from the Charge Point,
that ActiveChargingProfile is send to the eMSP by call the <<mod_charging_profiles_msp_post_method,POST>> method,
on the URL provided by the eMSP in the <<mod_charging_profiles_cpo_put_method,GET>> request of the eMSP,
this call will contain a <<mod_charging_profiles_active_charging_profiles_result_object,ActiveChargingProfileResult>> Object.

.Example of a GET ActiveChargingProfile.
image::images/sd_charging_profile_get.svg[Example of a GET ActiveChargingProfile]


==== Example of a GET ActiveChargingProfile send by the SCSP via eMSP

When the SCSP wants to known the current planned charging profile for a session,
the SCSP can ask the the eMSP to ask the CPO for the ActiveChargingProfile by calling the <<mod_charging_profiles_cpo_get_method,GET>> method on the eMSPs Charging Profile Receiver interface.
The eMSP forwards this to the CPO by calling the <<mod_charging_profiles_cpo_get_method,GET>> method on the CPOs Charging Profile Receiver interface.

The CPO responds to the eMSP, the response body will contain the response to the request,
acknowledging the request was accepted and can be forwarded to the Charge Point.
The eMSP forwards this response to the SCSP.

The CPO sends a message to the Charge Point to retrieve the current active charging profile.
When the CPO receives a response from the Charge Point,
that ActiveChargingProfile is send to the eMSP by call the <<mod_charging_profiles_msp_post_method,POST>> method,
on the URL provided by the eMSP in the <<mod_charging_profiles_cpo_get_method,GET>> request of the eMSP,
this call will contain a <<mod_charging_profiles_active_charging_profiles_result_object,ActiveChargingProfileResult>> Object.
The eMSP forwards this result to the the URL provided by the SCSP in the <<mod_charging_profiles_cpo_get_method,GET>> request of the SCSP,
this call will contain the same <<mod_charging_profiles_active_charging_profiles_result_object,ActiveChargingProfileResult>> Object.

.Example of a GET ActiveChargingProfile via the MSP.
image::images/sd_charging_profile_get_via_msp.svg[Example of a GET ActiveChargingProfile via the MSP]


====  Example of the Receiver (typically the CPO) sending an updated ActiveChargingProfile

When the CPO knows the ActiveChargingProfile of a Charge Point has changed,
the Receiver (typically the CPO) sends this update <<mod_charging_profiles_active_charging_profile_class,ActiveChargingProfile>> to the Sender (typically the eMSP or SCSP),
by calling the <<mod_charging_profiles_msp_put_method,PUT>> method on the Sender interface.

.Example of an ActiveChargingProfile being send by the CPO
image::images/sd_charging_profile_updated.svg[Example of an ActiveChargingProfile being send by the CPO]


====  Example of the Receiver (typically the CPO) sending an updated ActiveChargingProfile to the SCSP via the eMSP

When the CPO knows the ActiveChargingProfile of a Charge Point has changed,
the Receiver (typically the CPO) sends this update <<mod_charging_profiles_active_charging_profile_class,ActiveChargingProfile>> to the Sender (SCSP),
by calling the <<mod_charging_profiles_msp_put_method,PUT>> method on the eMSPs Sender interface.

The eMSP forwards this <<mod_charging_profiles_active_charging_profile_class,ActiveChargingProfile>> to the SCSP,
by calling the <<mod_charging_profiles_msp_put_method,PUT>> method on the SCSPs Sender interface.

.Example of an ActiveChargingProfile being sent by the CPO via the eMSP
image::images/sd_charging_profile_updated_via_msp.svg[Example of an ActiveChargingProfile being sent by the CPO to the SCSP via the eMSP]


[[mod_charging_profiles_interfaces_and_endpoints]]
=== Interfaces and endpoints

The ChargingProfiles module consists of two interfaces: a Receiver interface that enables a Sender (and its clients) to send ChargingProfiles to a Location/EVSE,
and an Sender interface to receive the response from the Location/EVSE asynchronously.

[[mod_charging_profiles_cpo_interface]]
==== Receiver Interface

Typically implemented by market roles like: CPO.

Example endpoint structures:

[cols="2,12",options="header"]
|===
|Method |Description

|<<mod_charging_profiles_cpo_get_method,GET>> |Gets the ActiveChargingProfile for a specific charging session.
|POST |n/a
|<<mod_charging_profiles_cpo_put_method,PUT>> |Creates/updates a ChargingProfile for a specific charging session.
|PATCH |n/a
|<<mod_charging_profiles_cpo_delete_method,DELETE>> |Cancels an existing ChargingProfile for a specific charging session.
|===

[[mod_charging_profiles_cpo_get_method]]
===== *GET* Method

Retrieves the ActiveChargingProfile as it is currently planned for the the given session.

Endpoint structure definition:

`{chargingprofiles_endpoint_url}{session_id}?duration={duration}&response_url={url}`

Example:

`+https://www.cpo.com/ocpi/2.2/chargingprofiles/1234?duration=900&response_url=https://www.msp.com/ocpi/2.2/chargingprofile/response?request_id=5678+`

NOTE: As it is not common to add a body to a GET request, all parameters are added to the URL.

[[mod_charging_profiles_msp_get_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description

|session_id |<<types_cistring_type,CiString>>(36) |yes |The unique id that identifies the session in the CPO platform.
|duration |int |1 |Length of the requested ActiveChargingProfile in seconds Duration in seconds. *
|response_url |<<types_url_type,URL>> |1 |URL that the <<mod_charging_profiles_active_charging_profiles_result_object,ActiveChargingProfileResult>> POST should be send to. This URL might contain an unique ID to be able to distinguish between GET ActiveChargingProfile requests.
|===

NOTE: duration: Balance the duration between maximizing the information gained and the data usage and computation to execute on the request.
Warning: asking for longer duration than necessary might result in additional data costs, while its added value diminishes with every change in the schedule.


[[mod_charging_profiles_get_response_data]]
====== Response Data

The response contains the direct response from the Receiver, not the response from the EVSE itself.
That information will be sent via an asynchronous POST on the Sender interface if this response is `ACCEPTED`.

[cols="4,1,12",options="header"]
|===
|Datatype |Card. |Description

|<<mod_charging_profiles_response_object,ChargingProfileResponse>> |1 |Result of the ActiveChargingProfile request,
                                    by the Receiver (Typically CPO), not the location/EVSE. So this indicates if the Receiver understood the ChargingProfile request and was able to send it to the EVSE.
                                    This is not the response by the Charge Point.
|===


[[mod_charging_profiles_cpo_put_method]]
===== *PUT* Method

Creates a new ChargingProfile on a session, or replaces an existing ChargingProfile on the EVSE.

Endpoint structure definition:

`{chargingprofiles_endpoint_url}{session_id}`

Example:

`+https://www.cpo.com/ocpi/2.2/chargingprofiles/1234+`

[[mod_charging_profiles_msp_put_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description

|session_id |<<types_cistring_type,CiString>>(36) |yes |The unique id that identifies the session in the CPO platform.
|===

[[mod_charging_profiles_msp_put_request_body]]
===== Request Body

The body contains a SetChargingProfile object, that contains the new ChargingProfile and a response URL.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description

|<<mod_charging_profiles_set_charging_profile_object,SetChargingProfile>> |1 |SetChargingProfile object with information needed to set/update the Charging Profile for a session.
|===


[[mod_charging_profiles_put_response_data]]
====== Response Data

The response contains the direct response from the Receiver (Typically CPO), not the response from the EVSE itself,
that will be sent via an asynchronous POST on the Sender interface if this response is `ACCEPTED`.

[cols="4,1,12",options="header"]
|===
|Datatype |Card. |Description

|<<mod_charging_profiles_response_object,ChargingProfileResponse>> |1 |Result of the ChargingProfile PUT request, by the CPO (not the location/EVSE). So this indicates if the CPO understood the ChargingProfile PUT request and was able to send it to the EVSE. This is not the response by the Charge Point.
|===


[[mod_charging_profiles_cpo_delete_method]]
===== *DELETE* Method

Clears the ChargingProfile set by the eMSP on the given session.

Endpoint structure definition:

`{chargingprofiles_endpoint_url}{session_id}?response_url={url}`

Example:

`+https://www.cpo.com/ocpi/2.2/chargingprofiles/1234?response_url=https://www.server.com/example+`

NOTE: As it is not common to add a body to a DELETE request, all parameters are added to the URL.

[[mod_charging_profiles_msp_delete_request_parameters]]
====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description

|session_id |<<types_cistring_type,CiString>>(36) |yes |The unique id that identifies the session in the CPO platform.
|response_url |<<types_url_type,URL>> |1 |URL that the <<mod_charging_profiles_clear_profiles_result_object,ClearProfileResult>> POST should be send to. This URL might contain an unique ID to be able to distinguish between DELETE ChargingProfile requests.
|===

[[mod_charging_profiles_delete_response_data]]
====== Response Data

The response contains the direct response from the Receiver (typically CPO), not the response from the EVSE itself,
that will be sent via an asynchronous POST on the Sender interface if this response is `ACCEPTED`.

[cols="4,1,12",options="header"]
|===
|Datatype |Card. |Description

|<<mod_charging_profiles_response_object,ChargingProfileResponse>> |1 |Result of the ChargingProfile DELETE request, by the CPO (not the location/EVSE). So this indicates if the CPO understood the ChargingProfile DELETE request and was able to send it to the EVSE. This is not the response by the Charge Point.
|===


[[mod_charging_profiles_emsp_interface]]
==== Sender Interface

Typically implemented by market roles like: SCSP.

The Sender interface receives the asynchronous responses.

[cols="2,12",options="header"]
|===
|Method |Description

|GET |n/a
|<<mod_charging_profiles_msp_post_method,POST>> |Receive the asynchronous response from the Charge Point.
|<<mod_charging_profiles_msp_put_method,PUT>> |Receiver (typically CPO) can send an updated ActiveChargingProfile when other inputs have made changes to existing profile.
        When the Receiver (typically CPO) sends a update profile to the EVSE, for an other reason then the Sender (Typically SCSP) asking, the Sender SHALL post an update to this interface.
        When a local input influence the ActiveChargingProfile in the EVSE AND the Receiver (typically CPO) is made aware of this, the Receiver SHALL post an update to this interface.
|PUT |n/a
|PATCH |n/a
|DELETE |n/a
|===


[[mod_charging_profiles_msp_post_method]]
===== *POST* Method

[[mod_charging_profiles_cpo_post_request_parameters]]
====== Request Parameters

There are no URL segment parameters required by OCPI.

As the Sender interface is called by the Receiver (typically CPO) on the URL given `response_url` in the Sender request to the Receiver interface.
It is up to the implementation of the Sender (typically SCSP) to determine what parameters are put in the URL.
The Sender sends a URL in the POST method body to the Receiver.
The Receiver is required to use this URL for the asynchronous response by the Charge Point.
It is advised to make this URL unique for every request to differentiate simultaneous commands,
for example by adding a unique id as a URL segment.

Endpoint structure definition:

No structure defined. This is open to the eMSP to define, the URL is provided to the Receiver by the Sender.
Therefor OCPI does not define variables.

Examples:

`+https://www.server.com/ocpi/2.2/chargingprofiles/chargingprofile/12345678+`

`+https://www.server.com/activechargingprofile/12345678+`

`+https://www.server.com/clearprofile?request_id=12345678+`

`+https://www.server.com/ocpi/2.2/12345678+`

The content of the request body depends on the original request by the eMSP to which this POST is send as a result.

[[mod_charging_profiles_cpo_post_request_body]]
===== Request Body

[cols="4,1,12",options="header"]
|===
|Datatype |Card. |Description

|_Choice: one of three_ | |
|<<mod_charging_profiles_active_charging_profiles_result_object,ActiveChargingProfileResult>> |1 |Result of the GET ActiveChargingProfile request, from the Charge Point.
|<<mod_charging_profiles_charging_profiles_result_object,ChargingProfileResult>> |1 |Result of the PUT ChargingProfile request, from the Charge Point.
|<<mod_charging_profiles_clear_profiles_result_object,ClearProfileResult>> |1 |Result of the DELETE ChargingProfile request, from the Charge Point.
|===

===== Response Body

The response to the POST on the Sender interface SHALL contain the <<transport_and_format_response_format,Response Format>> with the data field omitted.


[[mod_charging_profiles_msp_put_method]]
===== *PUT* Method

Updates the Sender (typically SCSP) when the Receiver (typically CPO) knows the ActiveChargingProfile has changed.

The Receiver SHALL call this interface every time it knows changes have been made that influence the ActiveChargingProfile for an ongoing session AND
the Sender has at least once successfully called the charging profile Receiver PUT interface for this session (SetChargingProfile).
If the Receiver doesn't know the ActiveChargingProfile has changed (EVSE does not notify the Receiver (typically CPO) of the change) it is not required to call this interface.

The Receiver SHALL NOT call this interface for any session where the Sender has never, successfully called the charging profile Receiver PUT interface for this session (SetChargingProfile).

The Receiver SHALL send a useful relevant duration of ActiveChargingProfile to send to the Sender. As a guide: between 5 and 60 minutes.
If the Sender wants a longer ActiveChargingProfile the Sender can always do a GET with a longer duration.

Endpoint structure definition:

`{chargingprofiles_endpoint_url}{session_id}`

Example:

`+https://www.server.com/ocpi/2.2/chargingprofiles/1234+`

[[mod_charging_profiles_cpo_put_request_parameters]]
====== Request Parameters


The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description

|session_id |<<types_cistring_type,CiString>>(36) |yes |The unique id that identifies the session in the CPO platform.
|===

[[mod_charging_profiles_cpo_put_request_body]]
===== Request Body

The body contains the update ActiveChargingProfile, The ActiveChargingProfile is the charging profile as calculated by the EVSE.

[cols="4,1,12",options="header"]
|===
|Type |Card. |Description

| <<mod_charging_profiles_active_charging_profile_class,ActiveChargingProfile>> | 1 | The new ActiveChargingProfile. If there is no longer any charging profile active, the ActiveChargingProfile SHALL reflect this by showing the maximum charging capacity of the EVSE.
|===

===== Response Body

The response to the PUT on the eMSP interface SHALL contain the <<transport_and_format_response_format,Response Format>> with the data field omitted.



[[mod_charging_profiles_object_description]]
=== Object description


[[mod_charging_profiles_response_object]]
==== _ChargingProfileResponse_ Object

The ChargingProfileResponse object is send in the HTTP response body.

Because OCPI does not allow/require retries, it could happen that the asynchronous result url given by the eMSP is never successfully called.
The eMSP might have had a glitch, HTTP 500 returned, was offline for a moment etc.
For the eMSP to be able to reject to timeouts, it is important for the eMSP to known the timeout on a certain command.

[cols="2,5,1,9",options="header"]
|===
|Property |Type |Card. |Description

|result |<<mod_charging_profiles_responsetype_enum,ChargingProfileResponseType>> |1 |Response from the CPO on the ChargingProfile request.
|timeout |int |1 |Timeout for this ChargingProfile request in seconds. When the Result is not received within this timeout, the eMSP can assume that the message might never be sent.
|===


[[mod_charging_profiles_active_charging_profiles_result_object]]
==== _ActiveChargingProfileResult_ Object

The ActiveChargingProfileResult object is send by the CPO to the given `response_url` in a POST request.
It contains the result of the GET (ActiveChargingProfile) request send by the eMSP.

[cols="2,4,1,10",options="header"]
|===
|Property |Type |Card. |Description
|result | <<mod_charging_profiles_resulttype_enum,ChargingProfileResultType>> | 1 | The EVSE will indicate if it was able to process the request for the ActiveChargingProfile
|profile | <<mod_charging_profiles_active_charging_profile_class,ActiveChargingProfile>> | ? | The requested ActiveChargingProfile, if the result field is set to: `ACCEPTED`
|===


[[mod_charging_profiles_charging_profiles_result_object]]
==== _ChargingProfileResult_ Object

The ChargingProfileResult object is send by the CPO to the given `response_url` in a POST request.
It contains the result of the PUT (SetChargingProfile) request send by the eMSP.

[cols="2,4,1,10",options="header"]
|===
|Property |Type |Card. |Description
|result | <<mod_charging_profiles_resulttype_enum,ChargingProfileResultType>> | 1 | The EVSE will indicate if it was able to process the new/updated charging profile.
|===


[[mod_charging_profiles_clear_profiles_result_object]]
==== _ClearProfileResult_ Object

The ClearProfileResult object is send by the CPO to the given `response_url` in a POST request.
It contains the result of the DELETE (ClearProfile) request send by the eMSP.

[cols="2,4,1,10",options="header"]
|===
|Property |Type |Card. |Description
|result | <<mod_charging_profiles_resulttype_enum,ChargingProfileResultType>> | 1 | The EVSE will indicate if it was able to process the removal of the charging profile (ClearChargingProfile).
|===


[[mod_charging_profiles_set_charging_profile_object]]
==== _SetChargingProfile_ Object

Object set to a CPO to set a Charging Profile.

[cols="3,4,1,9",options="header"]
|===
|Property |Type |Card. |Description
|charging_profile |<<mod_charging_profiles_charging_profile_class,ChargingProfile>> |1 | Contains limits for the available power or current over time.
|response_url      | <<types_url_type,URL>> |1 |URL that the ChargingProfileResult POST should be send to. This URL might contain an unique ID to be able to distinguish between GET ActiveChargingProfile requests.
|===


[[mod_charging_profiles_data_types]]
=== Data types

[[mod_charging_profiles_active_charging_profile_class]]
==== ActiveChargingProfile _class_

[cols="3,3,1,9",options="header"]
|===
|Property           |Type |Card. |Description
|start_date_time    |<<types_datetime_type,DateTime>> | 1 | Date and time at which the Charge Point has calculated this ActiveChargingProfile. All time measurements within the profile are relative to this timestamp.
|charging_profile   |<<mod_charging_profiles_charging_profile_class,ChargingProfile>> | 1 | Charging profile structure defines a list of charging periods.
|===


[[mod_charging_profiles_chargingrateunit]]
==== ChargingRateUnit _enum_

Unit in which a charging profile is defined.

[cols="3,10",options="header"]
|===
|Value |Description
|W | Watts (power) +
This is the TOTAL allowed charging power.
If used for AC Charging, the phase current should be calculated via: Current per phase = Power / (Line Voltage * Number of Phases).
The "Line Voltage" used in the calculation is the Line to Neutral Voltage (VLN). In Europe and Asia VLN is typically 220V or 230V and the corresponding Line to Line Voltage (VLL) is 380V and 400V.
The "Number of Phases" is the numberPhases from the ChargingProfilePeriod.
It is usually more convenient to use this for DC charging.
Note that if numberPhases in a ChargingProfilePeriod is absent, 3 SHALL be assumed.
|A | Amperes (current) +
The amount of Ampere per phase, not the sum of all phases.
It is usually more convenient to use this for AC charging.
|===



[[mod_charging_profiles_charging_profile_class]]
==== ChargingProfile _class_

Charging profile class defines a list of charging periods.

[cols="4,4,1,7",options="header"]
|===
|Property                |Type       |Card. |Description
|start_date_time         | <<types_datetime_type,DateTime>>           | ?    | Starting point of an absolute profile. If absent the profile will be relative to start of charging.
|duration                | int                                                       | ?    | Duration of the charging profile in seconds. If the duration is left empty, the last period will continue indefinitely or until end of the transaction in case startProfile is absent.
|charging_rate_unit      | <<mod_charging_profiles_chargingrateunit,ChargingRateUnit>> | 1    |  The unit of measure.
|min_charging_rate       | <<types_number_type,number>>               | ?    | Minimum charging rate supported by the EV. The unit of measure is defined by the chargingRateUnit. This parameter is intended to be used by a local smart charging algorithm to optimize the power allocation for in the case a charging process is inefficient at lower charging rates. Accepts at most one digit fraction (e.g. 8.1)
|charging_profile_period | <<mod_charging_profiles_charging_profile_period_class,ChargingProfilePeriod>> | * | List of ChargingProfilePeriod elements defining maximum power or current usage over time.
|===


[[mod_charging_profiles_charging_profile_period_class]]
==== ChargingprofilePeriod _class_

Charging profile period structure defines a time period in a charging profile, as used in: <<mod_charging_profiles_charging_profile_class,ChargingProfile>>

[cols="3,2,1,10",options="header"]
|===
|Property      |Type     |Card. |Description
|start_period  | int     | 1 | Start of the period, in seconds from the start of profile. The value of StartPeriod also defines the stop time of the previous period.
|limit         | <<types_number_type,number>> | 1 | Charging rate limit during the profile period, in the applicable chargingRateUnit, for example in Amperes (A) or Watts (W). Accepts at most one digit fraction (e.g. 8.1).
|===


[[mod_charging_profiles_responsetype_enum]]
==== ChargingProfileResponseType _enum_

Response to the ChargingProfile request from the eMSP to the CPO.

[cols="3,10",options="header"]
|===
|Value |Description

|ACCEPTED        |ChargingProfile request accepted by the CPO, request will be forwarded to the EVSE.
|NOT_SUPPORTED   |The ChargingProfiles not supported by this CPO, Charge Point, EVSE etc.
|REJECTED        |ChargingProfile request rejected by the CPO. (Session might not be from a customer of the eMSP that send this request)
|TOO_OFTEN       |ChargingProfile request rejected by the CPO, requests are send more often then allowed.
|UNKNOWN_SESSION |The Session in the requested command is not known by this CPO.
|===


[[mod_charging_profiles_resulttype_enum]]
==== ChargingProfileResultType _enum_

Result of a ChargingProfile request that the EVSE sends via the CPO to the eMSP.

[cols="3,10",options="header"]
|===
|Value |Description
|ACCEPTED |ChargingProfile request accepted by the EVSE.
|REJECTED |ChargingProfile request rejected by the EVSE.
|UNKNOWN |No Charging Profile(s) were found by the EVSE matching the request.
|===


<<<

:numbered:
[[mod_hub_client_info_module]]
== _HubClientInfo_ module

*Module Identifier: `hubclientinfo`*

*Data owner: `Hub`*

*Type:* Configuration Module

This module provides parties connected to a hub with the connection status of other parties that are connected to a hub that they can communicate with.
So, CPOs know which eMSP and other parties are online and vice versa.

Unlike the usual OCPI modules, this module is between eMSP/CPO and Hub instead of between eMSP and CPO.

=== Scenarios

This section will describe what the expected behavior is when a party receives information of a ConnectionState change.

==== Another Party becomes CONNECTED

Party is (back) online. Request can be sent again.
Every party receiving Client Owned Objects from this party should be prepared to receive Client Owned Objects with URLs
that contain the party_id and country_code of this party.

==== Another Party goes OFFLINE

Connection to party is not available: No requests can be sent.
Do not queue Push messages. When the other party comes back online, it is their responsibility to do a GET to get back in sync.

==== Another Party becomes PLANNED

No requests can be sent to this new party yet.
It can be a good idea to sent some notification to an operator to get into contact with the new party so contracts can be setup.
This state may also be used when a Hub has some configuration indicating which parties have contracts which each other.
When a company does not have a connection configured.
This state may also be sent to parties.

==== Another Party becomes SUSPENDED

Like with OFFLINE, no requests should be sent to this party, they cannot be delivered.

When for example CDRs still have to be delivered, so there is some unfinished business,
parties are advised to get into contact with the other party in another way the OCPI: Call them, send an e-mail.


[[mod_hub_client_info_flow]]
=== Flow and Life-cycle

[[mod_hub_client_info_push_model]]
==== Push model

When the Hub creates a new ClientInfo object they push it to the connected parties by calling <<mod_hub_client_info_client_put,PUT>> 
on the connected party ClientInfo endpoint with the newly created ClientInfo object.

Any changes to ClientInfo in the Hub system are send to the connected party system by calling the <<mod_hub_client_info_client_put,PUT>>
method on the connected party ClientInfo endpoint with the updated ClientInfo.

When the Hub invalidates a ClientInfo object (deleting is not possible), the Hub will send the updated ClientInfo object 
(with the field: status set to SUSPENDED, by calling the <<mod_hub_client_info_client_put,PUT>> method
on the connected party ClientInfo endpoint with the updated ClientInfo object.

When the connected party is not sure about the state or existence of a ClientInfo object in the Hub system, the
connected party can call the <<mod_hub_client_info_hub_get,GET>> to request to ClientInfo object from the Hub system.


[[mod_hub_client_info_pull_model]]
==== Pull model

When a connected party is not sure about the state of the list of known connected parties of a Hub, or wants to request the full
list at the start-up of their system, the connected party can call the <<mod_hub_client_info_hub_get,GET>> on the Hubs ClientInfo endpoint to receive
all ClientInfo objects.
This method is not for operational flow.


==== Still alive check.

The hubs needs to determine if a connection is still "alive".

To do this, the Hub should keep track of the time that has passed since the last message was received from a connected party.
When this is longer then X minutes (when unsure, start with 5 minutes) the Hub should send a: GET to the Version information endpoint.
As the Version information endpoint is always required in OCPI,
and this endpoint is provided by all parties,
and a GET to the versions endpoint does not have any side effects, this is seen as the best way to do an "still-alive"check.


=== Interfaces

There is both a Sender (Typically Hub) as a Receiver interface for ClientInfo.
It is advised to use the Push direction from Sender to connected clients during normal operation.
The Hub interface is meant to be used when the connected client is not 100% sure the ClientInfo cache is still correct.

[[mod_hub_client_info_client_interface]]
==== Receiver Interface

Typically implemented by all parties connecting to a Hub.

With this interface the Hub can push the ClientInfo information to a connected client (eMSP/CPO etc)
Example endpoint structure:
`/ocpi/cpo/2.0/clientinfo/{country_code}/{party_id}`

[cols="2,12",options="header"]
|===
|Method |Description

|<<mod_hub_client_info_client_get,GET>> |Retrieve a ClientInfo object as it is stored in the connected clients system.
|POST |n/a
|<<mod_hub_client_info_client_put,PUT>> |Push new/updated ClientInfo object to the connect client.
|PATCH |n/a
|DELETE |n/a, Use <<mod_hub_client_info_client_put,PUT>>, ClientInfo objects cannot be removed).
|===

[[mod_hub_client_info_client_get]]
===== *GET* Method

If the Hub wants to check the status of a ClientInfo object in the connected clients system it might
GET the object from the connected clients system for validation purposes. The Hub is the owner of the objects,
so it would be illogical if the connected client system had a different status or was missing an object.

====== Request Parameters

The following parameters can be provided as URL segments.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the requested ClientInfo object.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the requested ClientInfo object.
|===

====== Response Data

The response contains the requested object.

|===
|Type |Card. |Description

|<<mod_hub_client_info_hub_client_info_object,ClientInfo>> |1 |The requested ClientInfo object.
|===

[[mod_hub_client_info_client_put]]
===== *PUT* Method

New or updated ClientInfo objects are pushed from the Hub to a connected client.

====== Request Body

In the put request a the new or updated ClientInfo object is send.

|===
|Type |Card. |Description

|<<mod_hub_client_info_hub_client_info_object,ClientInfo>> |1 |New or updated ClientInfo object.
|===

====== Request Parameters

The following parameters can be provided as URL segments.

|===
|Parameter |Datatype |Required |Description

|country_code |<<types_cistring_type,CiString>>(2) |yes |Country code of the eMSP sending this PUT request to the CPO system.
|party_id |<<types_cistring_type,CiString>>(3) |yes |Party ID (Provider ID) of the eMSP sending this PUT request to the CPO system.
|===

====== Example: put a new ClientInfo object

[source,json]
----
PUT To URL: https://www.server.com/ocpi/cpo/2.0/clientinfo/NL/ALL

{
  "country_code": "NL",
  "party_id": "ALL",
  "role": "CPO",
  "status": "PLANNED",
}
----


[[mod_hub_client_info_hub_interface]]
==== Sender Interface

Typically implemented by the Hub.

This interface enables Receivers to request the current list of ClientInfo objects from the Sender, when needed.

[cols="2,12",options="header"]
|===
|Method |Description

|<<mod_hub_client_info_hub_get,GET>> |Get the list of known ClientInfo objects, last updated between the {date_from}
and {date_to} <<transport_and_format_pagination,paginated>>)
|POST |n/a
|PUT |n/a
|PATCH |n/a
|DELETE |n/a
|===

[[mod_hub_client_info_hub_get]]
===== *GET* Method

Fetch information about clients connected to a Hub.

Endpoint structure definition:

`{locations_endpoint_url}?[date_from={date_from}]&amp;[date_to={date_to}]&[offset={offset}]&[limit={limit}]`

Examples:

`+https://www.server.com/ocpi/cpo/2.2/hubclientinfo/?date_from=2019-01-28T12:00:00&date_to=2019-01-29T12:00:00+`

`+https://ocpi.server.com/2.2/hubclientinfo/?offset=50+`

`+https://www.server.com/ocpi/2.2/hubclientinfo/?date_from=2019-01-29T12:00:00&limit=100+`

`+https://www.server.com/ocpi/cpo/2.2/hubclientinfo/?offset=50&limit=100+`


===== Request Parameters

If additional parameters: `{date_from}` and/or `{date_to}` are provided, only ClientInfo objects with (`last_updated`)
between the given `{date_from}` (including) and `{date_to}` (excluding) will be returned.

This request is <<transport_and_format_pagination,paginated>>,
it supports the <<transport_and_format_paginated_request,pagination>> related URL parameters.

[cols="3,2,1,10",options="header"]
|===
|Parameter |Datatype |Required |Description

|date_from |<<types_datetime_type,DateTime>> |no |Only return ClientInfo that have `last_updated` after or equal to this Date/Time (inclusive).
|date_to |<<types_datetime_type,DateTime>> |no |Only return ClientInfo that have `last_updated` up to this Date/Time, but not including (exclusive).
|offset |int |no |The offset of the first object returned. Default is 0.
|limit |int |no |Maximum number of objects to GET.

|===

===== Response Data

The endpoint response with list of valid ClientInfo objects, the header will contain
the <<transport_and_format_paginated_response,pagination>> related headers.

Any older information that is not specified in the response is considered as no longer valid.
Each object must contain all required fields. Fields that are not specified may be considered as null values.

|===
|Type |Card. |Description

|<<mod_hub_client_info_hub_client_info_object,ClientInfo>> |* |List of all (or matching) ClientInfo objects.
|===

=== Object description

[[mod_hub_client_info_hub_client_info_object]]
==== _ClientInfo_ Object

[cols="3,3,1,9",options="header"]
|===
|Property |Type |Card. |Description

|party_id |<<types_cistring_type,CiString>>(3) |1 |CPO or eMSP ID of this party (following the 15118 ISO standard), as used in the credentials exchange.
|country_code |<<types_cistring_type,CiString>>(2) |1 |Country code of the country this party is operating in, as used in the credentials exchange.
|role |<<types_role_enum,Role>> |1 |The role of the connected party.
|status |<<mod_hub_client_info_hub_connection_type_enum,ConnectionStatus>> |1 |Status of the connection to the party.
|last_updated |<<types_datetime_type,DateTime>> |1 |Timestamp when this ClientInfo object was last updated.
|===

=== Data types

[[mod_hub_client_info_hub_connection_type_enum]]
==== ConnectionStatus _enum_

[cols="3,10",options="header"]
|===
|Value |Description

|CONNECTED |Party is connected.
|OFFLINE   |Party is currently not connected.
|PLANNED   |Connection to this party is planned, but has never been connected.
|SUSPENDED |Party is now longer active, will never connect anymore.
|===




<<<

:numbered:
[[types_types]]
== Types

[[types_cistring_type]]
=== CiString _type_

Case Insensitive String. Only printable ASCII allowed.
(Non-printable characters like: Carriage returns, Tabs, Line breaks, etc are not allowed)

[[types_datetime_type]]
=== DateTime _type_

All timestamps are formatted as string(25) following RFC 3339, with some additional limitations.

All timestamps SHALL be in UTC.
The absence of the timezone designator implies a UTC timestamp.
Fractional seconds MAY be used.

Example of how timestamps shall be formatted in OCPI, other formats/patterns are not allowed:

[source]
----
2015-06-29T20:39:09Z
2015-06-29T20:39:09
2016-12-29T17:45:09.2Z
2016-12-29T17:45:09.2
2018-01-01T01:08:01.123Z
2018-01-01T01:08:01.123
----

NOTE: +00:00 is not the same as UTC.

[[types_displaytext_class]]
=== DisplayText _class_

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description 

|language |<<types_string_type,string>>(2) |1 |Language Code ISO 639-1. 
|text |<<types_string_type,string>>(512) |1 |Text to be displayed to a end user. No markup, html etc. allowed. 
|===

Example:

[source]
----
include::examples/type_displaytext_example.json[]
----


[[types_number_type]]
=== number _type_

Numbers in OCPI are formatted as JSON numbers.
Unless mentioned otherwise, numbers use 4 decimals and a _sufficiently large amount_ of digits.

[[types_price_class]]
=== Price _class_

[cols="3,2,1,10",options="header"]
|===
|Property |Type |Card. |Description

|excl_vat |<<types_number_type,number>> |1 |Price/Cost excluding VAT.
|incl_vat |<<types_number_type,number>> |? |Price/Cost including VAT.
|===

[[types_role_enum]]
==== Role _enum_

[cols="3,10",options="header"]
|===
|Value |Description

|CPO |Charge Point Operator Role.
|EMSP |eMobility Service Provider Role.
|HUB |Hub role.
|NAP |National Access Point Role (national Database with all Location information of a country).
|NSP |Navigation Service Provider Role, role like an eMSP (probably only interested in Location information).
|OTHER |Other role.
|SCSP|Smart Charging Service Provider Role.
|===


[[types_string_type]]
=== string _type_

Case Sensitive String. Only printable UTF-8 allowed.
(Non-printable characters like: Carriage returns, Tabs, Line breaks, etc are not allowed)

All strings in messages and enumerations are case sensitive, unless explicitly stated
otherwise.

[[types_url_type]]
=== URL _type_

An URL a string(255) type following the http://www.w3.org/Addressing/URL/uri-spec.html[w3.org spec].


<<<

:numbered:
[[changelog_changelog]]
== Changelog

[[changelog_changes_between_ocpi_2.1.1_and_2.2]]
=== Changes between OCPI 2.1.1 and 2.2

Lots of typos fixed and textual improvements.

The following changes to messages/objects etc.

[cols="6,2,2,12",options="header"]
|===
|Context (Module / Object)
|Expected Impact: +
eMSP / CPO
|Expected Effort: +
eMSP / CPO
|Description

|CDRs / +
CDR Object
|Medium / +
Major
|Average / +
Large
|- Added `county_code` and `party_id` fields, making it easier to determine the owner of a CDR. +
- Added `session_id` field, making it easier to match a CDR to a Session. +
- Renamed `stop_date_time` field to `end_date_time`, to bring the naming inline with the rest of OCPI. +
- Changed `total_cost` field from type: `number` to `Price`, this provides the eMSP with the total cost including VAT. +
- Replaced `auth_id` field with `CdrToken`. `auth_id` alone could not be used to uniquely identify a <<mod_tokens_token_object,Token>>. By copying the information for the dynamic Token object, the CDR will always reflect the 'true' status of Token at the start of the charging session. +
- Replaced `location` field with `cdr_location`, this also changed type, from `Location` to `CdrLocation`. Reusing the `Location` object always caused a lot of confusing, things were not clear. By creating a dedicated object `CdrLocation` with only the relevant fields, things should be much clearer. +
- Added `credit` and `credit_reference_id` fields, to allow for Credit CDRs to be send. +
- Added `total_fixed_cost`, `total_energy_cost`, `total_time_cost`, `total_parking_cost` and `total_reservation_cost` fields, to allow more cost details in the CDRs. +
- Added `authorization_reference` field for binding an authorization to the resulting session. +
- Added `signed_data` field, enabling OCPI to be used to transport signed meter data from the Charge Point to the eMSP and EV driver, can be used for Eichrecht. +
- Added `invoice_reference_id` field (optional), to allow a CDRs to reference an invoice. +
- Field `id` changed in length from 36 to 39, to allow for something to be appended after the original id in case of a Credit CDR.

|Commands / +
AuthMethod enum
|Minor / +
Minor
|Minimal / +
Minimal
|Added `COMMAND` value, to enable reporting authorization via Command like: StartSession or ReserveNow.

|CDRs / +
CdrDimensionType enum
|Medium / +
Medium
|Minimal / +
Minimal
|Added `RESERVATION_TIME` value, to enable reporting of cost for a reservation in a Session or CDR.

|CDRs / +
CdrDimensionType enum
|Medium / +
Medium
|Minimal / +
Minimal
|Removed `FLAT` value, that is of no use on a CDR, only causes confusion, should have been removed when CdrDimensionType was created from DimensionType of OCPI 2.0.

|CDRs / +
ChargingPeriod class
|Medium / +
Medium
|Minimal / +
Minimal
|Added `tariff_id` field to ChargingPeriod, when the session switches from one tariff to another, this needs to be known, can be relevant with Preference based Smart Charging.

|ChargingProfiles
|Major / +
Major
|Large / +
Large
|Added new ChargingProfiles module.

|Commands / +
CancelReservation Object
|Minor / +
Minor
|Minimal / +
Minimal
|Added CancelReservation object for the cancel reservation command.

|Commands / +
CommandType Enum
|Minor / +
Minor
|Minimal / +
Minimal
|Added `CANCEL_RESERVATION` value, adding the cancel reservation command.

|Commands / +
CommandResponse Object
|Minor / +
Minor
|Minimal / +
Minimal
|- Added `message` field, enables the CPO to send a message to the user when something goes wrong. +
 - Added `timeout` field, enables the eMSP to cleanup not responded outstanding commands.

|Commands / +
ReserveNow Object
|Minor / +
Medium
|Minimal / +
Average
|- Changed `location_id` and `evse_uids` from string to CiString, making them case-insensitive, which had always been the idea. Lengths changed from 39 to 36, matching changes in the object definitions. +
 - Changed `reservation_id` from int to CiString(36), making it possible to use UUIDs. +
 - Added `authorization_reference` field for binding an authorization to the resulting session. +
 - Changed/added requirements in description of ReserveNow Object.

|Commands / +
StartSession Object
|Minor / +
Medium
|Minimal / +
Average
|- Changed `location_id` and `evse_uids` from string to CiString, making them case-insensitive, which had always been the idea. Lengths changed from 39 to 36, matching changes in the object definitions. +
 - Added `authorization_reference` field for binding an authorization to the resulting session. +
 - Changed/added requirements in description of StartSession Object.

|Commands / +
StopSession Object
|Minor / +
Minor
|Minimal / +
Minimal
|Changed `session_id` from string to CiString, making it case-insensitive, which had always been the idea.

|Commands / +
UnlockConnector Object
|Minor / +
Minor
|Minimal / +
Minimal
|- Changed `location_id`, `evse_uids` and `connector_ids` from string to CiString, making them case-insensitive, which had always been the idea. +
- Length of `location_id` and `evse_uids` changed from 39 to 36, matching changes in the object definitions.

|Commands / +
CommandResponseType Enum
|Minor / +
Minor
|Minimal / +
Minimal
|removed `TIMEOUT` as possible value. This is moved to the new CommandResult object.

|Commands / +
CommandResultType Enum
|Minor / +
Minor
|Minimal / +
Minimal
|added `CANCELED_RESERVATION` value. Make it possible for a CPO to cancel an existing reservation in case of issues with the Charge Point.

|Commands / +
CommandResult Object
|Medium / +
Medium
|Medium / +
Medium
|Changed result message from CPO to eMSP from CommandResponse to CommandResult to make it more clear.

|Credentials / +
Credentials Object
|Minor / +
Minor
|Minimal / +
Minimal
|Changed `country_code` and `party_id` from string to CiString, making them case-insensitive, which had always been the idea. +
Replaced the `business_details`, `party_id` and `country_code` field with a `roles` list. Making it possible to implement different parties and roles in the same OCPI instance. The fields are now moved into a new `CredentialsRole class.

|HubClientInfo
|Medium / +
Medium
|Medium / +
Medium
|Added new HubClientInfo module.

|Locations / +
Sender GET Object method
|Minor / +
Minor
|Minimal / +
Minimal
|- Changed `location_id`, `evse_uids` and `connector_ids` from string to CiString, making them case-insensitive, which had always been the idea. +
- Length of `location_id` and `evse_uids` changed from 39 to 36, matching changes in the object definitions.

|Locations / +
Receiver GET & PUT methods
|Minor / +
Minor
|Minimal / +
Minimal
|- Changed `country_code`, `party_id`, `location_id`, `evse_uids` and `connector_ids` from string to CiString, making them case-insensitive, which had always been the idea. +
- Length of `location_id` and `evse_uids` changed from 39 to 36, matching changes in the object definitions.

|Locations / +
Receiver PATCH method
|Minor / +
Minor
|Minimal / +
Minimal
|- Changed `country_code`, `party_id`, `location_id`, `evse_uids` and `connector_ids` from string to CiString, making them case-insensitive, which had always been the idea. +
- Length of `location_id` and `evse_uids` changed from 39 to 36, matching changes in the object definitions. +
- Added description on how to handle `last_updated`, and made it required for all PATCH requests.


|Locations / +
Connector Object
|Minor / +
Minor
|Minimal / +
Minimal
|- Field `id` is changed from string to CiString, making it now case-insensitive, which had always been the idea. +
- Added `max_electric_power` field, some DC Fast Charger have a lower max power then can be calculated form `voltage` and `amperage`. +
- Changed `tariff_id` field to `tariff_ids`, and changed cardinality from `?` to `*`. Making it possible to make provided tariffs for different Smart Charging Preferences and also for ad hoc payment. Changed type from string to CiString, matching the change to Tariff.id.
- Changed `amperage` field to `max_amperage` and `voltage` field to `max_voltage`, to better reflect the real meaning of both fields.

|Locations / +
EVSE Object
|Minor / +
Minor
|Minimal / +
Minimal
|- Fields `uid` and `evse_id` is changed from string to CiString, making them case-insensitive, which had always been the idea. +
- length of `uid` changed from 39 to 36, as 36 is enough to store UUID and GUIDs.

|Locations / +
Location Object
|Minor / +
Minor
|Minimal / +
Minimal
|- Added `county_code` and `party_id` fields, making it easier to determine the owner of a Location. +
- Field `id` is changed from string to CiString, making it now case-insensitive, which had always been the idea. +
- length changed from 39 to 36, as 36 is enough to store UUID and GUIDs. +
- Added `state` field, optional, to allow as much different address schemes from around the world as possible.. +
- Changed `postal_code` field from required to optional, with the remark that omitting is only allowed when location has no postal_code. +
- Changed `time_zone` field from optional to required, as the opening hours and tariff start/end depend on this, they are more and more important. +
- Renamed `type` field to `parking_type` and made it optional. It better reflects what this field really describes. +
- Added `publish` field, required, to control which locations may or may not be publish in apps etc.
- Added `publish_allowed_to` field, optional, to give access to locations to only a limited set of users.

|Locations / +
AdditionalGeoLocation class
|Minor / +
Minor
|Minimal / +
Minimal
|Changed regex for fields: `latitude` and `longitude` from fixed 6 decimal places, to more flexible 5 to 7 decimal places.

|Locations / +
Capability enum
|Minor / +
Minor
|Minimal / +
Minimal
|added new values for: `CHARGING_PREFERENCES_CAPABLE`, `DEBIT_CARD_PAYABLE` and `TOKEN_GROUP_CAPABLE`.

|Locations / +
ConnectorType enum
|Minor / +
Minor
|Minimal / +
Minimal
|added new values for: `PANTOGRAPH_TOP_DOWN` and `PANTOGRAPH_BOTTOM_UP`.

|Locations / +
EnvironmentalImpact class
|Minor / +
Minor
|Minimal / +
Minimal
|Changed field name from `source` to `category`, this was a copy/past error in an older version of OCPI, as this is not used (much) yet, it is better for understandability of OCPI for correct the field name.

|Locations / +
Facility enum
|Minor / +
Minor
|Minimal / +
Minimal
|added new values for: `BIKE_SHARING`, `PARKING_LOT`, `TRAM_STOP` and `METRO_STATION`.

|Locations / +
GeoLocation class
|Minor / +
Minor
|Minimal / +
Minimal
|Changed regex for fields: `latitude` and `longitude` from fixed 6 decimal places, to more flexible 5 to 7 decimal places.

|Locations / +
Hours class
|Minor / +
Minor
|Minimal / +
Minimal
|removed to option for either: twentyfourseven or regular_hours, now twentyfourseven is always required and regular_hours is required when twentyfourseven=false, this is much less confusing.

|Locations / +
Image class
|Minor / +
Minor
|Minimal / +
Minimal
|Changed field `type` from string to CiString, is for machine to machine communication, so UTF-8 is not needed.

|Locations / +
RegularHours class
|Minor / +
Minor
|Minimal / +
Minimal
|Improved the regex for time format.

|Locations / +
LocationType enum
|Minor / +
Minor
|Minimal / +
Minimal
|Renamed to: `ParkingType` +
Added the values: `ON_DRIVEWAY` and `ALONG_MOTORWAY` +
Removed the values: `OTHER` and `UNKNOWN`, no longer needed as this is now optional.

|Sessions / +
Sender PUT method
|Medium / +
Medium
| Large / +
Large
|Added setting Charging Preferences on a session. Proving the CPO with preferences from the driver, needed for Smart Charging.
  For this the following data types are added: ChargingPreferences, ChargingPreferencesResponse, ProfileType,

|Sessions / +
Receiver GET and PUT methods
|Minor / +
Minor
|Minimal / +
Minimal
|Changed `country_code`, `party_id` and `session_id` from string to CiString, making them case-insensitive, which had always been the idea.

|Sessions / +
Receiver PATCH method
|Minor / +
Minor
|Minimal / +
Minimal
|Changed `country_code`, `party_id` and `session_id` from string to CiString, making them case-insensitive, which had always been the idea. +
Added description and requirements how to add `charging_periods` and made `last_updated` required for all PATCH requests.

|Sessions / +
Session Object
|Minor / +
Medium
|Minimal / +
Average
|- Added `county_code` and `party_id` fields, making it easier to determine the owner of a Session. +
- Field `id` is changed from string to CiString, making it now case-insensitive, which had always been the idea. +
- Changed `total_cost` field from type: `number` to `Price`, this provides the eMSP with the total cost including VAT. +
- Renamed `start_datetime` field to `start_date_time`, to bring the naming inline with the rest of OCPI. +
- Renamed `end_datetime` field to `end_date_time`, to bring the naming inline with the rest of OCPI. +
- Replaced `auth_id` with `CdrToken` class. `auth_id` alone could not be used to uniquely identify a <<mod_tokens_token_object,Token>>. +
- Replaced `location` object with `location_id`, `evse_uid` and `connector_id`. Having the `Location` Object in the `Session` was overkill, only reference is more inline with the rest. +
- Added `authorization_reference` field for binding an authorization to the resulting session.

|Tariffs / +
Receiver PATCH method
|Minor / +
Minor
|Minimal / +
Minimal
|PATCH is removed from Tariffs as this was seen is not useful, use PUT instead.

|Tariffs / +
Tariff Object
|Minor / +
Minor
|Minimal / +
Minimal
|- Added `county_code` and `party_id` fields, making it easier to determine the owner of a Tariff. +
- Field `id` is changed from string to CiString, making it now case-insensitive, which had always been the idea. +
- Renamed `start_datetime` field to `start_date_time`, to bring the naming inline with the rest of OCPI. +
- Renamed `end_datetime` field to `end_date_time`, to bring the naming inline with the rest of OCPI. +
- Added optional `min_price` field, making it possible to set a minimum price on a Charging Session. +
- Added optional `max_price` field, making it possible to set a maximum price on a Charging Session. +
- Added `type` field to make it possible to make different tariffs for different Smart Charging Preferences and also for ad hoc payment.

|Tariffs / +
PriceComponent class
|Minor / +
Minor
|Minimal / +
Minimal
|- Added `vat` field to send the applicable VAT with every tariff component.

|Tariffs / +
ReservationRestrictionType enum
|Minor / +
Minor
|Minimal / +
Minimal
|Added new enum for Reservation restrictions.

|Tariffs / +
TariffRestrictions class
|Minor / +
Minor
|Minimal / +
Minimal
|Added optional `reservation` field, making it possible to define the tariff of a reservation (and an expired reservation). +
Added optional `min_current` and `max_current` field, making it possible to have a tariff that depends on the current being charged, instead of the power. +
Improved the regex for time format.

|Tokens / +
Sender GET & POST methods
|Minor / +
Minor
|Minimal / +
Minimal
|Changed `country_code`, `party_id` and `token_uid` from string to CiString, making them case-insensitive, which had always been the idea.

|Tokens / +
Receiver GET & PUT methods
|Minor / +
Minor
|Minimal / +
Minimal
|Changed `country_code`, `party_id` and `tariff_id` from string to CiString, making them case-insensitive, which had always been the idea. +
Added `token_type` field, making it possible to make a distinction between different Token types with the same `uid`.

|Tokens / +
Receiver PATCH method
|Minor / +
Minor
|Minimal / +
Minimal
|Changed `country_code`, `party_id` and `tariff_id` from string to CiString, making them case-insensitive, which had always been the idea. +
Added `token_type` field, making it possible to make a distinction between different Token types with the same `uid`.
Made `last_updated` required for all PATCH requests.

|Tokens / +
Token Object
|Minor / +
Minor
|Minimal / +
Minimal
|- Added `county_code` and `party_id` fields, making it easier to determine the owner of a Token. +
- Fields `uid` changed from string to CiString, making it now case-insensitive, which had always been the idea. +
- Fields `auth_id_` renamed to `contract_id`, a much more logical and less confusing name. Also changed from string to CiString, making it now case-insensitive, which had always been the idea. +
- Added `group_id` field to enable support for OCPP GroupId/ParentId. +
- Added `default_profile_type` field to enable a default Preference base Smart Charging ProfileType to be provided for a user. +
- Added `energy_contract` field to make it possible, if allowed, to use a drivers energy supplier/contract at a Charge Point.

|Tokens / +
AuthorizationInfo Object
|Minor / +
Medium
|Minimal / +
Average
|Added `token` field to enable real-time authorization of unknown Tokens. +
 Added `authorization_reference` field for binding an authorization to the resulting session.

|Tokens / +
LocationReferences class
|Minor / +
Minor
|Minimal / +
Minimal
|- Changed `location_id` and `evse_uids` from string to CiString, making them case-insensitive, which had always been the idea. +
- Length of `location_id` and `evse_uids` changed from 39 to 36, matching changes in the object definitions. +
- Removed `connector_ids`, this was not usable as they are not unique within the Location, there is also no use case.

|Tokens / +
TokenType enum
|Minor / +
Minor
|Minimal / +
Minimal
|Added value `AD_HOC_USER` and APP_USER`. As more and more eMSPs are launching Apps, this becomes more common, so a special categories are useful.

|Versions / +
Endpoint class
|Medium / +
Medium
|Minimal / +
Minimal
|Field `role` added, making it possible to have one OCPI version end-point for both eMSP and CPO role, so one OCPI connection when both CPO and eMSP implemented by the same party.

|Transport & Format
|Medium / +
Medium
|Medium / +
Medium
|To enable routing of messages through a Hub, new 'OCPI-to-' and 'OCPI-from-' headers are introduced.

|Transport & Format
|Minor / +
Minor
|Minimal / +
Minimal
|Unique message ID and Correlation message ID headers are now required in every request/response.

|Types / +
 DateTime
|Minor / +
Minor
|Minimum / +
Minimum
|Changed to: RFC 3339 (was ISO 8601) this does not change the OCPI format, RFC 3339 is more limited, and therefor more inline with OCPI then ISO 8601 was. +
 Fractional seconds are now allowed.

|Types / +
 string
|Minor / +
Minor
|Minimum / +
Minimum
|Type string changed from ASCII to UTF-8. String is used for human-readable information and thus needed to support for a lot more character sets then only ASCII.
|===




<<<

